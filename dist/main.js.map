{"version":3,"file":"main.js","sources":["../src/magistrates/LegatusArchivus.ts","../src/interfaces/TaskType.ts","../src/magistrates/LegatusOfficio.ts","../src/magistrates/LegatusGenetor.ts","../src/magistrates/LegatusFabrum.ts","../src/magistrates/LegatusViae.ts","../src/execution/TaskResult.ts","../src/execution/TaskExecutor.ts","../src/execution/executors/HarvestExecutor.ts","../src/execution/executors/PickupExecutor.ts","../src/execution/executors/TransferExecutor.ts","../src/execution/executors/UpgradeExecutor.ts","../src/execution/executors/BuildExecutor.ts","../src/execution/executors/RepairExecutor.ts","../src/execution/executors/WithdrawExecutor.ts","../src/execution/executors/DefendExecutor.ts","../src/execution/executors/IdleExecutor.ts","../src/execution/executors/RenewExecutor.ts","../src/execution/ExecutorFactory.ts","../src/magistrates/LegatusLegionum.ts","../src/principate/Empire.ts","../src/main.ts"],"sourcesContent":["/// <reference types=\"screeps\" />\r\n\r\nimport {\r\n  ArchivistReport,\r\n  SourceReport,\r\n  SpawnReport,\r\n  TowerReport,\r\n  ContainerReport,\r\n  ConstructionSiteReport,\r\n  RepairTargetReport,\r\n  ControllerReport,\r\n  HostileReport\r\n} from '../interfaces';\r\n\r\n/**\r\n * Legatus Archivus - The Archivist\r\n * \r\n * Responsibility: Observe and report on room state\r\n * Philosophy: No decisions, no opinions - only data\r\n * \r\n * The Archivist is the eyes and ears of the Magistrates.\r\n * It produces a clean, structured report that other modules consume.\r\n */\r\nexport class LegatusArchivus {\r\n  constructor(readonly roomName: string) {}\r\n\r\n  /**\r\n   * Generate a comprehensive report on the room's current state\r\n   */\r\n  public run(room: Room): ArchivistReport {\r\n    return {\r\n      roomName: room.name,\r\n      rcl: room.controller?.level || 0,\r\n      \r\n      energyAvailable: room.energyAvailable,\r\n      energyCapacityAvailable: room.energyCapacityAvailable,\r\n      energyDeficit: room.energyCapacityAvailable - room.energyAvailable,\r\n      \r\n      sources: this.analyzeSources(room),\r\n      spawns: this.analyzeSpawns(room),\r\n      extensions: room.find(FIND_MY_STRUCTURES, {\r\n        filter: (s) => s.structureType === STRUCTURE_EXTENSION\r\n      }).length,\r\n      towers: this.analyzeTowers(room),\r\n      containers: this.analyzeContainers(room),\r\n      storageAvailable: room.storage !== undefined,\r\n      storageEnergy: room.storage?.store[RESOURCE_ENERGY] || 0,\r\n      \r\n      constructionSites: this.analyzeConstructionSites(room),\r\n      repairTargets: this.analyzeRepairTargets(room),\r\n      \r\n      controller: this.analyzeController(room),\r\n      \r\n      hostiles: this.analyzeHostiles(room),\r\n      hostileThreatLevel: this.calculateThreatLevel(room),\r\n      \r\n      creepsByRole: this.countCreepsByRole(room),\r\n      totalCreeps: this.countTotalCreeps(room),\r\n      \r\n      highTrafficPositions: [] // TODO: Implement traffic analysis\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Analyze all energy sources in the room\r\n   */\r\n  private analyzeSources(room: Room): SourceReport[] {\r\n    const sources = room.find(FIND_SOURCES);\r\n    return sources.map(source => {\r\n      const harvesters = room.find(FIND_MY_CREEPS, {\r\n        filter: (c) => c.memory.role === 'harvester' && \r\n                       c.memory.targetId === source.id\r\n      });\r\n      \r\n      // Calculate available harvesting positions around source\r\n      const availableSpaces = this.countAvailableSpaces(room, source.pos);\r\n      \r\n      return {\r\n        id: source.id,\r\n        pos: { x: source.pos.x, y: source.pos.y },\r\n        energy: source.energy,\r\n        energyCapacity: source.energyCapacity,\r\n        harvestersPresent: harvesters.length,\r\n        harvestersNeeded: availableSpaces // Use actual terrain-based capacity\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Count walkable spaces adjacent to a position\r\n   * This determines how many creeps can actually harvest from a source\r\n   */\r\n  private countAvailableSpaces(room: Room, pos: RoomPosition): number {\r\n    const terrain = room.getTerrain();\r\n    let spaces = 0;\r\n    \r\n    // Check all 8 adjacent tiles\r\n    for (let dx = -1; dx <= 1; dx++) {\r\n      for (let dy = -1; dy <= 1; dy++) {\r\n        if (dx === 0 && dy === 0) continue; // Skip the center (source itself)\r\n        \r\n        const x = pos.x + dx;\r\n        const y = pos.y + dy;\r\n        \r\n        // Check bounds\r\n        if (x < 0 || x > 49 || y < 0 || y > 49) continue;\r\n        \r\n        // Check terrain\r\n        const terrainType = terrain.get(x, y);\r\n        if (terrainType !== TERRAIN_MASK_WALL) {\r\n          spaces++;\r\n        }\r\n      }\r\n    }\r\n    \r\n    return spaces;\r\n  }\r\n\r\n  /**\r\n   * Analyze all spawn structures in the room\r\n   */\r\n  private analyzeSpawns(room: Room): SpawnReport[] {\r\n    const spawns = room.find(FIND_MY_SPAWNS);\r\n    return spawns.map(spawn => ({\r\n      id: spawn.id,\r\n      spawning: spawn.spawning !== null,\r\n      energy: spawn.store[RESOURCE_ENERGY],\r\n      energyCapacity: spawn.store.getCapacity(RESOURCE_ENERGY)\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Analyze all tower structures in the room\r\n   */\r\n  private analyzeTowers(room: Room): TowerReport[] {\r\n    const towers = room.find(FIND_MY_STRUCTURES, {\r\n      filter: (s) => s.structureType === STRUCTURE_TOWER\r\n    }) as StructureTower[];\r\n    \r\n    return towers.map(tower => ({\r\n      id: tower.id,\r\n      energy: tower.store[RESOURCE_ENERGY],\r\n      energyCapacity: tower.store.getCapacity(RESOURCE_ENERGY),\r\n      needsRefill: tower.store[RESOURCE_ENERGY] < tower.store.getCapacity(RESOURCE_ENERGY) * 0.5\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Analyze all container structures in the room\r\n   */\r\n  private analyzeContainers(room: Room): ContainerReport[] {\r\n    const containers = room.find(FIND_STRUCTURES, {\r\n      filter: (s) => s.structureType === STRUCTURE_CONTAINER\r\n    }) as StructureContainer[];\r\n    \r\n    return containers.map(container => ({\r\n      id: container.id,\r\n      pos: { x: container.pos.x, y: container.pos.y },\r\n      store: { energy: container.store[RESOURCE_ENERGY] },\r\n      storeCapacity: container.store.getCapacity(RESOURCE_ENERGY)\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Analyze all construction sites in the room\r\n   */\r\n  private analyzeConstructionSites(room: Room): ConstructionSiteReport[] {\r\n    const sites = room.find(FIND_MY_CONSTRUCTION_SITES);\r\n    return sites.map(site => ({\r\n      id: site.id,\r\n      structureType: site.structureType,\r\n      progress: site.progress,\r\n      progressTotal: site.progressTotal,\r\n      pos: { x: site.pos.x, y: site.pos.y }\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Analyze all structures that need repair\r\n   */\r\n  private analyzeRepairTargets(room: Room): RepairTargetReport[] {\r\n    const structures = room.find(FIND_STRUCTURES, {\r\n      filter: (s) => s.hits < s.hitsMax && s.structureType !== STRUCTURE_WALL\r\n    });\r\n    \r\n    return structures.map(structure => ({\r\n      id: structure.id,\r\n      structureType: structure.structureType,\r\n      hits: structure.hits,\r\n      hitsMax: structure.hitsMax,\r\n      priority: this.calculateRepairPriority(structure),\r\n      pos: { x: structure.pos.x, y: structure.pos.y }\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Calculate repair priority for a structure based on type and condition\r\n   */\r\n  private calculateRepairPriority(structure: Structure): number {\r\n    const hitPercent = structure.hits / structure.hitsMax;\r\n    \r\n    // Critical structures get higher priority\r\n    const criticalStructures: StructureConstant[] = [\r\n      STRUCTURE_SPAWN,\r\n      STRUCTURE_TOWER,\r\n      STRUCTURE_STORAGE,\r\n      STRUCTURE_TERMINAL\r\n    ];\r\n    \r\n    if ((criticalStructures as StructureConstant[]).includes(structure.structureType)) {\r\n      return hitPercent < 0.5 ? 90 : 70;\r\n    }\r\n    \r\n    return hitPercent < 0.3 ? 50 : 30;\r\n  }\r\n\r\n  /**\r\n   * Analyze the room controller status\r\n   */\r\n  private analyzeController(room: Room): ControllerReport {\r\n    const controller = room.controller!;\r\n    return {\r\n      id: controller.id,\r\n      level: controller.level,\r\n      progress: controller.progress,\r\n      progressTotal: controller.progressTotal,\r\n      ticksToDowngrade: controller.ticksToDowngrade || 0,\r\n      upgraderCount: this.countUpgraders(room),\r\n      upgraderRecommendation: this.recommendUpgraders(controller)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Count how many upgrader creeps are currently active\r\n   */\r\n  private countUpgraders(room: Room): number {\r\n    return room.find(FIND_MY_CREEPS, {\r\n      filter: (c) => c.memory.role === 'upgrader'\r\n    }).length;\r\n  }\r\n\r\n  /**\r\n   * Recommend optimal number of upgraders based on controller level\r\n   */\r\n  private recommendUpgraders(controller: StructureController): number {\r\n    // Simple logic: more upgraders for higher RCL\r\n    if (controller.level < 3) return 1;\r\n    if (controller.level < 5) return 2;\r\n    return 3;\r\n  }\r\n\r\n  /**\r\n   * Analyze all hostile creeps in the room\r\n   */\r\n  private analyzeHostiles(room: Room): HostileReport[] {\r\n    const hostiles = room.find(FIND_HOSTILE_CREEPS);\r\n    return hostiles.map(hostile => ({\r\n      id: hostile.id,\r\n      pos: { x: hostile.pos.x, y: hostile.pos.y },\r\n      owner: hostile.owner.username,\r\n      body: hostile.body.map(part => part.type),\r\n      threatLevel: this.calculateCreepThreat(hostile)\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Calculate threat level of a creep based on body composition\r\n   */\r\n  private calculateCreepThreat(creep: Creep): number {\r\n    let threat = 0;\r\n    creep.body.forEach(part => {\r\n      if (part.type === ATTACK) threat += 3;\r\n      if (part.type === RANGED_ATTACK) threat += 2;\r\n      if (part.type === HEAL) threat += 2;\r\n      if (part.type === TOUGH) threat += 1;\r\n    });\r\n    return threat;\r\n  }\r\n\r\n  /**\r\n   * Calculate overall threat level for the room (0-10 scale)\r\n   */\r\n  private calculateThreatLevel(room: Room): number {\r\n    const hostiles = room.find(FIND_HOSTILE_CREEPS);\r\n    if (hostiles.length === 0) return 0;\r\n    \r\n    const totalThreat = hostiles.reduce((sum, h) => sum + this.calculateCreepThreat(h), 0);\r\n    return Math.min(10, Math.ceil(totalThreat / 5));\r\n  }\r\n\r\n  /**\r\n   * Count creeps by role\r\n   */\r\n  private countCreepsByRole(room: Room): Map<string, number> {\r\n    const creeps = room.find(FIND_MY_CREEPS);\r\n    const counts = new Map<string, number>();\r\n    \r\n    creeps.forEach(creep => {\r\n      const role = creep.memory.role || 'unknown';\r\n      counts.set(role, (counts.get(role) || 0) + 1);\r\n    });\r\n    \r\n    return counts;\r\n  }\r\n\r\n  /**\r\n   * Count total creeps in the room\r\n   */\r\n  private countTotalCreeps(room: Room): number {\r\n    return room.find(FIND_MY_CREEPS).length;\r\n  }\r\n}\r\n","/**\r\n * All possible task types in the Empire\r\n * These represent the fundamental actions a creep can be assigned\r\n */\r\nexport enum TaskType {\r\n  // Energy Management\r\n  HARVEST_ENERGY = 'HARVEST_ENERGY',\r\n  PICKUP_ENERGY = 'PICKUP_ENERGY',\r\n  HAUL_ENERGY = 'HAUL_ENERGY',\r\n  WITHDRAW_ENERGY = 'WITHDRAW_ENERGY',\r\n  \r\n  // Construction & Repair\r\n  BUILD = 'BUILD',\r\n  REPAIR = 'REPAIR',\r\n  \r\n  // Controller Operations\r\n  UPGRADE_CONTROLLER = 'UPGRADE_CONTROLLER',\r\n  \r\n  // Defense\r\n  DEFEND_ROOM = 'DEFEND_ROOM',\r\n  TOWER_DEFENSE = 'TOWER_DEFENSE',\r\n  \r\n  // Logistics\r\n  REFILL_SPAWN = 'REFILL_SPAWN',\r\n  REFILL_EXTENSION = 'REFILL_EXTENSION',\r\n  REFILL_TOWER = 'REFILL_TOWER',\r\n  \r\n  // Special Operations\r\n  CLAIM_CONTROLLER = 'CLAIM_CONTROLLER',\r\n  RESERVE_CONTROLLER = 'RESERVE_CONTROLLER',\r\n  SCOUT_ROOM = 'SCOUT_ROOM',\r\n  RENEW_CREEP = 'RENEW_CREEP',\r\n  \r\n  // Idle/Default\r\n  IDLE = 'IDLE'\r\n}\r\n","import { ArchivistReport, Task, TaskType } from '../interfaces';\r\n\r\n/**\r\n * Legatus Officio - The Taskmaster\r\n * \r\n * Responsibility: Transform observations into actionable tasks\r\n * Philosophy: Every problem is a task waiting to be solved\r\n * \r\n * The Taskmaster reads the Archivist's report and creates a prioritized\r\n * work queue. It doesn't care WHO does the work - just WHAT needs doing.\r\n */\r\nexport class LegatusOfficio {\r\n  private roomName: string;\r\n  private taskIdCounter: number = 0;\r\n\r\n  constructor(roomName: string) {\r\n    this.roomName = roomName;\r\n  }\r\n\r\n  /**\r\n   * Analyze the room report and generate prioritized tasks\r\n   */\r\n  public run(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n\r\n    // Priority 1: Emergency Defense\r\n    if (report.hostileThreatLevel > 0) {\r\n      tasks.push(...this.createDefenseTasks(report));\r\n    }\r\n\r\n    // Priority 2: Spawn Energy (can't do anything without energy)\r\n    if (report.energyDeficit > 0) {\r\n      tasks.push(...this.createEnergyTasks(report));\r\n    }\r\n\r\n    // Priority 3: Tower Maintenance\r\n    if (report.towers.some(t => t.needsRefill)) {\r\n      tasks.push(...this.createTowerRefillTasks(report));\r\n    }\r\n\r\n    // Priority 4: Construction\r\n    if (report.constructionSites.length > 0) {\r\n      tasks.push(...this.createConstructionTasks(report));\r\n    }\r\n\r\n    // Priority 5: Critical Repairs\r\n    const criticalRepairs = report.repairTargets.filter(r => r.priority > 70);\r\n    if (criticalRepairs.length > 0) {\r\n      tasks.push(...this.createRepairTasks(criticalRepairs));\r\n    }\r\n\r\n    // Priority 6: Controller Upgrade\r\n    tasks.push(...this.createUpgradeTasks(report));\r\n\r\n    // Priority 7: Non-Critical Repairs\r\n    const minorRepairs = report.repairTargets.filter(r => r.priority <= 70);\r\n    if (minorRepairs.length > 0) {\r\n      tasks.push(...this.createRepairTasks(minorRepairs));\r\n    }\r\n\r\n    // Priority 8: Renew Creeps (low priority - only when idle and spawn energy available)\r\n    tasks.push(...this.createRenewTasks(report));\r\n\r\n    // Sort by priority (highest first)\r\n    return tasks.sort((a, b) => b.priority - a.priority);\r\n  }\r\n\r\n  private createDefenseTasks(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n    \r\n    report.hostiles.forEach(hostile => {\r\n      tasks.push({\r\n        id: this.generateTaskId(),\r\n        type: TaskType.DEFEND_ROOM,\r\n        priority: 95 + report.hostileThreatLevel,\r\n        targetId: hostile.id,\r\n        targetPos: { x: hostile.pos.x, y: hostile.pos.y, roomName: this.roomName },\r\n        creepsNeeded: Math.ceil(hostile.threatLevel / 10),\r\n        assignedCreeps: []\r\n      });\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createEnergyTasks(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n\r\n    // Pickup dropped energy (highest priority - don't waste energy)\r\n    const room = Game.rooms[this.roomName];\r\n    if (room) {\r\n      const droppedResources = room.find(FIND_DROPPED_RESOURCES, {\r\n        filter: (resource) => resource.resourceType === RESOURCE_ENERGY && resource.amount > 50\r\n      });\r\n      \r\n      droppedResources.forEach(resource => {\r\n        tasks.push({\r\n          id: this.generateTaskId(),\r\n          type: TaskType.PICKUP_ENERGY,\r\n          priority: 88, // Higher than harvest, lower than refill\r\n          targetId: resource.id,\r\n          targetPos: { x: resource.pos.x, y: resource.pos.y, roomName: this.roomName },\r\n          creepsNeeded: 1,\r\n          assignedCreeps: [],\r\n          metadata: {\r\n            energyAmount: resource.amount\r\n          }\r\n        });\r\n      });\r\n    }\r\n\r\n    // Harvest from sources\r\n    report.sources.forEach(source => {\r\n      if (source.energy > 0 && source.harvestersPresent < source.harvestersNeeded) {\r\n        tasks.push({\r\n          id: this.generateTaskId(),\r\n          type: TaskType.HARVEST_ENERGY,\r\n          priority: 85,\r\n          targetId: source.id,\r\n          targetPos: { x: source.pos.x, y: source.pos.y, roomName: this.roomName },\r\n          creepsNeeded: source.harvestersNeeded - source.harvestersPresent,\r\n          assignedCreeps: []\r\n        });\r\n      }\r\n    });\r\n\r\n    // DIRECT TRANSFER to spawns/extensions (early game - no containers yet)\r\n    if (report.energyDeficit > 0) {\r\n      // Find spawns and extensions that need energy\r\n      report.spawns.forEach(spawn => {\r\n        const freeCapacity = spawn.energyCapacity - spawn.energy;\r\n        if (freeCapacity > 0) {\r\n          tasks.push({\r\n            id: this.generateTaskId(),\r\n            type: TaskType.REFILL_SPAWN,\r\n            priority: 90, // Higher than harvest - we need energy NOW\r\n            targetId: spawn.id,\r\n            creepsNeeded: 99, // Accept all haulers - proximity will optimize\r\n            assignedCreeps: [],\r\n            metadata: {\r\n              energyNeeded: freeCapacity\r\n            }\r\n          });\r\n        }\r\n      });\r\n\r\n      // TODO: Add REFILL_EXTENSION tasks when we have extensions\r\n    }\r\n\r\n    // Haul energy from containers to spawns/extensions (mid-game onwards)\r\n    report.containers.forEach(container => {\r\n      if (container.store.energy > 100 && report.energyDeficit > 0) {\r\n        tasks.push({\r\n          id: this.generateTaskId(),\r\n          type: TaskType.HAUL_ENERGY,\r\n          priority: 80,\r\n          targetId: container.id,\r\n          targetPos: { x: container.pos.x, y: container.pos.y, roomName: this.roomName },\r\n          creepsNeeded: 99, // Multiple haulers acceptable - proximity optimizes\r\n          assignedCreeps: [],\r\n          metadata: {\r\n            energyAvailable: container.store.energy\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createTowerRefillTasks(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n\r\n    report.towers.forEach(tower => {\r\n      if (tower.needsRefill) {\r\n        const energyNeeded = tower.energyCapacity - tower.energy;\r\n        tasks.push({\r\n          id: this.generateTaskId(),\r\n          type: TaskType.REFILL_TOWER,\r\n          priority: 75,\r\n          targetId: tower.id,\r\n          creepsNeeded: Math.ceil(energyNeeded / 500),\r\n          assignedCreeps: [],\r\n          metadata: {\r\n            energyRequired: energyNeeded\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createConstructionTasks(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n\r\n    report.constructionSites.forEach(site => {\r\n      // Prioritize spawns and towers\r\n      let priority = 60;\r\n      if (site.structureType === STRUCTURE_SPAWN) priority = 85;\r\n      if (site.structureType === STRUCTURE_TOWER) priority = 80;\r\n      if (site.structureType === STRUCTURE_EXTENSION) priority = 70;\r\n\r\n      tasks.push({\r\n        id: this.generateTaskId(),\r\n        type: TaskType.BUILD,\r\n        priority: priority,\r\n        targetId: site.id,\r\n        targetPos: { x: site.pos.x, y: site.pos.y, roomName: this.roomName },\r\n        creepsNeeded: Math.ceil((site.progressTotal - site.progress) / 5000),\r\n        assignedCreeps: [],\r\n        metadata: {\r\n          structureType: site.structureType,\r\n          remainingWork: site.progressTotal - site.progress\r\n        }\r\n      });\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createRepairTasks(repairTargets: any[]): Task[] {\r\n    const tasks: Task[] = [];\r\n\r\n    repairTargets.forEach(target => {\r\n      tasks.push({\r\n        id: this.generateTaskId(),\r\n        type: TaskType.REPAIR,\r\n        priority: target.priority,\r\n        targetId: target.id,\r\n        targetPos: { x: target.pos.x, y: target.pos.y, roomName: this.roomName },\r\n        creepsNeeded: 1,\r\n        assignedCreeps: [],\r\n        metadata: {\r\n          structureType: target.structureType,\r\n          hitsNeeded: target.hitsMax - target.hits\r\n        }\r\n      });\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createUpgradeTasks(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n\r\n    // ALWAYS create upgrade tasks - upgrading is core gameplay\r\n    // The controller can handle unlimited upgraders, so set a high limit\r\n    const upgraderShortage = report.controller.upgraderRecommendation - \r\n                             report.controller.upgraderCount;\r\n\r\n    const priority = report.controller.ticksToDowngrade < 5000 ? 90 : 55;\r\n    const creepsNeeded = upgraderShortage > 0 ? upgraderShortage : 99; // Accept all idle creeps with energy\r\n    \r\n    tasks.push({\r\n      id: this.generateTaskId(),\r\n      type: TaskType.UPGRADE_CONTROLLER,\r\n      priority: priority,\r\n      targetId: report.controller.id,\r\n      creepsNeeded: creepsNeeded, // Controller can handle many upgraders\r\n      assignedCreeps: []\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createRenewTasks(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n    const room = Game.rooms[this.roomName];\r\n    if (!room) return tasks;\r\n\r\n    // Create renew tasks for each spawn (low priority - only for idle creeps)\r\n    report.spawns.forEach(spawn => {\r\n      tasks.push({\r\n        id: this.generateTaskId(),\r\n        type: TaskType.RENEW_CREEP,\r\n        priority: 10, // Very low - only when nothing else to do\r\n        targetId: spawn.id,\r\n        creepsNeeded: 99, // Accept all idle creeps\r\n        assignedCreeps: [],\r\n        metadata: {\r\n          spawnId: spawn.id\r\n        }\r\n      });\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private generateTaskId(): string {\r\n    return `task_${this.roomName}_${Game.time}_${this.taskIdCounter++}`;\r\n  }\r\n}\r\n","import { Task, CreepRequest } from '../interfaces';\r\n\r\n/**\r\n * Legatus Genetor - The Broodmother\r\n * \r\n * Responsibility: Maintain optimal creep population with intelligent body designs\r\n * Philosophy: Spawn versatile workers, let tasks find them\r\n * \r\n * The Broodmother analyzes room needs and spawns creeps with appropriate\r\n * body configurations. Creeps are assigned tasks based on their capabilities.\r\n */\r\nexport class LegatusGenetor {\r\n  private roomName: string;\r\n\r\n  constructor(roomName: string) {\r\n    this.roomName = roomName;\r\n  }\r\n\r\n  /**\r\n   * Analyze room population and spawn creeps as needed\r\n   */\r\n  public run(tasks: Task[]): void {\r\n    const room = Game.rooms[this.roomName];\r\n    if (!room) return;\r\n\r\n    // Find available spawns\r\n    const spawns = room.find(FIND_MY_SPAWNS, {\r\n      filter: (s) => !s.spawning\r\n    });\r\n\r\n    if (spawns.length === 0) return;\r\n\r\n    // Check if we need more creeps\r\n    const creepCount = Object.keys(Game.creeps).filter(name => \r\n      Game.creeps[name].memory.room === this.roomName\r\n    ).length;\r\n\r\n    // Early game: maintain minimum population\r\n    const minCreeps = 6;\r\n    const maxCreeps = 15;\r\n\r\n    if (creepCount >= maxCreeps) return;\r\n\r\n    // DON'T SPAWN if there are no available tasks (workers would just idle)\r\n    // Check if there are ANY tasks that have open slots\r\n    const availableTasks = tasks.filter(task => {\r\n      const openSlots = task.creepsNeeded - task.assignedCreeps.length;\r\n      return openSlots > 0;\r\n    });\r\n\r\n    if (availableTasks.length === 0 && creepCount >= minCreeps) {\r\n      // No tasks available and we have minimum population - don't spawn\r\n      // Let existing creeps renew instead\r\n      return;\r\n    }\r\n\r\n    // Determine what type of creep to spawn based on room needs\r\n    const energy = room.energyAvailable;\r\n    \r\n    // Only spawn if we have enough energy (don't spawn weak creeps)\r\n    const minEnergyToSpawn = creepCount < minCreeps ? 200 : 300;\r\n    if (energy < minEnergyToSpawn) return;\r\n\r\n    // Decide body type based on current population and needs\r\n    const creepType = this.determineNeededCreepType(room, tasks);\r\n    const body = this.designCreepBody(creepType, energy);\r\n    \r\n    if (body.length === 0) return;\r\n\r\n    const cost = this.calculateBodyCost(body);\r\n    const role = creepType; // 'worker', 'hauler', 'defender', etc.\r\n\r\n    const request: CreepRequest = {\r\n      priority: creepCount < minCreeps ? 100 : 50, // Emergency priority if below min\r\n      body: body,\r\n      memory: {\r\n        role: role,\r\n        room: this.roomName\r\n      },\r\n      initialTask: undefined, // Workers are not spawned for specific tasks\r\n      cost: cost,\r\n      role: role\r\n    };\r\n\r\n    this.spawnCreep(spawns[0], request);\r\n  }\r\n\r\n  /**\r\n   * Determine what type of creep the room needs most\r\n   */\r\n  private determineNeededCreepType(room: Room, _tasks: Task[]): string {\r\n    const creeps = Object.values(Game.creeps).filter(c => c.memory.room === this.roomName);\r\n    \r\n    // Count creeps by capability\r\n    const workCreeps = creeps.filter(c => c.getActiveBodyparts(WORK) > 0).length;\r\n    const carryCreeps = creeps.filter(c => c.getActiveBodyparts(CARRY) > 0).length;\r\n    const attackCreeps = creeps.filter(c => c.getActiveBodyparts(ATTACK) > 0).length;\r\n\r\n    // Check for defense needs\r\n    const hostiles = room.find(FIND_HOSTILE_CREEPS);\r\n    if (hostiles.length > 0 && attackCreeps < 2) {\r\n      return 'defender';\r\n    }\r\n\r\n    // Early game: need workers who can do everything\r\n    if (workCreeps < 4) {\r\n      return 'worker'; // WORK + CARRY + MOVE - can harvest, build, upgrade, transfer\r\n    }\r\n\r\n    // Mid game: specialized haulers for efficiency\r\n    if (carryCreeps < workCreeps * 0.5) {\r\n      return 'hauler'; // Mostly CARRY + MOVE - fast energy transport\r\n    }\r\n\r\n    // Default: balanced worker\r\n    return 'worker';\r\n  }\r\n\r\n  /**\r\n   * Design a creep body based on type and available energy\r\n   */\r\n  private designCreepBody(type: string, energy: number): BodyPartConstant[] {\r\n    switch (type) {\r\n      case 'worker':\r\n        return this.designWorker(energy);\r\n      case 'hauler':\r\n        return this.designHauler(energy);\r\n      case 'defender':\r\n        return this.designDefender(energy);\r\n      default:\r\n        return this.designWorker(energy);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Design a general-purpose worker: WORK + CARRY + MOVE\r\n   * Can harvest, build, upgrade, repair, and transfer\r\n   */\r\n  private designWorker(energy: number): BodyPartConstant[] {\r\n    // Worker: Balanced WORK, CARRY, MOVE (versatile, can do anything)\r\n    const parts: BodyPartConstant[] = [];\r\n    \r\n    while (energy >= 200) {\r\n      parts.push(WORK);   // 100\r\n      parts.push(CARRY);  // 50\r\n      parts.push(MOVE);   // 50 = 200 total\r\n      energy -= 200;\r\n    }\r\n\r\n    return parts.length > 0 ? parts : [WORK, CARRY, MOVE];\r\n  }\r\n\r\n  /**\r\n   * Design a specialized hauler: Mostly CARRY + MOVE\r\n   * Fast energy transport\r\n   */\r\n  private designHauler(energy: number): BodyPartConstant[] {\r\n    // Hauler: Maximize CARRY with MOVE for speed\r\n    const parts: BodyPartConstant[] = [];\r\n    \r\n    // At least 1 WORK for emergency harvesting\r\n    if (energy >= 150) {\r\n      parts.push(WORK);\r\n      parts.push(CARRY);\r\n      parts.push(MOVE);\r\n      energy -= 150;\r\n    }\r\n    \r\n    // Rest is CARRY + MOVE\r\n    while (energy >= 100) {\r\n      parts.push(CARRY);\r\n      parts.push(MOVE);\r\n      energy -= 100;\r\n    }\r\n\r\n    return parts.length > 0 ? parts : [CARRY, MOVE];\r\n  }\r\n\r\n  private designDefender(energy: number): BodyPartConstant[] {\r\n    // Defender: ATTACK, MOVE, some TOUGH\r\n    const parts: BodyPartConstant[] = [];\r\n    \r\n    // Add tough armor first\r\n    if (energy >= 10) {\r\n      parts.push(TOUGH);\r\n      energy -= 10;\r\n    }\r\n\r\n    // Add attack and move\r\n    while (energy >= 130) {\r\n      parts.push(ATTACK);\r\n      parts.push(MOVE);\r\n      energy -= 130;\r\n    }\r\n\r\n    return parts.length > 0 ? parts : [ATTACK, MOVE];\r\n  }\r\n\r\n  private calculateBodyCost(body: BodyPartConstant[]): number {\r\n    const costs: { [key: string]: number } = {\r\n      [MOVE]: 50,\r\n      [WORK]: 100,\r\n      [CARRY]: 50,\r\n      [ATTACK]: 80,\r\n      [RANGED_ATTACK]: 150,\r\n      [HEAL]: 250,\r\n      [TOUGH]: 10,\r\n      [CLAIM]: 600\r\n    };\r\n\r\n    return body.reduce((sum, part) => sum + (costs[part] || 0), 0);\r\n  }\r\n\r\n  private spawnCreep(spawn: StructureSpawn, request: CreepRequest): void {\r\n    const name = `${request.role}_${Game.time}`;\r\n    const result = spawn.spawnCreep(request.body, name, { memory: request.memory });\r\n\r\n    if (result === OK) {\r\n      console.log(`üèõÔ∏è Spawning ${request.role}: ${name} (${request.cost} energy)`);\r\n    } else if (result === ERR_NOT_ENOUGH_ENERGY) {\r\n      // This is fine - we'll try again next tick\r\n    } else {\r\n      console.log(`‚ö†Ô∏è Failed to spawn ${request.role}: ${result}`);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Legatus Fabrum - The Architect\r\n * \r\n * Responsibility: Place construction sites according to room blueprints\r\n * Philosophy: Every room should be a masterpiece of efficiency\r\n * \r\n * The Architect plans and places structures to optimize room layout.\r\n * Currently implements RCL 1-3 infrastructure.\r\n */\r\nexport class LegatusFabrum {\r\n  private roomName: string;\r\n\r\n  constructor(roomName: string) {\r\n    this.roomName = roomName;\r\n  }\r\n\r\n  /**\r\n   * Analyze room and place construction sites based on RCL\r\n   */\r\n  public run(): void {\r\n    const room = Game.rooms[this.roomName];\r\n    if (!room || !room.controller || !room.controller.my) return;\r\n\r\n    const rcl = room.controller.level;\r\n    \r\n    // Place structures based on RCL progression\r\n    if (rcl >= 2) {\r\n      this.placeExtensions(room);\r\n    }\r\n    \r\n    if (rcl >= 3) {\r\n      this.placeTower(room);\r\n      this.placeContainers(room);\r\n    }\r\n    \r\n    // Future: Roads, ramparts, walls, storage, etc.\r\n  }\r\n\r\n  /**\r\n   * Place extensions near spawn\r\n   * RCL 2: 5 extensions, RCL 3: 10 extensions, etc.\r\n   * Strategy: Place ONE at a time, evenly distributed in rings\r\n   */\r\n  private placeExtensions(room: Room): void {\r\n    const rcl = room.controller!.level;\r\n    \r\n    // Extension limits by RCL\r\n    const extensionLimits: { [key: number]: number } = {\r\n      2: 5,\r\n      3: 10,\r\n      4: 20,\r\n      5: 30,\r\n      6: 40,\r\n      7: 50,\r\n      8: 60\r\n    };\r\n    \r\n    const maxExtensions = extensionLimits[rcl] || 0;\r\n    \r\n    // Count existing extensions and construction sites\r\n    const existingExtensions = room.find(FIND_MY_STRUCTURES, {\r\n      filter: (s) => s.structureType === STRUCTURE_EXTENSION\r\n    }).length;\r\n    \r\n    const extensionSites = room.find(FIND_MY_CONSTRUCTION_SITES, {\r\n      filter: (s) => s.structureType === STRUCTURE_EXTENSION\r\n    }).length;\r\n    \r\n    const totalExtensions = existingExtensions + extensionSites;\r\n    \r\n    if (totalExtensions >= maxExtensions) return; // Already have enough\r\n    \r\n    // ONLY place ONE construction site at a time\r\n    if (extensionSites > 0) return; // Wait for current site to be built\r\n    \r\n    // Find spawn to build near\r\n    const spawn = room.find(FIND_MY_SPAWNS)[0];\r\n    if (!spawn) return;\r\n    \r\n    // Place extensions evenly distributed in rings\r\n    // Use a deterministic pattern to ensure even spacing\r\n    const extensionsNeeded = 1; // ONE AT A TIME\r\n    let placed = 0;\r\n    \r\n    // Search in expanding rings around spawn\r\n    for (let range = 2; range <= 5 && placed < extensionsNeeded; range++) {\r\n      const positions = this.getEvenlyDistributedPositions(spawn.pos, range);\r\n      \r\n      for (const pos of positions) {\r\n        if (placed >= extensionsNeeded) break;\r\n        \r\n        // Check if position is valid for extension\r\n        if (this.canPlaceStructure(room, pos)) {\r\n          const result = room.createConstructionSite(pos.x, pos.y, STRUCTURE_EXTENSION);\r\n          if (result === OK) {\r\n            placed++;\r\n            console.log(`üèóÔ∏è Architect: Placed EXTENSION at ${pos.x},${pos.y} (${totalExtensions + 1}/${maxExtensions})`);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Place tower for defense (RCL 3+)\r\n   */\r\n  private placeTower(room: Room): void {\r\n    // Check if we already have a tower or construction site\r\n    const existingTowers = room.find(FIND_MY_STRUCTURES, {\r\n      filter: (s) => s.structureType === STRUCTURE_TOWER\r\n    }).length;\r\n    \r\n    const towerSites = room.find(FIND_MY_CONSTRUCTION_SITES, {\r\n      filter: (s) => s.structureType === STRUCTURE_TOWER\r\n    }).length;\r\n    \r\n    if (existingTowers + towerSites > 0) return;\r\n    \r\n    // Place tower near controller for defense\r\n    const controller = room.controller!;\r\n    const positions = this.getPositionsInRange(controller.pos, 3);\r\n    \r\n    for (const pos of positions) {\r\n      if (this.canPlaceStructure(room, pos)) {\r\n        const result = room.createConstructionSite(pos.x, pos.y, STRUCTURE_TOWER);\r\n        if (result === OK) {\r\n          console.log(`üèóÔ∏è Architect: Placed TOWER at ${pos.x},${pos.y}`);\r\n          return;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Place containers near sources (RCL 3+)\r\n   */\r\n  private placeContainers(room: Room): void {\r\n    const sources = room.find(FIND_SOURCES);\r\n    \r\n    sources.forEach(source => {\r\n      // Check if source already has container or site\r\n      const existingContainer = room.find(FIND_STRUCTURES, {\r\n        filter: (s) => s.structureType === STRUCTURE_CONTAINER &&\r\n                      s.pos.inRangeTo(source.pos, 1)\r\n      }).length;\r\n      \r\n      const containerSite = room.find(FIND_CONSTRUCTION_SITES, {\r\n        filter: (s) => s.structureType === STRUCTURE_CONTAINER &&\r\n                      s.pos.inRangeTo(source.pos, 1)\r\n      }).length;\r\n      \r\n      if (existingContainer + containerSite > 0) return;\r\n      \r\n      // Place container adjacent to source\r\n      const positions = this.getPositionsInRange(source.pos, 1);\r\n      \r\n      for (const pos of positions) {\r\n        if (this.canPlaceStructure(room, pos)) {\r\n          const result = room.createConstructionSite(pos.x, pos.y, STRUCTURE_CONTAINER);\r\n          if (result === OK) {\r\n            console.log(`üèóÔ∏è Architect: Placed CONTAINER near source at ${pos.x},${pos.y}`);\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get all positions in a specific range (ring) around a position\r\n   */\r\n  private getPositionsInRange(pos: RoomPosition, range: number): RoomPosition[] {\r\n    const positions: RoomPosition[] = [];\r\n    \r\n    for (let x = pos.x - range; x <= pos.x + range; x++) {\r\n      for (let y = pos.y - range; y <= pos.y + range; y++) {\r\n        // Only positions at exactly this range (ring, not filled circle)\r\n        const dx = Math.abs(x - pos.x);\r\n        const dy = Math.abs(y - pos.y);\r\n        if (Math.max(dx, dy) !== range) continue;\r\n        \r\n        if (x >= 0 && x <= 49 && y >= 0 && y <= 49) {\r\n          positions.push(new RoomPosition(x, y, pos.roomName));\r\n        }\r\n      }\r\n    }\r\n    \r\n    return positions;\r\n  }\r\n\r\n  /**\r\n   * Get evenly distributed positions around a point\r\n   * Prioritizes cardinal directions and diagonals for balanced spacing\r\n   */\r\n  private getEvenlyDistributedPositions(pos: RoomPosition, range: number): RoomPosition[] {\r\n    const positions: RoomPosition[] = [];\r\n    \r\n    // For each ring, prioritize 8 main directions (N, NE, E, SE, S, SW, W, NW)\r\n    // This creates balanced, cross-pattern distribution\r\n    const directions = [\r\n      { dx: 0, dy: -1 },  // North\r\n      { dx: 1, dy: -1 },  // Northeast\r\n      { dx: 1, dy: 0 },   // East\r\n      { dx: 1, dy: 1 },   // Southeast\r\n      { dx: 0, dy: 1 },   // South\r\n      { dx: -1, dy: 1 },  // Southwest\r\n      { dx: -1, dy: 0 },  // West\r\n      { dx: -1, dy: -1 }  // Northwest\r\n    ];\r\n    \r\n    // Add primary 8 directions at this range\r\n    for (const dir of directions) {\r\n      const x = pos.x + (dir.dx * range);\r\n      const y = pos.y + (dir.dy * range);\r\n      \r\n      if (x >= 0 && x <= 49 && y >= 0 && y <= 49) {\r\n        positions.push(new RoomPosition(x, y, pos.roomName));\r\n      }\r\n    }\r\n    \r\n    // Add remaining positions in the ring (fills gaps between cardinal/diagonal)\r\n    for (let x = pos.x - range; x <= pos.x + range; x++) {\r\n      for (let y = pos.y - range; y <= pos.y + range; y++) {\r\n        const dx = Math.abs(x - pos.x);\r\n        const dy = Math.abs(y - pos.y);\r\n        if (Math.max(dx, dy) !== range) continue;\r\n        \r\n        // Skip if already added (cardinal/diagonal)\r\n        const alreadyAdded = positions.some(p => p.x === x && p.y === y);\r\n        if (alreadyAdded) continue;\r\n        \r\n        if (x >= 0 && x <= 49 && y >= 0 && y <= 49) {\r\n          positions.push(new RoomPosition(x, y, pos.roomName));\r\n        }\r\n      }\r\n    }\r\n    \r\n    return positions;\r\n  }\r\n\r\n  /**\r\n   * Check if a structure can be placed at this position\r\n   */\r\n  private canPlaceStructure(room: Room, pos: RoomPosition): boolean {\r\n    // Check terrain\r\n    const terrain = room.getTerrain();\r\n    if (terrain.get(pos.x, pos.y) === TERRAIN_MASK_WALL) return false;\r\n    \r\n    // Check for existing structures\r\n    const structures = pos.lookFor(LOOK_STRUCTURES);\r\n    if (structures.length > 0) return false;\r\n    \r\n    // Check for construction sites\r\n    const sites = pos.lookFor(LOOK_CONSTRUCTION_SITES);\r\n    if (sites.length > 0) return false;\r\n    \r\n    // Don't build on source or controller\r\n    const sources = pos.lookFor(LOOK_SOURCES);\r\n    if (sources.length > 0) return false;\r\n    \r\n    // Check controller\r\n    if (room.controller && pos.isEqualTo(room.controller.pos)) return false;\r\n    \r\n    return true;\r\n  }\r\n}\r\n\r\n","/**\r\n * Legatus Viae - The Trailblazer\r\n * \r\n * Responsibility: Analyze traffic and build roads\r\n * Philosophy: The shortest path between two points is a Roman road\r\n * \r\n * The Trailblazer monitors creep movement patterns and builds roads\r\n * in high-traffic areas to improve efficiency.\r\n */\r\nexport class LegatusViae {\r\n  private roomName: string;\r\n\r\n  constructor(roomName: string) {\r\n    this.roomName = roomName;\r\n  }\r\n\r\n  /**\r\n   * Analyze traffic patterns and place road construction sites\r\n   * TODO: Implement traffic analysis and road planning\r\n   */\r\n  public run(): void {\r\n    // STUB: Traffic analysis logic will be implemented later\r\n    // This will include:\r\n    // - Tracking creep movement patterns\r\n    // - Identifying high-traffic positions\r\n    // - Placing road construction sites\r\n    // - Optimizing paths between key structures\r\n    \r\n    // Suppress unused variable warning - will be used in future implementation\r\n    void this.roomName;\r\n  }\r\n}\r\n","/**\r\n * Task execution status enumeration\r\n * Represents the outcome of a task execution attempt\r\n */\r\nexport enum TaskStatus {\r\n  /** Task is currently being executed */\r\n  IN_PROGRESS = 'IN_PROGRESS',\r\n  /** Task has been completed successfully */\r\n  COMPLETED = 'COMPLETED',\r\n  /** Task execution failed */\r\n  FAILED = 'FAILED',\r\n  /** Task cannot be executed (e.g., target unreachable) */\r\n  BLOCKED = 'BLOCKED'\r\n}\r\n\r\n/**\r\n * Result of a single task execution\r\n * Returned by TaskExecutor.execute() to indicate what happened\r\n */\r\nexport interface TaskResult {\r\n  /** Current status of the task */\r\n  status: TaskStatus;\r\n  /** Optional message describing the status (e.g., error details) */\r\n  message?: string;\r\n  /** Energy consumed during this execution */\r\n  energyUsed?: number;\r\n  /** Amount of work completed (e.g., energy transferred, building damage) */\r\n  workDone?: number;\r\n}\r\n","import { Task } from '../interfaces';\r\nimport { TaskResult } from './TaskResult';\r\n\r\n/**\r\n * Base class for task execution\r\n * \r\n * Responsibility: Execute specific task types with creeps\r\n * Strategy: Each TaskType has a corresponding executor subclass\r\n * \r\n * This abstract class defines the interface that all task executors must implement,\r\n * providing utility methods for common operations like movement and positioning checks.\r\n */\r\nexport abstract class TaskExecutor {\r\n  /**\r\n   * Execute the given task with the specified creep\r\n   * \r\n   * Each subclass must implement specific execution logic for its TaskType\r\n   * \r\n   * @param creep - The creep performing the task\r\n   * @param task - The task to execute\r\n   * @returns TaskResult indicating the outcome and progress\r\n   */\r\n  abstract execute(creep: Creep, task: Task): TaskResult;\r\n\r\n  /**\r\n   * Check if a creep is at or adjacent to the target position\r\n   * \r\n   * @param creep - The creep to check\r\n   * @param target - The target position or object\r\n   * @returns true if creep is near target, false otherwise\r\n   */\r\n  protected isAtTarget(creep: Creep, target: RoomPosition | RoomObject): boolean {\r\n    return creep.pos.isNearTo(target);\r\n  }\r\n\r\n  /**\r\n   * Move a creep to the target position with standard pathfinding\r\n   * \r\n   * Uses visualized paths and path reuse for efficiency\r\n   * \r\n   * @param creep - The creep to move\r\n   * @param target - The target position or object\r\n   * @returns Screeps return code (OK, ERR_NO_PATH, etc.)\r\n   */\r\n  protected moveToTarget(creep: Creep, target: RoomPosition | RoomObject): ScreepsReturnCode {\r\n    return creep.moveTo(target, {\r\n      visualizePathStyle: { stroke: '#ffffff' },\r\n      reusePath: 10\r\n    });\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * HarvestExecutor - Execute HARVEST_ENERGY tasks\r\n * \r\n * Creeps move to energy sources and harvest energy\r\n * Returns COMPLETED when creep is full or source is empty\r\n */\r\nexport class HarvestExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Validate task has a target source\r\n    if (!task.targetId) {\r\n      return { status: TaskStatus.FAILED, message: 'No harvest target specified' };\r\n    }\r\n\r\n    // Get the source\r\n    const source = Game.getObjectById(task.targetId as Id<Source>);\r\n    if (!source) {\r\n      return { status: TaskStatus.FAILED, message: 'Source not found' };\r\n    }\r\n\r\n    // Check if creep is full\r\n    if (creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'Creep full',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if source is depleted\r\n    if (source.energy === 0) {\r\n      return { \r\n        status: TaskStatus.BLOCKED, \r\n        message: 'Source empty',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if already adjacent to source\r\n    if (!this.isAtTarget(creep, source)) {\r\n      // Move towards source\r\n      const moveResult = this.moveToTarget(creep, source);\r\n      \r\n      // Movement errors are usually not fatal - creep just needs to keep trying\r\n      // Only fail on critical errors like ERR_NO_BODYPART\r\n      if (moveResult !== OK && moveResult !== ERR_TIRED && moveResult !== ERR_BUSY) {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n      \r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Moving to source',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Adjacent to source - perform harvest\r\n    const harvestResult = creep.harvest(source);\r\n    if (harvestResult === OK) {\r\n      const workParts = creep.getActiveBodyparts(WORK);\r\n      const energyHarvested = Math.min(source.energy, workParts * HARVEST_POWER);\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Harvesting',\r\n        workDone: energyHarvested\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Harvest failed: ${harvestResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * PickupExecutor - Execute PICKUP_ENERGY tasks\r\n * \r\n * Creeps move to dropped energy and pick it up\r\n * Returns COMPLETED when creep is full or energy is gone\r\n */\r\nexport class PickupExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Validate task has a target\r\n    if (!task.targetId) {\r\n      return { status: TaskStatus.FAILED, message: 'No pickup target specified' };\r\n    }\r\n\r\n    // Get the dropped resource\r\n    const resource = Game.getObjectById(task.targetId as Id<Resource>);\r\n    if (!resource) {\r\n      return { status: TaskStatus.FAILED, message: 'Dropped resource not found' };\r\n    }\r\n\r\n    // Check if creep is full\r\n    if (creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'Creep full',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if resource still exists and has energy\r\n    if (resource.amount === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'Resource depleted',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if in range to pickup (must be adjacent)\r\n    if (!this.isAtTarget(creep, resource)) {\r\n      // Move towards resource\r\n      const moveResult = this.moveToTarget(creep, resource);\r\n      \r\n      // Movement errors are usually not fatal\r\n      if (moveResult !== OK && moveResult !== ERR_TIRED && moveResult !== ERR_BUSY) {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n      \r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Moving to resource',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Adjacent to resource - perform pickup\r\n    const pickupResult = creep.pickup(resource);\r\n    if (pickupResult === OK) {\r\n      const amountPickedUp = Math.min(\r\n        resource.amount,\r\n        creep.store.getFreeCapacity(RESOURCE_ENERGY)\r\n      );\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Picking up energy',\r\n        workDone: amountPickedUp\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Pickup failed: ${pickupResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * TransferExecutor - Execute energy transfer tasks\r\n * \r\n * Handles: REFILL_SPAWN, REFILL_EXTENSION, REFILL_TOWER tasks\r\n * Creeps move to target structure and transfer energy\r\n * Returns COMPLETED when creep is empty or structure is full\r\n */\r\nexport class TransferExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Validate task has a target\r\n    if (!task.targetId) {\r\n      return { status: TaskStatus.FAILED, message: 'No transfer target specified' };\r\n    }\r\n\r\n    // Get the target structure\r\n    const target = Game.getObjectById(task.targetId as Id<Structure>);\r\n    if (!target) {\r\n      return { status: TaskStatus.FAILED, message: 'Target structure not found' };\r\n    }\r\n\r\n    // Validate target can store energy\r\n    const storableTarget = target as AnyStoreStructure;\r\n    if (!storableTarget.store) {\r\n      return { status: TaskStatus.FAILED, message: 'Target cannot store energy' };\r\n    }\r\n\r\n    // Check if creep is empty\r\n    if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'Creep empty',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if target is full\r\n    if (storableTarget.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'Target full',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if adjacent to target\r\n    if (!this.isAtTarget(creep, target)) {\r\n      // Move towards target\r\n      const moveResult = this.moveToTarget(creep, target);\r\n      \r\n      // Movement errors are usually not fatal - creep just needs to keep trying\r\n      if (moveResult !== OK && moveResult !== ERR_TIRED && moveResult !== ERR_BUSY) {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n      \r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Moving to target',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Adjacent to target - perform transfer\r\n    const transferResult = creep.transfer(storableTarget, RESOURCE_ENERGY);\r\n    if (transferResult === OK) {\r\n      const energyTransferred = Math.min(\r\n        creep.store.getUsedCapacity(RESOURCE_ENERGY),\r\n        storableTarget.store.getFreeCapacity(RESOURCE_ENERGY)\r\n      );\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Transferring',\r\n        workDone: energyTransferred\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Transfer failed: ${transferResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * UpgradeExecutor - Execute UPGRADE_CONTROLLER tasks\r\n * \r\n * Creeps move to the room controller and upgrade it\r\n * Returns COMPLETED when creep is empty of energy\r\n */\r\nexport class UpgradeExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, _task: Task): TaskResult {\r\n    // Get the controller\r\n    const controller = creep.room.controller;\r\n    if (!controller) {\r\n      return { status: TaskStatus.FAILED, message: 'No controller in room' };\r\n    }\r\n\r\n    const energyAmount = creep.store.getUsedCapacity(RESOURCE_ENERGY);\r\n    const distance = creep.pos.getRangeTo(controller);\r\n    \r\n    // Debug logging\r\n    console.log(`üîß ${creep.name}: Energy=${energyAmount}, Distance=${distance}, Pos=${creep.pos}`);\r\n\r\n    // Check if creep is out of energy\r\n    if (energyAmount === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'No energy',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if in range of controller (3 squares)\r\n    if (!creep.pos.inRangeTo(controller, 3)) {\r\n      // Move towards controller\r\n      console.log(`üö∂ ${creep.name}: Moving to controller at ${controller.pos}`);\r\n      const moveResult = this.moveToTarget(creep, controller);\r\n      console.log(`üìç ${creep.name}: moveTo result = ${moveResult}`);\r\n      \r\n      // Movement errors are usually not fatal - creep just needs to keep trying\r\n      if (moveResult !== OK && moveResult !== ERR_TIRED && moveResult !== ERR_BUSY) {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n      \r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: `Moving to controller`,\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // In range - perform upgrade\r\n    const upgradeResult = creep.upgradeController(controller);\r\n    if (upgradeResult === OK) {\r\n      const workParts = creep.getActiveBodyparts(WORK);\r\n      const workDone = workParts * UPGRADE_CONTROLLER_POWER;\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Upgrading',\r\n        workDone: workDone\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Upgrade failed: ${upgradeResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * BuildExecutor - Execute BUILD tasks\r\n * \r\n * Creeps move to construction sites and build structures\r\n * Returns COMPLETED when construction site is finished or creep is empty\r\n */\r\nexport class BuildExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Validate task has a target construction site\r\n    if (!task.targetId) {\r\n      return { status: TaskStatus.FAILED, message: 'No construction site specified' };\r\n    }\r\n\r\n    // Get the construction site\r\n    const site = Game.getObjectById(task.targetId as Id<ConstructionSite>);\r\n    if (!site) {\r\n      return { status: TaskStatus.FAILED, message: 'Construction site not found' };\r\n    }\r\n\r\n    // If creep has no energy, go harvest first\r\n    if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\r\n      // Find nearest source with energy\r\n      const sources = creep.room.find(FIND_SOURCES_ACTIVE);\r\n      if (sources.length === 0) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Waiting for energy sources to regenerate',\r\n          workDone: 0\r\n        };\r\n      }\r\n\r\n      const nearestSource = creep.pos.findClosestByPath(sources);\r\n      if (!nearestSource) {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: 'Cannot path to energy source',\r\n          workDone: 0\r\n        };\r\n      }\r\n\r\n      // Move to source and harvest\r\n      if (!creep.pos.isNearTo(nearestSource)) {\r\n        creep.moveTo(nearestSource, { visualizePathStyle: { stroke: '#ffaa00' } });\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Moving to harvest energy',\r\n          workDone: 0\r\n        };\r\n      }\r\n\r\n      // Harvest\r\n      const harvestResult = creep.harvest(nearestSource);\r\n      if (harvestResult === OK) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Harvesting energy for build',\r\n          workDone: 0\r\n        };\r\n      } else {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Harvest failed: ${harvestResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n    }\r\n\r\n    // Check if adjacent to construction site\r\n    if (!this.isAtTarget(creep, site)) {\r\n      // Move towards site\r\n      const moveResult = this.moveToTarget(creep, site);\r\n      if (moveResult === OK) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Moving to construction site',\r\n          workDone: 0\r\n        };\r\n      } else {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n    }\r\n\r\n    // Adjacent to site - perform build\r\n    const buildResult = creep.build(site);\r\n    if (buildResult === OK) {\r\n      const workParts = creep.getActiveBodyparts(WORK);\r\n      const workDone = workParts * BUILD_POWER;\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Building',\r\n        workDone: workDone\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Build failed: ${buildResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * RepairExecutor - Execute REPAIR tasks\r\n * \r\n * Creeps move to damaged structures and repair them\r\n * Returns COMPLETED when structure is fully repaired or creep is empty\r\n */\r\nexport class RepairExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Validate task has a target structure\r\n    if (!task.targetId) {\r\n      return { status: TaskStatus.FAILED, message: 'No repair target specified' };\r\n    }\r\n\r\n    // Get the structure to repair\r\n    const structure = Game.getObjectById(task.targetId as Id<Structure>);\r\n    if (!structure) {\r\n      return { status: TaskStatus.FAILED, message: 'Target structure not found' };\r\n    }\r\n\r\n    // Check if structure is already fully repaired\r\n    if (structure.hits >= structure.hitsMax) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'Structure repaired',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if creep is out of energy\r\n    if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'No energy',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if adjacent to structure\r\n    if (!this.isAtTarget(creep, structure)) {\r\n      // Move towards structure\r\n      const moveResult = this.moveToTarget(creep, structure);\r\n      if (moveResult === OK) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Moving to repair target',\r\n          workDone: 0\r\n        };\r\n      } else {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n    }\r\n\r\n    // Adjacent to structure - perform repair\r\n    const repairResult = creep.repair(structure);\r\n    if (repairResult === OK) {\r\n      const workParts = creep.getActiveBodyparts(WORK);\r\n      const workDone = workParts * REPAIR_POWER;\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Repairing',\r\n        workDone: workDone\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Repair failed: ${repairResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * WithdrawExecutor - Execute WITHDRAW_ENERGY tasks\r\n * \r\n * Creeps move to containers/storage and withdraw energy\r\n * Returns COMPLETED when creep is full or structure is empty\r\n */\r\nexport class WithdrawExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Validate task has a target\r\n    if (!task.targetId) {\r\n      return { status: TaskStatus.FAILED, message: 'No withdraw target specified' };\r\n    }\r\n\r\n    // Get the target structure\r\n    const target = Game.getObjectById(task.targetId as Id<Structure>);\r\n    if (!target) {\r\n      return { status: TaskStatus.FAILED, message: 'Target structure not found' };\r\n    }\r\n\r\n    // Validate target has a store\r\n    const storableTarget = target as AnyStoreStructure;\r\n    if (!storableTarget.store) {\r\n      return { status: TaskStatus.FAILED, message: 'Target has no store' };\r\n    }\r\n\r\n    // Check if creep is full\r\n    if (creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'Creep full',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if target is empty\r\n    if (storableTarget.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.BLOCKED, \r\n        message: 'Target empty',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if adjacent to target\r\n    if (!this.isAtTarget(creep, target)) {\r\n      // Move towards target\r\n      const moveResult = this.moveToTarget(creep, target);\r\n      if (moveResult === OK) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Moving to target',\r\n          workDone: 0\r\n        };\r\n      } else {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n    }\r\n\r\n    // Adjacent to target - perform withdraw\r\n    const withdrawResult = creep.withdraw(storableTarget, RESOURCE_ENERGY);\r\n    if (withdrawResult === OK) {\r\n      const energyWithdrawn = Math.min(\r\n        creep.store.getFreeCapacity(RESOURCE_ENERGY),\r\n        storableTarget.store.getUsedCapacity(RESOURCE_ENERGY)\r\n      );\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Withdrawing',\r\n        workDone: energyWithdrawn\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Withdraw failed: ${withdrawResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * DefendExecutor - Execute DEFEND_ROOM tasks\r\n * \r\n * Creeps move to hostile creeps and attack them\r\n * Uses melee attack if available, otherwise ranged attack\r\n * Returns COMPLETED when no hostiles remain\r\n */\r\nexport class DefendExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Get target hostile\r\n    let hostile: Creep | null = null;\r\n\r\n    if (task.targetId) {\r\n      // If specific target is assigned, try to use it\r\n      hostile = Game.getObjectById(task.targetId as Id<Creep>);\r\n    }\r\n\r\n    // If no target or target is gone, find nearest hostile\r\n    if (!hostile) {\r\n      const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);\r\n      if (hostiles.length === 0) {\r\n        return { \r\n          status: TaskStatus.COMPLETED, \r\n          message: 'No hostiles',\r\n          workDone: 0\r\n        };\r\n      }\r\n      // Target nearest hostile\r\n      hostile = creep.pos.findClosestByPath(hostiles);\r\n      if (!hostile) {\r\n        hostile = creep.pos.findClosestByRange(hostiles);\r\n      }\r\n    }\r\n\r\n    // Validate we have a hostile to attack\r\n    if (!hostile) {\r\n      return { \r\n        status: TaskStatus.BLOCKED, \r\n        message: 'Hostile unreachable',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check which attack types we have\r\n    const hasAttack = creep.getActiveBodyparts(ATTACK) > 0;\r\n    const hasRangedAttack = creep.getActiveBodyparts(RANGED_ATTACK) > 0;\r\n\r\n    // If adjacent to hostile, use melee attack\r\n    if (creep.pos.isNearTo(hostile)) {\r\n      if (hasAttack) {\r\n        const attackResult = creep.attack(hostile);\r\n        if (attackResult === OK) {\r\n          return { \r\n            status: TaskStatus.IN_PROGRESS, \r\n            message: 'Attacking',\r\n            workDone: creep.getActiveBodyparts(ATTACK) * ATTACK_POWER\r\n          };\r\n        }\r\n      }\r\n      // Fall through to ranged attack\r\n    }\r\n\r\n    // Use ranged attack or move closer\r\n    if (hasRangedAttack && creep.pos.inRangeTo(hostile, 3)) {\r\n      const rangedResult = creep.rangedAttack(hostile);\r\n      if (rangedResult === OK) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Ranged attacking',\r\n          workDone: creep.getActiveBodyparts(RANGED_ATTACK) * RANGED_ATTACK_POWER\r\n        };\r\n      }\r\n    }\r\n\r\n    // Move towards hostile\r\n    const moveResult = this.moveToTarget(creep, hostile);\r\n    if (moveResult === OK) {\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Moving to hostile',\r\n        workDone: 0\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Failed to move: ${moveResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * IdleExecutor - Execute IDLE tasks\r\n * \r\n * Default fallback executor for creeps without assigned tasks\r\n * Moves to a safe parking position near the controller\r\n * Returns IN_PROGRESS indefinitely until reassigned\r\n */\r\nexport class IdleExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, _task: Task): TaskResult {\r\n    // Get the controller as a safe parking position\r\n    const controller = creep.room.controller;\r\n    if (!controller) {\r\n      // No controller - just stay put\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Idling (no controller)',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // If already in parking area (adjacent to controller), stay put\r\n    if (creep.pos.inRangeTo(controller, 3)) {\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Parked',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Move to parking position\r\n    const moveResult = this.moveToTarget(creep, controller);\r\n    if (moveResult === OK) {\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Moving to parking',\r\n        workDone: 0\r\n      };\r\n    } else if (moveResult === ERR_NO_PATH) {\r\n      // Can't reach parking - stay put\r\n      return { \r\n        status: TaskStatus.BLOCKED, \r\n        message: 'Parking unreachable',\r\n        workDone: 0\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Idling',\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * RenewExecutor - Handles RENEW_CREEP tasks\r\n * \r\n * Responsibility: Keep creeps alive by renewing them at spawns\r\n * Philosophy: Use excess spawn energy to extend creep lifespan\r\n * \r\n * When there are no urgent tasks, idle creeps should renew themselves\r\n * to avoid dying and wasting the energy that was used to spawn them.\r\n */\r\nexport class RenewExecutor extends TaskExecutor {\r\n  /**\r\n   * Execute renewal for a creep\r\n   */\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Get the spawn from the task\r\n    const spawn = Game.getObjectById(task.targetId as Id<StructureSpawn>);\r\n    \r\n    if (!spawn) {\r\n      return {\r\n        status: TaskStatus.FAILED,\r\n        message: 'Spawn not found'\r\n      };\r\n    }\r\n\r\n    // Don't renew if creep is still very young (TTL > 1300 = ~65% life)\r\n    if (creep.ticksToLive && creep.ticksToLive > 1300) {\r\n      return {\r\n        status: TaskStatus.COMPLETED,\r\n        message: 'Creep still young, no renewal needed'\r\n      };\r\n    }\r\n\r\n    // Check if spawn is spawning (can't renew while spawning)\r\n    if (spawn.spawning) {\r\n      return {\r\n        status: TaskStatus.IN_PROGRESS,\r\n        message: 'Waiting for spawn to finish spawning'\r\n      };\r\n    }\r\n\r\n    // Check if spawn has enough energy to renew (costs energy)\r\n    const renewCost = Math.ceil(this.calculateRenewCost(creep) * 0.1); // Estimate 10% of body cost\r\n    if (spawn.store.getUsedCapacity(RESOURCE_ENERGY) < renewCost) {\r\n      return {\r\n        status: TaskStatus.FAILED,\r\n        message: 'Spawn lacks energy for renewal'\r\n      };\r\n    }\r\n\r\n    // Move to spawn if not adjacent\r\n    if (!creep.pos.isNearTo(spawn)) {\r\n      const moveResult = creep.moveTo(spawn, {\r\n        visualizePathStyle: { stroke: '#00ff00' }\r\n      });\r\n\r\n      if (moveResult === OK) {\r\n        return {\r\n          status: TaskStatus.IN_PROGRESS,\r\n          message: 'Moving to spawn'\r\n        };\r\n      } else {\r\n        return {\r\n          status: TaskStatus.FAILED,\r\n          message: `Movement failed: ${moveResult}`\r\n        };\r\n      }\r\n    }\r\n\r\n    // Renew the creep\r\n    const renewResult = spawn.renewCreep(creep);\r\n\r\n    switch (renewResult) {\r\n      case OK:\r\n        return {\r\n          status: TaskStatus.IN_PROGRESS,\r\n          message: `Renewing (TTL: ${creep.ticksToLive})`\r\n        };\r\n\r\n      case ERR_NOT_ENOUGH_ENERGY:\r\n        return {\r\n          status: TaskStatus.FAILED,\r\n          message: 'Spawn out of energy'\r\n        };\r\n\r\n      case ERR_FULL:\r\n        // Creep is fully renewed\r\n        return {\r\n          status: TaskStatus.COMPLETED,\r\n          message: 'Fully renewed'\r\n        };\r\n\r\n      case ERR_BUSY:\r\n        return {\r\n          status: TaskStatus.IN_PROGRESS,\r\n          message: 'Spawn busy, waiting'\r\n        };\r\n\r\n      default:\r\n        return {\r\n          status: TaskStatus.FAILED,\r\n          message: `Renewal failed: ${renewResult}`\r\n        };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate approximate renewal cost based on body parts\r\n   */\r\n  private calculateRenewCost(creep: Creep): number {\r\n    const costs: { [key: string]: number } = {\r\n      [MOVE]: 50,\r\n      [WORK]: 100,\r\n      [CARRY]: 50,\r\n      [ATTACK]: 80,\r\n      [RANGED_ATTACK]: 150,\r\n      [HEAL]: 250,\r\n      [TOUGH]: 10,\r\n      [CLAIM]: 600\r\n    };\r\n\r\n    return creep.body.reduce((sum, part) => sum + (costs[part.type] || 0), 0);\r\n  }\r\n}\r\n","import { TaskType } from '../interfaces';\r\nimport { TaskExecutor } from './TaskExecutor';\r\nimport { HarvestExecutor } from './executors/HarvestExecutor';\r\nimport { PickupExecutor } from './executors/PickupExecutor';\r\nimport { TransferExecutor } from './executors/TransferExecutor';\r\nimport { UpgradeExecutor } from './executors/UpgradeExecutor';\r\nimport { BuildExecutor } from './executors/BuildExecutor';\r\nimport { RepairExecutor } from './executors/RepairExecutor';\r\nimport { WithdrawExecutor } from './executors/WithdrawExecutor';\r\nimport { DefendExecutor } from './executors/DefendExecutor';\r\nimport { IdleExecutor } from './executors/IdleExecutor';\r\nimport { RenewExecutor } from './executors/RenewExecutor';\r\n\r\n/**\r\n * Factory for task executors\r\n * \r\n * Responsibility: Provide the correct TaskExecutor for any given TaskType\r\n * Strategy: Registry pattern - executors register themselves by task type\r\n * \r\n * This factory maintains a registry of TaskExecutor instances, one per TaskType.\r\n * Specific executors are registered as they are implemented (Phase IV-B, Phase IV-C, etc.)\r\n */\r\nexport class ExecutorFactory {\r\n  /** Registry mapping task types to their executors */\r\n  private static executors: Map<TaskType, TaskExecutor> = new Map();\r\n\r\n  /**\r\n   * Get the executor responsible for a specific task type\r\n   * \r\n   * Initializes executor registry on first use\r\n   * \r\n   * @param taskType - The type of task to get an executor for\r\n   * @returns TaskExecutor instance or null if not yet implemented\r\n   */\r\n  public static getExecutor(taskType: TaskType): TaskExecutor | null {\r\n    // Initialize executors on first use\r\n    if (this.executors.size === 0) {\r\n      this.initializeExecutors();\r\n    }\r\n\r\n    return this.executors.get(taskType) || null;\r\n  }\r\n\r\n  /**\r\n   * Register an executor for a task type\r\n   * \r\n   * Called during executor initialization phases to populate the registry\r\n   * Multiple registrations for the same TaskType will replace the previous executor\r\n   * \r\n   * @param taskType - The task type this executor handles\r\n   * @param executor - The executor instance\r\n   */\r\n  public static registerExecutor(taskType: TaskType, executor: TaskExecutor): void {\r\n    this.executors.set(taskType, executor);\r\n  }\r\n\r\n  /**\r\n   * Initialize the executor registry\r\n   * \r\n   * This is called on first getExecutor() call\r\n   * Specific executors will be registered as they are created in subsequent phases:\r\n   * - Phase IV-B: Agent Secundus creates Harvest, Transfer, Upgrade executors\r\n   * - Phase IV-C: Additional executor implementations\r\n   */\r\n  private static initializeExecutors(): void {\r\n    // Create executor instances\r\n    const harvestExecutor = new HarvestExecutor();\r\n    const pickupExecutor = new PickupExecutor();\r\n    const transferExecutor = new TransferExecutor();\r\n    const upgradeExecutor = new UpgradeExecutor();\r\n    const buildExecutor = new BuildExecutor();\r\n    const repairExecutor = new RepairExecutor();\r\n    const withdrawExecutor = new WithdrawExecutor();\r\n    const defendExecutor = new DefendExecutor();\r\n    const idleExecutor = new IdleExecutor();\r\n    const renewExecutor = new RenewExecutor();\r\n\r\n    // Register energy management executors\r\n    this.registerExecutor(TaskType.HARVEST_ENERGY, harvestExecutor);\r\n    this.registerExecutor(TaskType.PICKUP_ENERGY, pickupExecutor);\r\n    this.registerExecutor(TaskType.WITHDRAW_ENERGY, withdrawExecutor);\r\n    this.registerExecutor(TaskType.HAUL_ENERGY, transferExecutor); // Same logic as transfer\r\n\r\n    // Register construction & repair executors\r\n    this.registerExecutor(TaskType.BUILD, buildExecutor);\r\n    this.registerExecutor(TaskType.REPAIR, repairExecutor);\r\n\r\n    // Register controller operations\r\n    this.registerExecutor(TaskType.UPGRADE_CONTROLLER, upgradeExecutor);\r\n\r\n    // Register logistics executors (all use transfer logic)\r\n    this.registerExecutor(TaskType.REFILL_SPAWN, transferExecutor);\r\n    this.registerExecutor(TaskType.REFILL_EXTENSION, transferExecutor);\r\n    this.registerExecutor(TaskType.REFILL_TOWER, transferExecutor);\r\n\r\n    // Register defense executor\r\n    this.registerExecutor(TaskType.DEFEND_ROOM, defendExecutor);\r\n    this.registerExecutor(TaskType.TOWER_DEFENSE, defendExecutor);\r\n\r\n    // Register special operations\r\n    this.registerExecutor(TaskType.CLAIM_CONTROLLER, upgradeExecutor); // Temporary - will be updated\r\n    this.registerExecutor(TaskType.RESERVE_CONTROLLER, upgradeExecutor); // Temporary - will be updated\r\n    this.registerExecutor(TaskType.SCOUT_ROOM, idleExecutor); // Temporary - will be updated\r\n    this.registerExecutor(TaskType.RENEW_CREEP, renewExecutor);\r\n\r\n    // Register default idle\r\n    this.registerExecutor(TaskType.IDLE, idleExecutor);\r\n\r\n    console.log(`‚úÖ ExecutorFactory initialized with ${this.executors.size} executors`);\r\n  }\r\n\r\n  /**\r\n   * Get count of registered executors (useful for debugging)\r\n   */\r\n  public static getExecutorCount(): number {\r\n    return this.executors.size;\r\n  }\r\n\r\n  /**\r\n   * Get list of registered task types (useful for debugging)\r\n   */\r\n  public static getRegisteredTaskTypes(): TaskType[] {\r\n    return Array.from(this.executors.keys());\r\n  }\r\n}\r\n","import { Task } from '../interfaces';\r\nimport { ExecutorFactory, TaskStatus, TaskResult } from '../execution';\r\n\r\n/**\r\n * Legatus Legionum - The Legion Commander\r\n * \r\n * Responsibility: Execute tasks assigned to creeps\r\n * Philosophy: Every creep is a soldier executing orders\r\n * \r\n * The Legion Commander ensures each creep executes its assigned task.\r\n * It coordinates with ExecutorFactory to delegate task execution to \r\n * specialized executors, then handles the results (completion, failure, etc.)\r\n */\r\nexport class LegatusLegionum {\r\n  private roomName: string;\r\n\r\n  constructor(roomName: string) {\r\n    this.roomName = roomName;\r\n  }\r\n\r\n  /**\r\n   * Execute tasks for all creeps in the room\r\n   * \r\n   * For each creep:\r\n   * 1. Check if it has an assigned task\r\n   * 2. If no task, try to assign one from available tasks\r\n   * 3. If it has a task, execute it using the appropriate executor\r\n   * 4. Handle the result (mark complete, reassign, etc.)\r\n   */\r\n  public run(tasks: Task[]): void {\r\n    const room = Game.rooms[this.roomName];\r\n    if (!room) return;\r\n\r\n    const creeps = room.find(FIND_MY_CREEPS);\r\n    \r\n    creeps.forEach(creep => {\r\n      this.executeCreepTask(creep, tasks);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute the assigned task for a specific creep\r\n   * \r\n   * @param creep - The creep to execute a task for\r\n   * @param tasks - Available tasks in the room\r\n   */\r\n  private executeCreepTask(creep: Creep, tasks: Task[]): void {\r\n    // Get creep's assigned task\r\n    const taskId = creep.memory.task;\r\n    \r\n    if (!taskId) {\r\n      // Creep has no task - assign one\r\n      this.assignTask(creep, tasks);\r\n      return;\r\n    }\r\n    \r\n    const task = tasks.find(t => t.id === taskId);\r\n    \r\n    if (!task) {\r\n      // Task no longer exists - clear and reassign\r\n      console.log(`‚ö†Ô∏è ${creep.name}: Task ${taskId} not found, reassigning`);\r\n      creep.memory.task = undefined;\r\n      this.assignTask(creep, tasks);\r\n      return;\r\n    }\r\n    \r\n    // Get executor for this task type\r\n    const executor = ExecutorFactory.getExecutor(task.type);\r\n    if (!executor) {\r\n      console.log(`‚ö†Ô∏è ${creep.name}: No executor for task type ${task.type}`);\r\n      return;\r\n    }\r\n    \r\n    // Execute the task\r\n    console.log(`‚öôÔ∏è ${creep.name}: Executing ${task.type} (${task.id})`);\r\n    const result = executor.execute(creep, task);\r\n    console.log(`üìä ${creep.name}: Result = ${result.status}, ${result.message}`);\r\n    \r\n    // Handle result\r\n    this.handleTaskResult(creep, task, result);\r\n  }\r\n\r\n  /**\r\n   * Assign a task to an idle creep\r\n   * \r\n   * Finds the highest priority task that:\r\n   * 1. Needs more creeps assigned\r\n   * 2. The creep is capable of performing (based on body parts and state)\r\n   * \r\n   * @param creep - The creep to assign a task to\r\n   * @param tasks - Available tasks\r\n   */\r\n  private assignTask(creep: Creep, tasks: Task[]): void {\r\n    // Analyze creep body composition\r\n    const workParts = creep.body.filter(p => p.type === WORK).length;\r\n    const carryParts = creep.body.filter(p => p.type === CARRY).length;\r\n    const attackParts = creep.body.filter(p => p.type === ATTACK || p.type === RANGED_ATTACK).length;\r\n    \r\n    // Check if creep can do this task based on energy state\r\n    const hasEnergy = creep.store.getUsedCapacity(RESOURCE_ENERGY) > 0;\r\n    const hasSpace = creep.store.getFreeCapacity(RESOURCE_ENERGY) > 0;\r\n    \r\n    // Filter tasks based on creep capabilities and state\r\n    const suitableTasks = tasks.filter(t => {\r\n      // Check if already assigned to this task\r\n      if (t.assignedCreeps.includes(creep.name)) return false;\r\n      \r\n      // Check if task is full - if so, can we displace someone less suitable?\r\n      if (t.assignedCreeps.length >= t.creepsNeeded) {\r\n        const myScore = this.calculateTaskSuitability(creep, t, workParts, carryParts, attackParts);\r\n        const canDisplace = this.canDisplaceForTask(creep, t, myScore);\r\n        if (!canDisplace) return false;\r\n      }\r\n      \r\n      // Energy transfer tasks require energy\r\n      if (t.type === 'REFILL_SPAWN' || t.type === 'REFILL_EXTENSION' || \r\n          t.type === 'REFILL_TOWER' || t.type === 'HAUL_ENERGY' || t.type === 'PICKUP_ENERGY') {\r\n        if (!hasEnergy && t.type === 'PICKUP_ENERGY') return true; // Pickup needs space, not energy\r\n        if (t.type !== 'PICKUP_ENERGY' && !hasEnergy) return false;\r\n      }\r\n      \r\n      // Harvest and pickup tasks require space\r\n      if (t.type === 'HARVEST_ENERGY' || t.type === 'PICKUP_ENERGY' || t.type === 'WITHDRAW_ENERGY') {\r\n        if (!hasSpace) return false;\r\n      }\r\n      \r\n      // Upgrade/build/repair - DON'T filter by energy, let executor handle getting energy\r\n      // (Creeps can be assigned while empty, then go harvest, then execute the task)\r\n      // Only UPGRADE requires energy (it's low priority and only for already-loaded creeps)\r\n      if (t.type === 'UPGRADE_CONTROLLER') {\r\n        if (!hasEnergy) return false;\r\n      }\r\n      \r\n      // Defense tasks require attack parts\r\n      if (t.type === 'DEFEND_ROOM' && attackParts === 0) return false;\r\n      \r\n      return true;\r\n    });\r\n    \r\n    // Debug: Log why no tasks available\r\n    if (suitableTasks.length === 0) {\r\n      console.log(`üîç ${creep.name} - NO SUITABLE TASKS`);\r\n      console.log(`  Energy: ${creep.store[RESOURCE_ENERGY]}/${creep.store.getCapacity(RESOURCE_ENERGY)} (hasEnergy:${hasEnergy}, hasSpace:${hasSpace})`);\r\n      console.log(`  Body: WORK:${workParts} CARRY:${carryParts} ATTACK:${attackParts}`);\r\n      console.log(`  Total tasks: ${tasks.length}`);\r\n      tasks.forEach(t => {\r\n        const reason = [];\r\n        if (t.assignedCreeps.length >= t.creepsNeeded) reason.push('FULL');\r\n        if (t.assignedCreeps.includes(creep.name)) reason.push('ALREADY_ASSIGNED');\r\n        if (['REFILL_SPAWN', 'REFILL_EXTENSION', 'REFILL_TOWER', 'HAUL_ENERGY'].includes(t.type) && !hasEnergy) reason.push('NEEDS_ENERGY');\r\n        if (['HARVEST_ENERGY', 'PICKUP_ENERGY', 'WITHDRAW_ENERGY'].includes(t.type) && !hasSpace) reason.push('NEEDS_SPACE');\r\n        if (t.type === 'UPGRADE_CONTROLLER' && !hasEnergy) reason.push('NEEDS_ENERGY');\r\n        console.log(`    ${t.type} [${t.priority}] ${t.assignedCreeps.length}/${t.creepsNeeded} - ‚ùå ${reason.join(', ')}`);\r\n      });\r\n    }\r\n    \r\n    // Sort by priority (highest first)\r\n    suitableTasks.sort((a, b) => b.priority - a.priority);\r\n    \r\n    const availableTask = suitableTasks[0];\r\n    \r\n    if (availableTask) {\r\n      // Check if task is full and we need to displace someone\r\n      if (availableTask.assignedCreeps.length >= availableTask.creepsNeeded) {\r\n        const myScore = this.calculateTaskSuitability(creep, availableTask, workParts, carryParts, attackParts);\r\n        this.displaceWeakestForTask(creep, availableTask, myScore);\r\n      } else {\r\n        // Normal assignment\r\n        creep.memory.task = availableTask.id;\r\n        creep.memory.targetId = availableTask.targetId;\r\n        availableTask.assignedCreeps.push(creep.name);\r\n        console.log(`üìã ${creep.name} assigned to ${availableTask.type} (target: ${availableTask.targetId})`);\r\n      }\r\n    } else {\r\n      // No tasks available - assign idle task\r\n      creep.memory.task = 'idle';\r\n      creep.memory.targetId = undefined;\r\n      console.log(`üí§ ${creep.name} idle - no tasks available`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate how suitable a creep is for a specific task type\r\n   * Higher score = better fit\r\n   */\r\n  private calculateTaskSuitability(_creep: Creep, task: Task, workParts: number, carryParts: number, attackParts: number): number {\r\n    let score = 0;\r\n    \r\n    switch (task.type) {\r\n      case 'HARVEST_ENERGY':\r\n        // Harvesters: WORK parts are king\r\n        score = workParts * 10;\r\n        break;\r\n        \r\n      case 'PICKUP_ENERGY':\r\n      case 'REFILL_SPAWN':\r\n      case 'REFILL_EXTENSION':\r\n      case 'REFILL_TOWER':\r\n      case 'HAUL_ENERGY':\r\n        // Haulers: CARRY parts matter most, penalize WORK parts\r\n        score = carryParts * 10 - workParts * 5;\r\n        break;\r\n        \r\n      case 'UPGRADE_CONTROLLER':\r\n        // Upgraders: WORK parts for speed\r\n        score = workParts * 8;\r\n        break;\r\n        \r\n      case 'BUILD':\r\n      case 'REPAIR':\r\n        // Builders: WORK and CARRY both useful\r\n        score = workParts * 6 + carryParts * 4;\r\n        break;\r\n        \r\n      case 'DEFEND_ROOM':\r\n        // Defenders: ATTACK parts essential\r\n        score = attackParts * 10;\r\n        break;\r\n        \r\n      default:\r\n        // Generic tasks: balanced creeps preferred\r\n        score = workParts + carryParts;\r\n    }\r\n    \r\n    return score;\r\n  }\r\n\r\n  /**\r\n   * Check if this creep can displace someone less suitable for the task\r\n   */\r\n  private canDisplaceForTask(_creep: Creep, task: Task, myScore: number): boolean {\r\n    // Find least suitable assigned creep\r\n    for (const assignedName of task.assignedCreeps) {\r\n      const assignedCreep = Game.creeps[assignedName];\r\n      if (!assignedCreep) continue;\r\n      \r\n      const workParts = assignedCreep.body.filter(p => p.type === WORK).length;\r\n      const carryParts = assignedCreep.body.filter(p => p.type === CARRY).length;\r\n      const attackParts = assignedCreep.body.filter(p => p.type === ATTACK || p.type === RANGED_ATTACK).length;\r\n      \r\n      const theirScore = this.calculateTaskSuitability(assignedCreep, task, workParts, carryParts, attackParts);\r\n      if (myScore > theirScore) {\r\n        return true; // We can displace at least one less suitable creep\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Displace the least suitable creep and assign this one instead\r\n   */\r\n  private displaceWeakestForTask(creep: Creep, task: Task, myScore: number): void {\r\n    let weakestCreep: Creep | null = null;\r\n    let weakestScore = myScore;\r\n    \r\n    // Find the least suitable assigned creep\r\n    for (const assignedName of task.assignedCreeps) {\r\n      const assignedCreep = Game.creeps[assignedName];\r\n      if (!assignedCreep) continue;\r\n      \r\n      const workParts = assignedCreep.body.filter(p => p.type === WORK).length;\r\n      const carryParts = assignedCreep.body.filter(p => p.type === CARRY).length;\r\n      const attackParts = assignedCreep.body.filter(p => p.type === ATTACK || p.type === RANGED_ATTACK).length;\r\n      \r\n      const theirScore = this.calculateTaskSuitability(assignedCreep, task, workParts, carryParts, attackParts);\r\n      if (theirScore < weakestScore) {\r\n        weakestCreep = assignedCreep;\r\n        weakestScore = theirScore;\r\n      }\r\n    }\r\n    \r\n    if (weakestCreep) {\r\n      // Remove less suitable creep from task\r\n      const index = task.assignedCreeps.indexOf(weakestCreep.name);\r\n      if (index > -1) {\r\n        task.assignedCreeps.splice(index, 1);\r\n      }\r\n      weakestCreep.memory.task = undefined;\r\n      weakestCreep.memory.targetId = undefined;\r\n      \r\n      // Assign better suited creep\r\n      creep.memory.task = task.id;\r\n      creep.memory.targetId = task.targetId;\r\n      task.assignedCreeps.push(creep.name);\r\n      \r\n      console.log(`‚öîÔ∏è ${creep.name} (score:${myScore}) displaced ${weakestCreep.name} (score:${weakestScore}) from ${task.type}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle the result of a task execution\r\n   * \r\n   * @param creep - The creep that executed the task\r\n   * @param task - The task that was executed\r\n   * @param result - The result of the execution\r\n   */\r\n  private handleTaskResult(creep: Creep, task: Task, result: TaskResult): void {\r\n    if (result.status === TaskStatus.COMPLETED) {\r\n      // Task complete - clear assignment\r\n      creep.memory.task = undefined;\r\n      creep.memory.targetId = undefined;\r\n      const index = task.assignedCreeps.indexOf(creep.name);\r\n      if (index > -1) {\r\n        task.assignedCreeps.splice(index, 1);\r\n      }\r\n      console.log(`‚úÖ ${creep.name} completed ${task.type}`);\r\n    } else if (result.status === TaskStatus.FAILED) {\r\n      // Task failed - log and clear\r\n      console.log(`‚ùå ${creep.name} failed ${task.type}: ${result.message || 'Unknown error'}`);\r\n      creep.memory.task = undefined;\r\n      creep.memory.targetId = undefined;\r\n      const index = task.assignedCreeps.indexOf(creep.name);\r\n      if (index > -1) {\r\n        task.assignedCreeps.splice(index, 1);\r\n      }\r\n    } else if (result.status === TaskStatus.BLOCKED) {\r\n      // Task blocked - log and clear for reassignment\r\n      console.log(`üö´ ${creep.name} blocked on ${task.type}: ${result.message || 'Task blocked'}`);\r\n      creep.memory.task = undefined;\r\n      const index = task.assignedCreeps.indexOf(creep.name);\r\n      if (index > -1) {\r\n        task.assignedCreeps.splice(index, 1);\r\n      }\r\n    }\r\n    // IN_PROGRESS: Continue normally next tick\r\n  }\r\n}\r\n","import { LegatusArchivus } from '../magistrates/LegatusArchivus';\r\nimport { LegatusOfficio } from '../magistrates/LegatusOfficio';\r\nimport { LegatusGenetor } from '../magistrates/LegatusGenetor';\r\nimport { LegatusFabrum } from '../magistrates/LegatusFabrum';\r\nimport { LegatusViae } from '../magistrates/LegatusViae';\r\nimport { LegatusLegionum } from '../magistrates/LegatusLegionum';\r\n\r\n/**\r\n * Room-specific magistrate instances\r\n */\r\ninterface RoomMagistrates {\r\n  archivist: LegatusArchivus;\r\n  taskmaster: LegatusOfficio;\r\n  broodmother: LegatusGenetor;\r\n  architect: LegatusFabrum;\r\n  trailblazer: LegatusViae;\r\n  legionCommander: LegatusLegionum;\r\n}\r\n\r\n/**\r\n * The Empire - The Principate\r\n * \r\n * The highest authority in Project Imperium. Orchestrates all subordinate systems\r\n * and executes the grand strategy each tick.\r\n * \r\n * Responsibilities:\r\n * - Initialize all Magistrate instances per room\r\n * - Execute the main decision cycle each tick\r\n * - Handle empire-wide state management\r\n * - Maintain the magistrate execution chain\r\n */\r\nexport class Empire {\r\n  private isInitialized: boolean = false;\r\n  private magistratesByRoom: Map<string, RoomMagistrates> = new Map();\r\n\r\n  constructor() {\r\n    console.log('üèõÔ∏è The Empire awakens...');\r\n  }\r\n\r\n  /**\r\n   * Main execution function - called every game tick\r\n   */\r\n  public run(): void {\r\n    if (!this.isInitialized) {\r\n      this.initialize();\r\n    }\r\n\r\n    // TODO: This will be expanded after Magistrate classes are built\r\n    this.executeImperialStrategy();\r\n  }\r\n\r\n  private initialize(): void {\r\n    console.log('‚öîÔ∏è Ave Imperator! Project Imperium initializing...');\r\n    \r\n    // TODO: Initialize Consuls (after they are created)\r\n    // TODO: Initialize Magistrates for each room\r\n    \r\n    this.isInitialized = true;\r\n  }\r\n\r\n  private executeImperialStrategy(): void {\r\n    // High-level empire logic - coordinate all rooms\r\n    // Each room has its own magistrate council\r\n    \r\n    for (const roomName in Game.rooms) {\r\n      const room = Game.rooms[roomName];\r\n      \r\n      // Only manage rooms we control\r\n      if (room.controller && room.controller.my) {\r\n        this.manageColonia(room);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Manage a single colony (room) through its magistrate council\r\n   * Executes the full decision and execution chain\r\n   */\r\n  private manageColonia(room: Room): void {\r\n    // Get or create magistrates for this room\r\n    if (!this.magistratesByRoom.has(room.name)) {\r\n      this.magistratesByRoom.set(room.name, {\r\n        archivist: new LegatusArchivus(room.name),\r\n        taskmaster: new LegatusOfficio(room.name),\r\n        broodmother: new LegatusGenetor(room.name),\r\n        architect: new LegatusFabrum(room.name),\r\n        trailblazer: new LegatusViae(room.name),\r\n        legionCommander: new LegatusLegionum(room.name)\r\n      });\r\n    }\r\n\r\n    const magistrates = this.magistratesByRoom.get(room.name)!;\r\n\r\n    // Initialize room memory for tasks if needed\r\n    if (!room.memory.tasks) {\r\n      room.memory.tasks = [];\r\n    }\r\n\r\n    // Execute the Magistrate chain in order\r\n    // 1. Archivist observes the room state\r\n    const report = magistrates.archivist.run(room);\r\n    console.log(`üìä ${room.name} Report: energyDeficit=${report.energyDeficit}, sources=${report.sources.length}, upgraderShortage=${report.controller.upgraderRecommendation - report.controller.upgraderCount}`);\r\n    \r\n    // Debug source info\r\n    report.sources.forEach((s, i) => {\r\n      console.log(`   Source ${i}: energy=${s.energy}, harvesters=${s.harvestersPresent}/${s.harvestersNeeded}`);\r\n    });\r\n    \r\n    // 2. Taskmaster generates tasks based on the report\r\n    // Use existing tasks from memory, or generate new ones if none exist\r\n    let tasks = room.memory.tasks || [];\r\n    \r\n    // Clean up completed tasks (no assigned creeps and not needed anymore)\r\n    tasks = tasks.filter(t => t.assignedCreeps.length > 0 || t.creepsNeeded > 0);\r\n    \r\n    // Generate new tasks if we have none, or refresh periodically (every 10 ticks)\r\n    if (tasks.length === 0 || Game.time % 10 === 0) {\r\n      const newTasks = magistrates.taskmaster.run(report);\r\n      \r\n      // Merge new tasks with existing ones (preserve assignments)\r\n      newTasks.forEach(newTask => {\r\n        const existing = tasks.find(t => \r\n          t.type === newTask.type && \r\n          t.targetId === newTask.targetId\r\n        );\r\n        \r\n        if (existing) {\r\n          // Update existing task's priority and needs\r\n          existing.priority = newTask.priority;\r\n          existing.creepsNeeded = newTask.creepsNeeded;\r\n        } else {\r\n          // Add new task\r\n          tasks.push(newTask);\r\n        }\r\n      });\r\n      \r\n      console.log(`üìã ${room.name}: Refreshed tasks - ${tasks.length} total`);\r\n    }\r\n    \r\n    if (tasks.length > 0) {\r\n      tasks.forEach(t => console.log(`   - ${t.type} (priority ${t.priority}, ${t.assignedCreeps.length}/${t.creepsNeeded} creeps)`));\r\n    }\r\n    \r\n    // Store tasks in room memory for persistence\r\n    room.memory.tasks = tasks;\r\n    \r\n    // 3. Broodmother spawns creeps based on tasks\r\n    magistrates.broodmother.run(tasks);\r\n    \r\n    // 4. Legion Commander executes tasks with existing creeps\r\n    magistrates.legionCommander.run(tasks);\r\n    \r\n    // 5. Architect handles construction\r\n    magistrates.architect.run();\r\n    \r\n    // 6. Trailblazer handles pathfinding and movement\r\n    magistrates.trailblazer.run();\r\n  }\r\n}\r\n","import { Empire } from './principate/Empire';\r\n\r\n// Initialize the Empire once (persists across ticks via global scope)\r\nconst empire = new Empire();\r\n\r\n// This is the main game loop - called every tick by Screeps\r\nexport const loop = (): void => {\r\n  try {\r\n    // Clear dead creep memory\r\n    for (const name in Memory.creeps) {\r\n      if (!(name in Game.creeps)) {\r\n        delete Memory.creeps[name];\r\n      }\r\n    }\r\n\r\n    // Execute the Empire's master plan\r\n    empire.run();\r\n  } catch (error) {\r\n    console.log(`‚ùå CRITICAL ERROR in main loop: ${error}`);\r\n    if (error instanceof Error) {\r\n      console.log(`Stack: ${error.stack}`);\r\n    }\r\n  }\r\n};\r\n"],"names":[],"mappings":"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"}