{"version":3,"file":"main.js","sources":["../src/magistrates/LegatusArchivus.ts","../src/interfaces/TaskType.ts","../src/magistrates/LegatusOfficio.ts","../src/magistrates/LegatusGenetor.ts","../src/magistrates/LegatusFabrum.ts","../src/magistrates/LegatusViae.ts","../src/execution/TaskResult.ts","../src/execution/TaskExecutor.ts","../src/execution/executors/HarvestExecutor.ts","../src/execution/executors/TransferExecutor.ts","../src/execution/executors/UpgradeExecutor.ts","../src/execution/executors/BuildExecutor.ts","../src/execution/executors/RepairExecutor.ts","../src/execution/executors/WithdrawExecutor.ts","../src/execution/executors/DefendExecutor.ts","../src/execution/executors/IdleExecutor.ts","../src/execution/ExecutorFactory.ts","../src/magistrates/LegatusLegionum.ts","../src/principate/Empire.ts","../src/main.ts"],"sourcesContent":["/// <reference types=\"screeps\" />\r\n\r\nimport {\r\n  ArchivistReport,\r\n  SourceReport,\r\n  SpawnReport,\r\n  TowerReport,\r\n  ContainerReport,\r\n  ConstructionSiteReport,\r\n  RepairTargetReport,\r\n  ControllerReport,\r\n  HostileReport\r\n} from '../interfaces';\r\n\r\n/**\r\n * Legatus Archivus - The Archivist\r\n * \r\n * Responsibility: Observe and report on room state\r\n * Philosophy: No decisions, no opinions - only data\r\n * \r\n * The Archivist is the eyes and ears of the Magistrates.\r\n * It produces a clean, structured report that other modules consume.\r\n */\r\nexport class LegatusArchivus {\r\n  constructor(readonly roomName: string) {}\r\n\r\n  /**\r\n   * Generate a comprehensive report on the room's current state\r\n   */\r\n  public run(room: Room): ArchivistReport {\r\n    return {\r\n      roomName: room.name,\r\n      rcl: room.controller?.level || 0,\r\n      \r\n      energyAvailable: room.energyAvailable,\r\n      energyCapacityAvailable: room.energyCapacityAvailable,\r\n      energyDeficit: room.energyCapacityAvailable - room.energyAvailable,\r\n      \r\n      sources: this.analyzeSources(room),\r\n      spawns: this.analyzeSpawns(room),\r\n      extensions: room.find(FIND_MY_STRUCTURES, {\r\n        filter: (s) => s.structureType === STRUCTURE_EXTENSION\r\n      }).length,\r\n      towers: this.analyzeTowers(room),\r\n      containers: this.analyzeContainers(room),\r\n      storageAvailable: room.storage !== undefined,\r\n      storageEnergy: room.storage?.store[RESOURCE_ENERGY] || 0,\r\n      \r\n      constructionSites: this.analyzeConstructionSites(room),\r\n      repairTargets: this.analyzeRepairTargets(room),\r\n      \r\n      controller: this.analyzeController(room),\r\n      \r\n      hostiles: this.analyzeHostiles(room),\r\n      hostileThreatLevel: this.calculateThreatLevel(room),\r\n      \r\n      creepsByRole: this.countCreepsByRole(room),\r\n      totalCreeps: this.countTotalCreeps(room),\r\n      \r\n      highTrafficPositions: [] // TODO: Implement traffic analysis\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Analyze all energy sources in the room\r\n   */\r\n  private analyzeSources(room: Room): SourceReport[] {\r\n    const sources = room.find(FIND_SOURCES);\r\n    return sources.map(source => {\r\n      const harvesters = room.find(FIND_MY_CREEPS, {\r\n        filter: (c) => c.memory.role === 'harvester' && \r\n                       c.memory.targetId === source.id\r\n      });\r\n      \r\n      return {\r\n        id: source.id,\r\n        pos: { x: source.pos.x, y: source.pos.y },\r\n        energy: source.energy,\r\n        energyCapacity: source.energyCapacity,\r\n        harvestersPresent: harvesters.length,\r\n        harvestersNeeded: 2 // Simple default - can be improved\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyze all spawn structures in the room\r\n   */\r\n  private analyzeSpawns(room: Room): SpawnReport[] {\r\n    const spawns = room.find(FIND_MY_SPAWNS);\r\n    return spawns.map(spawn => ({\r\n      id: spawn.id,\r\n      spawning: spawn.spawning !== null,\r\n      energy: spawn.store[RESOURCE_ENERGY],\r\n      energyCapacity: spawn.store.getCapacity(RESOURCE_ENERGY)\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Analyze all tower structures in the room\r\n   */\r\n  private analyzeTowers(room: Room): TowerReport[] {\r\n    const towers = room.find(FIND_MY_STRUCTURES, {\r\n      filter: (s) => s.structureType === STRUCTURE_TOWER\r\n    }) as StructureTower[];\r\n    \r\n    return towers.map(tower => ({\r\n      id: tower.id,\r\n      energy: tower.store[RESOURCE_ENERGY],\r\n      energyCapacity: tower.store.getCapacity(RESOURCE_ENERGY),\r\n      needsRefill: tower.store[RESOURCE_ENERGY] < tower.store.getCapacity(RESOURCE_ENERGY) * 0.5\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Analyze all container structures in the room\r\n   */\r\n  private analyzeContainers(room: Room): ContainerReport[] {\r\n    const containers = room.find(FIND_STRUCTURES, {\r\n      filter: (s) => s.structureType === STRUCTURE_CONTAINER\r\n    }) as StructureContainer[];\r\n    \r\n    return containers.map(container => ({\r\n      id: container.id,\r\n      pos: { x: container.pos.x, y: container.pos.y },\r\n      store: { energy: container.store[RESOURCE_ENERGY] },\r\n      storeCapacity: container.store.getCapacity(RESOURCE_ENERGY)\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Analyze all construction sites in the room\r\n   */\r\n  private analyzeConstructionSites(room: Room): ConstructionSiteReport[] {\r\n    const sites = room.find(FIND_MY_CONSTRUCTION_SITES);\r\n    return sites.map(site => ({\r\n      id: site.id,\r\n      structureType: site.structureType,\r\n      progress: site.progress,\r\n      progressTotal: site.progressTotal,\r\n      pos: { x: site.pos.x, y: site.pos.y }\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Analyze all structures that need repair\r\n   */\r\n  private analyzeRepairTargets(room: Room): RepairTargetReport[] {\r\n    const structures = room.find(FIND_STRUCTURES, {\r\n      filter: (s) => s.hits < s.hitsMax && s.structureType !== STRUCTURE_WALL\r\n    });\r\n    \r\n    return structures.map(structure => ({\r\n      id: structure.id,\r\n      structureType: structure.structureType,\r\n      hits: structure.hits,\r\n      hitsMax: structure.hitsMax,\r\n      priority: this.calculateRepairPriority(structure),\r\n      pos: { x: structure.pos.x, y: structure.pos.y }\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Calculate repair priority for a structure based on type and condition\r\n   */\r\n  private calculateRepairPriority(structure: Structure): number {\r\n    const hitPercent = structure.hits / structure.hitsMax;\r\n    \r\n    // Critical structures get higher priority\r\n    const criticalStructures: StructureConstant[] = [\r\n      STRUCTURE_SPAWN,\r\n      STRUCTURE_TOWER,\r\n      STRUCTURE_STORAGE,\r\n      STRUCTURE_TERMINAL\r\n    ];\r\n    \r\n    if ((criticalStructures as StructureConstant[]).includes(structure.structureType)) {\r\n      return hitPercent < 0.5 ? 90 : 70;\r\n    }\r\n    \r\n    return hitPercent < 0.3 ? 50 : 30;\r\n  }\r\n\r\n  /**\r\n   * Analyze the room controller status\r\n   */\r\n  private analyzeController(room: Room): ControllerReport {\r\n    const controller = room.controller!;\r\n    return {\r\n      id: controller.id,\r\n      level: controller.level,\r\n      progress: controller.progress,\r\n      progressTotal: controller.progressTotal,\r\n      ticksToDowngrade: controller.ticksToDowngrade || 0,\r\n      upgraderCount: this.countUpgraders(room),\r\n      upgraderRecommendation: this.recommendUpgraders(controller)\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Count how many upgrader creeps are currently active\r\n   */\r\n  private countUpgraders(room: Room): number {\r\n    return room.find(FIND_MY_CREEPS, {\r\n      filter: (c) => c.memory.role === 'upgrader'\r\n    }).length;\r\n  }\r\n\r\n  /**\r\n   * Recommend optimal number of upgraders based on controller level\r\n   */\r\n  private recommendUpgraders(controller: StructureController): number {\r\n    // Simple logic: more upgraders for higher RCL\r\n    if (controller.level < 3) return 1;\r\n    if (controller.level < 5) return 2;\r\n    return 3;\r\n  }\r\n\r\n  /**\r\n   * Analyze all hostile creeps in the room\r\n   */\r\n  private analyzeHostiles(room: Room): HostileReport[] {\r\n    const hostiles = room.find(FIND_HOSTILE_CREEPS);\r\n    return hostiles.map(hostile => ({\r\n      id: hostile.id,\r\n      pos: { x: hostile.pos.x, y: hostile.pos.y },\r\n      owner: hostile.owner.username,\r\n      body: hostile.body.map(part => part.type),\r\n      threatLevel: this.calculateCreepThreat(hostile)\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Calculate threat level of a creep based on body composition\r\n   */\r\n  private calculateCreepThreat(creep: Creep): number {\r\n    let threat = 0;\r\n    creep.body.forEach(part => {\r\n      if (part.type === ATTACK) threat += 3;\r\n      if (part.type === RANGED_ATTACK) threat += 2;\r\n      if (part.type === HEAL) threat += 2;\r\n      if (part.type === TOUGH) threat += 1;\r\n    });\r\n    return threat;\r\n  }\r\n\r\n  /**\r\n   * Calculate overall threat level for the room (0-10 scale)\r\n   */\r\n  private calculateThreatLevel(room: Room): number {\r\n    const hostiles = room.find(FIND_HOSTILE_CREEPS);\r\n    if (hostiles.length === 0) return 0;\r\n    \r\n    const totalThreat = hostiles.reduce((sum, h) => sum + this.calculateCreepThreat(h), 0);\r\n    return Math.min(10, Math.ceil(totalThreat / 5));\r\n  }\r\n\r\n  /**\r\n   * Count creeps by role\r\n   */\r\n  private countCreepsByRole(room: Room): Map<string, number> {\r\n    const creeps = room.find(FIND_MY_CREEPS);\r\n    const counts = new Map<string, number>();\r\n    \r\n    creeps.forEach(creep => {\r\n      const role = creep.memory.role || 'unknown';\r\n      counts.set(role, (counts.get(role) || 0) + 1);\r\n    });\r\n    \r\n    return counts;\r\n  }\r\n\r\n  /**\r\n   * Count total creeps in the room\r\n   */\r\n  private countTotalCreeps(room: Room): number {\r\n    return room.find(FIND_MY_CREEPS).length;\r\n  }\r\n}\r\n","/**\r\n * All possible task types in the Empire\r\n * These represent the fundamental actions a creep can be assigned\r\n */\r\nexport enum TaskType {\r\n  // Energy Management\r\n  HARVEST_ENERGY = 'HARVEST_ENERGY',\r\n  HAUL_ENERGY = 'HAUL_ENERGY',\r\n  WITHDRAW_ENERGY = 'WITHDRAW_ENERGY',\r\n  \r\n  // Construction & Repair\r\n  BUILD = 'BUILD',\r\n  REPAIR = 'REPAIR',\r\n  \r\n  // Controller Operations\r\n  UPGRADE_CONTROLLER = 'UPGRADE_CONTROLLER',\r\n  \r\n  // Defense\r\n  DEFEND_ROOM = 'DEFEND_ROOM',\r\n  TOWER_DEFENSE = 'TOWER_DEFENSE',\r\n  \r\n  // Logistics\r\n  REFILL_SPAWN = 'REFILL_SPAWN',\r\n  REFILL_EXTENSION = 'REFILL_EXTENSION',\r\n  REFILL_TOWER = 'REFILL_TOWER',\r\n  \r\n  // Special Operations\r\n  CLAIM_CONTROLLER = 'CLAIM_CONTROLLER',\r\n  RESERVE_CONTROLLER = 'RESERVE_CONTROLLER',\r\n  SCOUT_ROOM = 'SCOUT_ROOM',\r\n  \r\n  // Idle/Default\r\n  IDLE = 'IDLE'\r\n}\r\n","import { ArchivistReport, Task, TaskType } from '../interfaces';\r\n\r\n/**\r\n * Legatus Officio - The Taskmaster\r\n * \r\n * Responsibility: Transform observations into actionable tasks\r\n * Philosophy: Every problem is a task waiting to be solved\r\n * \r\n * The Taskmaster reads the Archivist's report and creates a prioritized\r\n * work queue. It doesn't care WHO does the work - just WHAT needs doing.\r\n */\r\nexport class LegatusOfficio {\r\n  private roomName: string;\r\n  private taskIdCounter: number = 0;\r\n\r\n  constructor(roomName: string) {\r\n    this.roomName = roomName;\r\n  }\r\n\r\n  /**\r\n   * Analyze the room report and generate prioritized tasks\r\n   */\r\n  public run(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n\r\n    // Priority 1: Emergency Defense\r\n    if (report.hostileThreatLevel > 0) {\r\n      tasks.push(...this.createDefenseTasks(report));\r\n    }\r\n\r\n    // Priority 2: Spawn Energy (can't do anything without energy)\r\n    if (report.energyDeficit > 0) {\r\n      tasks.push(...this.createEnergyTasks(report));\r\n    }\r\n\r\n    // Priority 3: Tower Maintenance\r\n    if (report.towers.some(t => t.needsRefill)) {\r\n      tasks.push(...this.createTowerRefillTasks(report));\r\n    }\r\n\r\n    // Priority 4: Construction\r\n    if (report.constructionSites.length > 0) {\r\n      tasks.push(...this.createConstructionTasks(report));\r\n    }\r\n\r\n    // Priority 5: Critical Repairs\r\n    const criticalRepairs = report.repairTargets.filter(r => r.priority > 70);\r\n    if (criticalRepairs.length > 0) {\r\n      tasks.push(...this.createRepairTasks(criticalRepairs));\r\n    }\r\n\r\n    // Priority 6: Controller Upgrade\r\n    tasks.push(...this.createUpgradeTasks(report));\r\n\r\n    // Priority 7: Non-Critical Repairs\r\n    const minorRepairs = report.repairTargets.filter(r => r.priority <= 70);\r\n    if (minorRepairs.length > 0) {\r\n      tasks.push(...this.createRepairTasks(minorRepairs));\r\n    }\r\n\r\n    // Sort by priority (highest first)\r\n    return tasks.sort((a, b) => b.priority - a.priority);\r\n  }\r\n\r\n  private createDefenseTasks(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n    \r\n    report.hostiles.forEach(hostile => {\r\n      tasks.push({\r\n        id: this.generateTaskId(),\r\n        type: TaskType.DEFEND_ROOM,\r\n        priority: 95 + report.hostileThreatLevel,\r\n        targetId: hostile.id,\r\n        targetPos: { x: hostile.pos.x, y: hostile.pos.y, roomName: this.roomName },\r\n        creepsNeeded: Math.ceil(hostile.threatLevel / 10),\r\n        assignedCreeps: []\r\n      });\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createEnergyTasks(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n\r\n    // Harvest from sources\r\n    report.sources.forEach(source => {\r\n      if (source.energy > 0 && source.harvestersPresent < source.harvestersNeeded) {\r\n        tasks.push({\r\n          id: this.generateTaskId(),\r\n          type: TaskType.HARVEST_ENERGY,\r\n          priority: 85,\r\n          targetId: source.id,\r\n          targetPos: { x: source.pos.x, y: source.pos.y, roomName: this.roomName },\r\n          creepsNeeded: source.harvestersNeeded - source.harvestersPresent,\r\n          assignedCreeps: []\r\n        });\r\n      }\r\n    });\r\n\r\n    // Haul energy from containers to spawns/extensions\r\n    report.containers.forEach(container => {\r\n      if (container.store.energy > 100 && report.energyDeficit > 0) {\r\n        tasks.push({\r\n          id: this.generateTaskId(),\r\n          type: TaskType.HAUL_ENERGY,\r\n          priority: 80,\r\n          targetId: container.id,\r\n          targetPos: { x: container.pos.x, y: container.pos.y, roomName: this.roomName },\r\n          creepsNeeded: 1,\r\n          assignedCreeps: [],\r\n          metadata: {\r\n            energyAvailable: container.store.energy\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createTowerRefillTasks(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n\r\n    report.towers.forEach(tower => {\r\n      if (tower.needsRefill) {\r\n        const energyNeeded = tower.energyCapacity - tower.energy;\r\n        tasks.push({\r\n          id: this.generateTaskId(),\r\n          type: TaskType.REFILL_TOWER,\r\n          priority: 75,\r\n          targetId: tower.id,\r\n          creepsNeeded: Math.ceil(energyNeeded / 500),\r\n          assignedCreeps: [],\r\n          metadata: {\r\n            energyRequired: energyNeeded\r\n          }\r\n        });\r\n      }\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createConstructionTasks(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n\r\n    report.constructionSites.forEach(site => {\r\n      // Prioritize spawns and towers\r\n      let priority = 60;\r\n      if (site.structureType === STRUCTURE_SPAWN) priority = 85;\r\n      if (site.structureType === STRUCTURE_TOWER) priority = 80;\r\n      if (site.structureType === STRUCTURE_EXTENSION) priority = 70;\r\n\r\n      tasks.push({\r\n        id: this.generateTaskId(),\r\n        type: TaskType.BUILD,\r\n        priority: priority,\r\n        targetId: site.id,\r\n        targetPos: { x: site.pos.x, y: site.pos.y, roomName: this.roomName },\r\n        creepsNeeded: Math.ceil((site.progressTotal - site.progress) / 5000),\r\n        assignedCreeps: [],\r\n        metadata: {\r\n          structureType: site.structureType,\r\n          remainingWork: site.progressTotal - site.progress\r\n        }\r\n      });\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createRepairTasks(repairTargets: any[]): Task[] {\r\n    const tasks: Task[] = [];\r\n\r\n    repairTargets.forEach(target => {\r\n      tasks.push({\r\n        id: this.generateTaskId(),\r\n        type: TaskType.REPAIR,\r\n        priority: target.priority,\r\n        targetId: target.id,\r\n        targetPos: { x: target.pos.x, y: target.pos.y, roomName: this.roomName },\r\n        creepsNeeded: 1,\r\n        assignedCreeps: [],\r\n        metadata: {\r\n          structureType: target.structureType,\r\n          hitsNeeded: target.hitsMax - target.hits\r\n        }\r\n      });\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private createUpgradeTasks(report: ArchivistReport): Task[] {\r\n    const tasks: Task[] = [];\r\n\r\n    // ALWAYS create upgrade tasks - upgrading is core gameplay\r\n    const upgraderShortage = report.controller.upgraderRecommendation - \r\n                             report.controller.upgraderCount;\r\n\r\n    const priority = report.controller.ticksToDowngrade < 5000 ? 90 : 55;\r\n    const creepsNeeded = upgraderShortage > 0 ? upgraderShortage : 1;\r\n    \r\n    tasks.push({\r\n      id: this.generateTaskId(),\r\n      type: TaskType.UPGRADE_CONTROLLER,\r\n      priority: priority,\r\n      targetId: report.controller.id,\r\n      creepsNeeded: creepsNeeded,\r\n      assignedCreeps: []\r\n    });\r\n\r\n    return tasks;\r\n  }\r\n\r\n  private generateTaskId(): string {\r\n    return `task_${this.roomName}_${Game.time}_${this.taskIdCounter++}`;\r\n  }\r\n}\r\n","import { Task, CreepRequest, TaskType } from '../interfaces';\r\n\r\n/**\r\n * Legatus Genetor - The Broodmother\r\n * \r\n * Responsibility: Design and spawn creeps optimized for tasks\r\n * Philosophy: The right tool for the right job\r\n * \r\n * The Broodmother looks at the task queue and determines if a new creep\r\n * is needed. If so, it designs the perfect body for that task.\r\n */\r\nexport class LegatusGenetor {\r\n  private roomName: string;\r\n\r\n  constructor(roomName: string) {\r\n    this.roomName = roomName;\r\n  }\r\n\r\n  /**\r\n   * Analyze tasks and spawn creeps as needed\r\n   */\r\n  public run(tasks: Task[]): void {\r\n    const room = Game.rooms[this.roomName];\r\n    if (!room) return;\r\n\r\n    // Find available spawns\r\n    const spawns = room.find(FIND_MY_SPAWNS, {\r\n      filter: (s) => !s.spawning\r\n    });\r\n\r\n    if (spawns.length === 0) return;\r\n\r\n    // Find highest priority task that needs creeps\r\n    const taskNeedingCreeps = tasks.find(t => \r\n      t.assignedCreeps.length < t.creepsNeeded\r\n    );\r\n\r\n    if (!taskNeedingCreeps) return;\r\n\r\n    // Design and spawn a creep for this task\r\n    const request = this.designCreep(taskNeedingCreeps, room);\r\n    if (request) {\r\n      this.spawnCreep(spawns[0], request);\r\n    }\r\n  }\r\n\r\n  private designCreep(task: Task, room: Room): CreepRequest | null {\r\n    const energy = room.energyAvailable;\r\n    \r\n    // Design body based on task type\r\n    let body: BodyPartConstant[] = [];\r\n    let role: string = '';\r\n\r\n    switch (task.type) {\r\n      case TaskType.HARVEST_ENERGY:\r\n        body = this.designHarvester(energy);\r\n        role = 'harvester';\r\n        break;\r\n      \r\n      case TaskType.HAUL_ENERGY:\r\n      case TaskType.REFILL_TOWER:\r\n      case TaskType.REFILL_SPAWN:\r\n      case TaskType.REFILL_EXTENSION:\r\n        body = this.designHauler(energy);\r\n        role = 'hauler';\r\n        break;\r\n      \r\n      case TaskType.BUILD:\r\n        body = this.designBuilder(energy);\r\n        role = 'builder';\r\n        break;\r\n      \r\n      case TaskType.REPAIR:\r\n        body = this.designRepairer(energy);\r\n        role = 'repairer';\r\n        break;\r\n      \r\n      case TaskType.UPGRADE_CONTROLLER:\r\n        body = this.designUpgrader(energy);\r\n        role = 'upgrader';\r\n        break;\r\n      \r\n      case TaskType.DEFEND_ROOM:\r\n        body = this.designDefender(energy);\r\n        role = 'defender';\r\n        break;\r\n      \r\n      default:\r\n        body = this.designWorker(energy);\r\n        role = 'worker';\r\n    }\r\n\r\n    if (body.length === 0) return null;\r\n\r\n    const cost = this.calculateBodyCost(body);\r\n\r\n    return {\r\n      priority: task.priority,\r\n      body: body,\r\n      memory: {\r\n        role: role,\r\n        room: this.roomName,\r\n        task: task.id,\r\n        targetId: task.targetId?.toString()\r\n      },\r\n      initialTask: task,\r\n      cost: cost,\r\n      role: role\r\n    };\r\n  }\r\n\r\n  private designHarvester(energy: number): BodyPartConstant[] {\r\n    // Optimal harvester: 1 WORK per 2 MOVE for speed\r\n    // Max 5 WORK parts (source energy/tick limit)\r\n    const parts: BodyPartConstant[] = [];\r\n    const maxWork = 5;\r\n    let workParts = 0;\r\n    let moveParts = 0;\r\n\r\n    while (energy >= 150 && workParts < maxWork) {\r\n      parts.push(WORK);\r\n      parts.push(MOVE);\r\n      workParts++;\r\n      moveParts++;\r\n      energy -= 150;\r\n    }\r\n\r\n    // Add carry for pickup\r\n    if (energy >= 50) {\r\n      parts.push(CARRY);\r\n      energy -= 50;\r\n    }\r\n\r\n    return parts.length > 0 ? parts : [WORK, CARRY, MOVE];\r\n  }\r\n\r\n  private designHauler(energy: number): BodyPartConstant[] {\r\n    // Hauler: Maximize CARRY with MOVE for speed\r\n    const parts: BodyPartConstant[] = [];\r\n    \r\n    while (energy >= 100) {\r\n      parts.push(CARRY);\r\n      parts.push(MOVE);\r\n      energy -= 100;\r\n    }\r\n\r\n    return parts.length > 0 ? parts : [CARRY, MOVE];\r\n  }\r\n\r\n  private designBuilder(energy: number): BodyPartConstant[] {\r\n    // Builder: Balanced WORK, CARRY, MOVE\r\n    const parts: BodyPartConstant[] = [];\r\n    \r\n    while (energy >= 200) {\r\n      parts.push(WORK);\r\n      parts.push(CARRY);\r\n      parts.push(MOVE);\r\n      energy -= 200;\r\n    }\r\n\r\n    return parts.length > 0 ? parts : [WORK, CARRY, MOVE];\r\n  }\r\n\r\n  private designRepairer(energy: number): BodyPartConstant[] {\r\n    // Same as builder\r\n    return this.designBuilder(energy);\r\n  }\r\n\r\n  private designUpgrader(energy: number): BodyPartConstant[] {\r\n    // Upgrader: More WORK than builder for efficiency\r\n    const parts: BodyPartConstant[] = [];\r\n    \r\n    while (energy >= 300) {\r\n      parts.push(WORK);\r\n      parts.push(WORK);\r\n      parts.push(CARRY);\r\n      parts.push(MOVE);\r\n      energy -= 300;\r\n    }\r\n\r\n    return parts.length > 0 ? parts : [WORK, CARRY, MOVE];\r\n  }\r\n\r\n  private designDefender(energy: number): BodyPartConstant[] {\r\n    // Defender: ATTACK, MOVE, some TOUGH\r\n    const parts: BodyPartConstant[] = [];\r\n    \r\n    // Add tough armor first\r\n    if (energy >= 10) {\r\n      parts.push(TOUGH);\r\n      energy -= 10;\r\n    }\r\n\r\n    // Add attack and move\r\n    while (energy >= 130) {\r\n      parts.push(ATTACK);\r\n      parts.push(MOVE);\r\n      energy -= 130;\r\n    }\r\n\r\n    return parts.length > 0 ? parts : [ATTACK, MOVE];\r\n  }\r\n\r\n  private designWorker(energy: number): BodyPartConstant[] {\r\n    // Generic worker: balanced parts\r\n    const parts: BodyPartConstant[] = [];\r\n    \r\n    while (energy >= 200) {\r\n      parts.push(WORK);\r\n      parts.push(CARRY);\r\n      parts.push(MOVE);\r\n      energy -= 200;\r\n    }\r\n\r\n    return parts.length > 0 ? parts : [WORK, CARRY, MOVE];\r\n  }\r\n\r\n  private calculateBodyCost(body: BodyPartConstant[]): number {\r\n    const costs: { [key: string]: number } = {\r\n      [MOVE]: 50,\r\n      [WORK]: 100,\r\n      [CARRY]: 50,\r\n      [ATTACK]: 80,\r\n      [RANGED_ATTACK]: 150,\r\n      [HEAL]: 250,\r\n      [TOUGH]: 10,\r\n      [CLAIM]: 600\r\n    };\r\n\r\n    return body.reduce((sum, part) => sum + (costs[part] || 0), 0);\r\n  }\r\n\r\n  private spawnCreep(spawn: StructureSpawn, request: CreepRequest): void {\r\n    const name = `${request.role}_${Game.time}`;\r\n    const result = spawn.spawnCreep(request.body, name, { memory: request.memory });\r\n\r\n    if (result === OK) {\r\n      console.log(`🏛️ Spawning ${request.role}: ${name} (${request.cost} energy)`);\r\n    } else if (result === ERR_NOT_ENOUGH_ENERGY) {\r\n      // This is fine - we'll try again next tick\r\n    } else {\r\n      console.log(`⚠️ Failed to spawn ${request.role}: ${result}`);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * Legatus Fabrum - The Architect\r\n * \r\n * Responsibility: Place construction sites according to room blueprints\r\n * Philosophy: Every room should be a masterpiece of efficiency\r\n * \r\n * The Architect plans and places structures to optimize room layout.\r\n * This is complex logic that will be implemented in future phases.\r\n */\r\nexport class LegatusFabrum {\r\n  private roomName: string;\r\n\r\n  constructor(roomName: string) {\r\n    this.roomName = roomName;\r\n  }\r\n\r\n  /**\r\n   * Analyze room and place construction sites\r\n   * TODO: Implement room planning logic\r\n   */\r\n  public run(): void {\r\n    // STUB: Room planning logic will be implemented later\r\n    // This will include:\r\n    // - Extension placement optimization\r\n    // - Road planning (coordinate with Legatus Viae)\r\n    // - Defense structure placement\r\n    // - Storage and terminal positioning\r\n    \r\n    // Suppress unused variable warning - will be used in future implementation\r\n    void this.roomName;\r\n  }\r\n}\r\n","/**\r\n * Legatus Viae - The Trailblazer\r\n * \r\n * Responsibility: Analyze traffic and build roads\r\n * Philosophy: The shortest path between two points is a Roman road\r\n * \r\n * The Trailblazer monitors creep movement patterns and builds roads\r\n * in high-traffic areas to improve efficiency.\r\n */\r\nexport class LegatusViae {\r\n  private roomName: string;\r\n\r\n  constructor(roomName: string) {\r\n    this.roomName = roomName;\r\n  }\r\n\r\n  /**\r\n   * Analyze traffic patterns and place road construction sites\r\n   * TODO: Implement traffic analysis and road planning\r\n   */\r\n  public run(): void {\r\n    // STUB: Traffic analysis logic will be implemented later\r\n    // This will include:\r\n    // - Tracking creep movement patterns\r\n    // - Identifying high-traffic positions\r\n    // - Placing road construction sites\r\n    // - Optimizing paths between key structures\r\n    \r\n    // Suppress unused variable warning - will be used in future implementation\r\n    void this.roomName;\r\n  }\r\n}\r\n","/**\r\n * Task execution status enumeration\r\n * Represents the outcome of a task execution attempt\r\n */\r\nexport enum TaskStatus {\r\n  /** Task is currently being executed */\r\n  IN_PROGRESS = 'IN_PROGRESS',\r\n  /** Task has been completed successfully */\r\n  COMPLETED = 'COMPLETED',\r\n  /** Task execution failed */\r\n  FAILED = 'FAILED',\r\n  /** Task cannot be executed (e.g., target unreachable) */\r\n  BLOCKED = 'BLOCKED'\r\n}\r\n\r\n/**\r\n * Result of a single task execution\r\n * Returned by TaskExecutor.execute() to indicate what happened\r\n */\r\nexport interface TaskResult {\r\n  /** Current status of the task */\r\n  status: TaskStatus;\r\n  /** Optional message describing the status (e.g., error details) */\r\n  message?: string;\r\n  /** Energy consumed during this execution */\r\n  energyUsed?: number;\r\n  /** Amount of work completed (e.g., energy transferred, building damage) */\r\n  workDone?: number;\r\n}\r\n","import { Task } from '../interfaces';\r\nimport { TaskResult } from './TaskResult';\r\n\r\n/**\r\n * Base class for task execution\r\n * \r\n * Responsibility: Execute specific task types with creeps\r\n * Strategy: Each TaskType has a corresponding executor subclass\r\n * \r\n * This abstract class defines the interface that all task executors must implement,\r\n * providing utility methods for common operations like movement and positioning checks.\r\n */\r\nexport abstract class TaskExecutor {\r\n  /**\r\n   * Execute the given task with the specified creep\r\n   * \r\n   * Each subclass must implement specific execution logic for its TaskType\r\n   * \r\n   * @param creep - The creep performing the task\r\n   * @param task - The task to execute\r\n   * @returns TaskResult indicating the outcome and progress\r\n   */\r\n  abstract execute(creep: Creep, task: Task): TaskResult;\r\n\r\n  /**\r\n   * Check if a creep is at or adjacent to the target position\r\n   * \r\n   * @param creep - The creep to check\r\n   * @param target - The target position or object\r\n   * @returns true if creep is near target, false otherwise\r\n   */\r\n  protected isAtTarget(creep: Creep, target: RoomPosition | RoomObject): boolean {\r\n    return creep.pos.isNearTo(target);\r\n  }\r\n\r\n  /**\r\n   * Move a creep to the target position with standard pathfinding\r\n   * \r\n   * Uses visualized paths and path reuse for efficiency\r\n   * \r\n   * @param creep - The creep to move\r\n   * @param target - The target position or object\r\n   * @returns Screeps return code (OK, ERR_NO_PATH, etc.)\r\n   */\r\n  protected moveToTarget(creep: Creep, target: RoomPosition | RoomObject): ScreepsReturnCode {\r\n    return creep.moveTo(target, {\r\n      visualizePathStyle: { stroke: '#ffffff' },\r\n      reusePath: 10\r\n    });\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * HarvestExecutor - Execute HARVEST_ENERGY tasks\r\n * \r\n * Creeps move to energy sources and harvest energy\r\n * Returns COMPLETED when creep is full or source is empty\r\n */\r\nexport class HarvestExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Validate task has a target source\r\n    if (!task.targetId) {\r\n      return { status: TaskStatus.FAILED, message: 'No harvest target specified' };\r\n    }\r\n\r\n    // Get the source\r\n    const source = Game.getObjectById(task.targetId as Id<Source>);\r\n    if (!source) {\r\n      return { status: TaskStatus.FAILED, message: 'Source not found' };\r\n    }\r\n\r\n    // Check if creep is full\r\n    if (creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'Creep full',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if source is depleted\r\n    if (source.energy === 0) {\r\n      return { \r\n        status: TaskStatus.BLOCKED, \r\n        message: 'Source empty',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if already adjacent to source\r\n    if (!this.isAtTarget(creep, source)) {\r\n      // Move towards source\r\n      const moveResult = this.moveToTarget(creep, source);\r\n      if (moveResult === OK) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Moving to source',\r\n          workDone: 0\r\n        };\r\n      } else {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n    }\r\n\r\n    // Adjacent to source - perform harvest\r\n    const harvestResult = creep.harvest(source);\r\n    if (harvestResult === OK) {\r\n      const workParts = creep.getActiveBodyparts(WORK);\r\n      const energyHarvested = Math.min(source.energy, workParts * HARVEST_POWER);\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Harvesting',\r\n        workDone: energyHarvested\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Harvest failed: ${harvestResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * TransferExecutor - Execute energy transfer tasks\r\n * \r\n * Handles: REFILL_SPAWN, REFILL_EXTENSION, REFILL_TOWER tasks\r\n * Creeps move to target structure and transfer energy\r\n * Returns COMPLETED when creep is empty or structure is full\r\n */\r\nexport class TransferExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Validate task has a target\r\n    if (!task.targetId) {\r\n      return { status: TaskStatus.FAILED, message: 'No transfer target specified' };\r\n    }\r\n\r\n    // Get the target structure\r\n    const target = Game.getObjectById(task.targetId as Id<Structure>);\r\n    if (!target) {\r\n      return { status: TaskStatus.FAILED, message: 'Target structure not found' };\r\n    }\r\n\r\n    // Validate target can store energy\r\n    const storableTarget = target as AnyStoreStructure;\r\n    if (!storableTarget.store) {\r\n      return { status: TaskStatus.FAILED, message: 'Target cannot store energy' };\r\n    }\r\n\r\n    // Check if creep is empty\r\n    if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'Creep empty',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if target is full\r\n    if (storableTarget.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'Target full',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if adjacent to target\r\n    if (!this.isAtTarget(creep, target)) {\r\n      // Move towards target\r\n      const moveResult = this.moveToTarget(creep, target);\r\n      if (moveResult === OK) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Moving to target',\r\n          workDone: 0\r\n        };\r\n      } else {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n    }\r\n\r\n    // Adjacent to target - perform transfer\r\n    const transferResult = creep.transfer(storableTarget, RESOURCE_ENERGY);\r\n    if (transferResult === OK) {\r\n      const energyTransferred = Math.min(\r\n        creep.store.getUsedCapacity(RESOURCE_ENERGY),\r\n        storableTarget.store.getFreeCapacity(RESOURCE_ENERGY)\r\n      );\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Transferring',\r\n        workDone: energyTransferred\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Transfer failed: ${transferResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * UpgradeExecutor - Execute UPGRADE_CONTROLLER tasks\r\n * \r\n * Creeps move to the room controller and upgrade it\r\n * Returns COMPLETED when creep is empty of energy\r\n */\r\nexport class UpgradeExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, _task: Task): TaskResult {\r\n    // Get the controller\r\n    const controller = creep.room.controller;\r\n    if (!controller) {\r\n      return { status: TaskStatus.FAILED, message: 'No controller in room' };\r\n    }\r\n\r\n    const energyAmount = creep.store.getUsedCapacity(RESOURCE_ENERGY);\r\n    const distance = creep.pos.getRangeTo(controller);\r\n    \r\n    // Debug logging\r\n    console.log(`🔧 ${creep.name}: Energy=${energyAmount}, Distance=${distance}, Pos=${creep.pos}`);\r\n\r\n    // Check if creep is out of energy\r\n    if (energyAmount === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'No energy',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if in range of controller (3 squares)\r\n    if (!creep.pos.inRangeTo(controller, 3)) {\r\n      // Move towards controller\r\n      console.log(`🚶 ${creep.name}: Moving to controller at ${controller.pos}`);\r\n      const moveResult = this.moveToTarget(creep, controller);\r\n      console.log(`📍 ${creep.name}: moveTo result = ${moveResult}`);\r\n      \r\n      if (moveResult === OK || moveResult === ERR_TIRED) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: `Moving to controller (${moveResult})`,\r\n          workDone: 0\r\n        };\r\n      } else {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n    }\r\n\r\n    // In range - perform upgrade\r\n    const upgradeResult = creep.upgradeController(controller);\r\n    if (upgradeResult === OK) {\r\n      const workParts = creep.getActiveBodyparts(WORK);\r\n      const workDone = workParts * UPGRADE_CONTROLLER_POWER;\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Upgrading',\r\n        workDone: workDone\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Upgrade failed: ${upgradeResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * BuildExecutor - Execute BUILD tasks\r\n * \r\n * Creeps move to construction sites and build structures\r\n * Returns COMPLETED when construction site is finished or creep is empty\r\n */\r\nexport class BuildExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Validate task has a target construction site\r\n    if (!task.targetId) {\r\n      return { status: TaskStatus.FAILED, message: 'No construction site specified' };\r\n    }\r\n\r\n    // Get the construction site\r\n    const site = Game.getObjectById(task.targetId as Id<ConstructionSite>);\r\n    if (!site) {\r\n      return { status: TaskStatus.FAILED, message: 'Construction site not found' };\r\n    }\r\n\r\n    // Check if creep is out of energy\r\n    if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'No energy',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if adjacent to construction site\r\n    if (!this.isAtTarget(creep, site)) {\r\n      // Move towards site\r\n      const moveResult = this.moveToTarget(creep, site);\r\n      if (moveResult === OK) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Moving to construction site',\r\n          workDone: 0\r\n        };\r\n      } else {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n    }\r\n\r\n    // Adjacent to site - perform build\r\n    const buildResult = creep.build(site);\r\n    if (buildResult === OK) {\r\n      const workParts = creep.getActiveBodyparts(WORK);\r\n      const workDone = workParts * BUILD_POWER;\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Building',\r\n        workDone: workDone\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Build failed: ${buildResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * RepairExecutor - Execute REPAIR tasks\r\n * \r\n * Creeps move to damaged structures and repair them\r\n * Returns COMPLETED when structure is fully repaired or creep is empty\r\n */\r\nexport class RepairExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Validate task has a target structure\r\n    if (!task.targetId) {\r\n      return { status: TaskStatus.FAILED, message: 'No repair target specified' };\r\n    }\r\n\r\n    // Get the structure to repair\r\n    const structure = Game.getObjectById(task.targetId as Id<Structure>);\r\n    if (!structure) {\r\n      return { status: TaskStatus.FAILED, message: 'Target structure not found' };\r\n    }\r\n\r\n    // Check if structure is already fully repaired\r\n    if (structure.hits >= structure.hitsMax) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'Structure repaired',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if creep is out of energy\r\n    if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'No energy',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if adjacent to structure\r\n    if (!this.isAtTarget(creep, structure)) {\r\n      // Move towards structure\r\n      const moveResult = this.moveToTarget(creep, structure);\r\n      if (moveResult === OK) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Moving to repair target',\r\n          workDone: 0\r\n        };\r\n      } else {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n    }\r\n\r\n    // Adjacent to structure - perform repair\r\n    const repairResult = creep.repair(structure);\r\n    if (repairResult === OK) {\r\n      const workParts = creep.getActiveBodyparts(WORK);\r\n      const workDone = workParts * REPAIR_POWER;\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Repairing',\r\n        workDone: workDone\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Repair failed: ${repairResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * WithdrawExecutor - Execute WITHDRAW_ENERGY tasks\r\n * \r\n * Creeps move to containers/storage and withdraw energy\r\n * Returns COMPLETED when creep is full or structure is empty\r\n */\r\nexport class WithdrawExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Validate task has a target\r\n    if (!task.targetId) {\r\n      return { status: TaskStatus.FAILED, message: 'No withdraw target specified' };\r\n    }\r\n\r\n    // Get the target structure\r\n    const target = Game.getObjectById(task.targetId as Id<Structure>);\r\n    if (!target) {\r\n      return { status: TaskStatus.FAILED, message: 'Target structure not found' };\r\n    }\r\n\r\n    // Validate target has a store\r\n    const storableTarget = target as AnyStoreStructure;\r\n    if (!storableTarget.store) {\r\n      return { status: TaskStatus.FAILED, message: 'Target has no store' };\r\n    }\r\n\r\n    // Check if creep is full\r\n    if (creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.COMPLETED, \r\n        message: 'Creep full',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if target is empty\r\n    if (storableTarget.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\r\n      return { \r\n        status: TaskStatus.BLOCKED, \r\n        message: 'Target empty',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check if adjacent to target\r\n    if (!this.isAtTarget(creep, target)) {\r\n      // Move towards target\r\n      const moveResult = this.moveToTarget(creep, target);\r\n      if (moveResult === OK) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Moving to target',\r\n          workDone: 0\r\n        };\r\n      } else {\r\n        return { \r\n          status: TaskStatus.FAILED, \r\n          message: `Failed to move: ${moveResult}`,\r\n          workDone: 0\r\n        };\r\n      }\r\n    }\r\n\r\n    // Adjacent to target - perform withdraw\r\n    const withdrawResult = creep.withdraw(storableTarget, RESOURCE_ENERGY);\r\n    if (withdrawResult === OK) {\r\n      const energyWithdrawn = Math.min(\r\n        creep.store.getFreeCapacity(RESOURCE_ENERGY),\r\n        storableTarget.store.getUsedCapacity(RESOURCE_ENERGY)\r\n      );\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Withdrawing',\r\n        workDone: energyWithdrawn\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Withdraw failed: ${withdrawResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * DefendExecutor - Execute DEFEND_ROOM tasks\r\n * \r\n * Creeps move to hostile creeps and attack them\r\n * Uses melee attack if available, otherwise ranged attack\r\n * Returns COMPLETED when no hostiles remain\r\n */\r\nexport class DefendExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, task: Task): TaskResult {\r\n    // Get target hostile\r\n    let hostile: Creep | null = null;\r\n\r\n    if (task.targetId) {\r\n      // If specific target is assigned, try to use it\r\n      hostile = Game.getObjectById(task.targetId as Id<Creep>);\r\n    }\r\n\r\n    // If no target or target is gone, find nearest hostile\r\n    if (!hostile) {\r\n      const hostiles = creep.room.find(FIND_HOSTILE_CREEPS);\r\n      if (hostiles.length === 0) {\r\n        return { \r\n          status: TaskStatus.COMPLETED, \r\n          message: 'No hostiles',\r\n          workDone: 0\r\n        };\r\n      }\r\n      // Target nearest hostile\r\n      hostile = creep.pos.findClosestByPath(hostiles);\r\n      if (!hostile) {\r\n        hostile = creep.pos.findClosestByRange(hostiles);\r\n      }\r\n    }\r\n\r\n    // Validate we have a hostile to attack\r\n    if (!hostile) {\r\n      return { \r\n        status: TaskStatus.BLOCKED, \r\n        message: 'Hostile unreachable',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Check which attack types we have\r\n    const hasAttack = creep.getActiveBodyparts(ATTACK) > 0;\r\n    const hasRangedAttack = creep.getActiveBodyparts(RANGED_ATTACK) > 0;\r\n\r\n    // If adjacent to hostile, use melee attack\r\n    if (creep.pos.isNearTo(hostile)) {\r\n      if (hasAttack) {\r\n        const attackResult = creep.attack(hostile);\r\n        if (attackResult === OK) {\r\n          return { \r\n            status: TaskStatus.IN_PROGRESS, \r\n            message: 'Attacking',\r\n            workDone: creep.getActiveBodyparts(ATTACK) * ATTACK_POWER\r\n          };\r\n        }\r\n      }\r\n      // Fall through to ranged attack\r\n    }\r\n\r\n    // Use ranged attack or move closer\r\n    if (hasRangedAttack && creep.pos.inRangeTo(hostile, 3)) {\r\n      const rangedResult = creep.rangedAttack(hostile);\r\n      if (rangedResult === OK) {\r\n        return { \r\n          status: TaskStatus.IN_PROGRESS, \r\n          message: 'Ranged attacking',\r\n          workDone: creep.getActiveBodyparts(RANGED_ATTACK) * RANGED_ATTACK_POWER\r\n        };\r\n      }\r\n    }\r\n\r\n    // Move towards hostile\r\n    const moveResult = this.moveToTarget(creep, hostile);\r\n    if (moveResult === OK) {\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Moving to hostile',\r\n        workDone: 0\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.FAILED, \r\n        message: `Failed to move: ${moveResult}`,\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","/// <reference types=\"screeps\" />\r\n\r\nimport { TaskExecutor } from '../TaskExecutor';\r\nimport { Task } from '../../interfaces';\r\nimport { TaskResult, TaskStatus } from '../TaskResult';\r\n\r\n/**\r\n * IdleExecutor - Execute IDLE tasks\r\n * \r\n * Default fallback executor for creeps without assigned tasks\r\n * Moves to a safe parking position near the controller\r\n * Returns IN_PROGRESS indefinitely until reassigned\r\n */\r\nexport class IdleExecutor extends TaskExecutor {\r\n  public execute(creep: Creep, _task: Task): TaskResult {\r\n    // Get the controller as a safe parking position\r\n    const controller = creep.room.controller;\r\n    if (!controller) {\r\n      // No controller - just stay put\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Idling (no controller)',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // If already in parking area (adjacent to controller), stay put\r\n    if (creep.pos.inRangeTo(controller, 3)) {\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Parked',\r\n        workDone: 0\r\n      };\r\n    }\r\n\r\n    // Move to parking position\r\n    const moveResult = this.moveToTarget(creep, controller);\r\n    if (moveResult === OK) {\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Moving to parking',\r\n        workDone: 0\r\n      };\r\n    } else if (moveResult === ERR_NO_PATH) {\r\n      // Can't reach parking - stay put\r\n      return { \r\n        status: TaskStatus.BLOCKED, \r\n        message: 'Parking unreachable',\r\n        workDone: 0\r\n      };\r\n    } else {\r\n      return { \r\n        status: TaskStatus.IN_PROGRESS, \r\n        message: 'Idling',\r\n        workDone: 0\r\n      };\r\n    }\r\n  }\r\n}\r\n","import { TaskType } from '../interfaces';\r\nimport { TaskExecutor } from './TaskExecutor';\r\nimport { HarvestExecutor } from './executors/HarvestExecutor';\r\nimport { TransferExecutor } from './executors/TransferExecutor';\r\nimport { UpgradeExecutor } from './executors/UpgradeExecutor';\r\nimport { BuildExecutor } from './executors/BuildExecutor';\r\nimport { RepairExecutor } from './executors/RepairExecutor';\r\nimport { WithdrawExecutor } from './executors/WithdrawExecutor';\r\nimport { DefendExecutor } from './executors/DefendExecutor';\r\nimport { IdleExecutor } from './executors/IdleExecutor';\r\n\r\n/**\r\n * Factory for task executors\r\n * \r\n * Responsibility: Provide the correct TaskExecutor for any given TaskType\r\n * Strategy: Registry pattern - executors register themselves by task type\r\n * \r\n * This factory maintains a registry of TaskExecutor instances, one per TaskType.\r\n * Specific executors are registered as they are implemented (Phase IV-B, Phase IV-C, etc.)\r\n */\r\nexport class ExecutorFactory {\r\n  /** Registry mapping task types to their executors */\r\n  private static executors: Map<TaskType, TaskExecutor> = new Map();\r\n\r\n  /**\r\n   * Get the executor responsible for a specific task type\r\n   * \r\n   * Initializes executor registry on first use\r\n   * \r\n   * @param taskType - The type of task to get an executor for\r\n   * @returns TaskExecutor instance or null if not yet implemented\r\n   */\r\n  public static getExecutor(taskType: TaskType): TaskExecutor | null {\r\n    // Initialize executors on first use\r\n    if (this.executors.size === 0) {\r\n      this.initializeExecutors();\r\n    }\r\n\r\n    return this.executors.get(taskType) || null;\r\n  }\r\n\r\n  /**\r\n   * Register an executor for a task type\r\n   * \r\n   * Called during executor initialization phases to populate the registry\r\n   * Multiple registrations for the same TaskType will replace the previous executor\r\n   * \r\n   * @param taskType - The task type this executor handles\r\n   * @param executor - The executor instance\r\n   */\r\n  public static registerExecutor(taskType: TaskType, executor: TaskExecutor): void {\r\n    this.executors.set(taskType, executor);\r\n  }\r\n\r\n  /**\r\n   * Initialize the executor registry\r\n   * \r\n   * This is called on first getExecutor() call\r\n   * Specific executors will be registered as they are created in subsequent phases:\r\n   * - Phase IV-B: Agent Secundus creates Harvest, Transfer, Upgrade executors\r\n   * - Phase IV-C: Additional executor implementations\r\n   */\r\n  private static initializeExecutors(): void {\r\n    // Create executor instances\r\n    const harvestExecutor = new HarvestExecutor();\r\n    const transferExecutor = new TransferExecutor();\r\n    const upgradeExecutor = new UpgradeExecutor();\r\n    const buildExecutor = new BuildExecutor();\r\n    const repairExecutor = new RepairExecutor();\r\n    const withdrawExecutor = new WithdrawExecutor();\r\n    const defendExecutor = new DefendExecutor();\r\n    const idleExecutor = new IdleExecutor();\r\n\r\n    // Register energy management executors\r\n    this.registerExecutor(TaskType.HARVEST_ENERGY, harvestExecutor);\r\n    this.registerExecutor(TaskType.WITHDRAW_ENERGY, withdrawExecutor);\r\n    this.registerExecutor(TaskType.HAUL_ENERGY, transferExecutor); // Same logic as transfer\r\n\r\n    // Register construction & repair executors\r\n    this.registerExecutor(TaskType.BUILD, buildExecutor);\r\n    this.registerExecutor(TaskType.REPAIR, repairExecutor);\r\n\r\n    // Register controller operations\r\n    this.registerExecutor(TaskType.UPGRADE_CONTROLLER, upgradeExecutor);\r\n\r\n    // Register logistics executors (all use transfer logic)\r\n    this.registerExecutor(TaskType.REFILL_SPAWN, transferExecutor);\r\n    this.registerExecutor(TaskType.REFILL_EXTENSION, transferExecutor);\r\n    this.registerExecutor(TaskType.REFILL_TOWER, transferExecutor);\r\n\r\n    // Register defense executor\r\n    this.registerExecutor(TaskType.DEFEND_ROOM, defendExecutor);\r\n    this.registerExecutor(TaskType.TOWER_DEFENSE, defendExecutor);\r\n\r\n    // Register special operations\r\n    this.registerExecutor(TaskType.CLAIM_CONTROLLER, upgradeExecutor); // Temporary - will be updated\r\n    this.registerExecutor(TaskType.RESERVE_CONTROLLER, upgradeExecutor); // Temporary - will be updated\r\n    this.registerExecutor(TaskType.SCOUT_ROOM, idleExecutor); // Temporary - will be updated\r\n\r\n    // Register default idle\r\n    this.registerExecutor(TaskType.IDLE, idleExecutor);\r\n\r\n    console.log(`✅ ExecutorFactory initialized with ${this.executors.size} executors`);\r\n  }\r\n\r\n  /**\r\n   * Get count of registered executors (useful for debugging)\r\n   */\r\n  public static getExecutorCount(): number {\r\n    return this.executors.size;\r\n  }\r\n\r\n  /**\r\n   * Get list of registered task types (useful for debugging)\r\n   */\r\n  public static getRegisteredTaskTypes(): TaskType[] {\r\n    return Array.from(this.executors.keys());\r\n  }\r\n}\r\n","import { Task } from '../interfaces';\r\nimport { ExecutorFactory, TaskStatus, TaskResult } from '../execution';\r\n\r\n/**\r\n * Legatus Legionum - The Legion Commander\r\n * \r\n * Responsibility: Execute tasks assigned to creeps\r\n * Philosophy: Every creep is a soldier executing orders\r\n * \r\n * The Legion Commander ensures each creep executes its assigned task.\r\n * It coordinates with ExecutorFactory to delegate task execution to \r\n * specialized executors, then handles the results (completion, failure, etc.)\r\n */\r\nexport class LegatusLegionum {\r\n  private roomName: string;\r\n\r\n  constructor(roomName: string) {\r\n    this.roomName = roomName;\r\n  }\r\n\r\n  /**\r\n   * Execute tasks for all creeps in the room\r\n   * \r\n   * For each creep:\r\n   * 1. Check if it has an assigned task\r\n   * 2. If no task, try to assign one from available tasks\r\n   * 3. If it has a task, execute it using the appropriate executor\r\n   * 4. Handle the result (mark complete, reassign, etc.)\r\n   */\r\n  public run(tasks: Task[]): void {\r\n    const room = Game.rooms[this.roomName];\r\n    if (!room) return;\r\n\r\n    const creeps = room.find(FIND_MY_CREEPS);\r\n    \r\n    creeps.forEach(creep => {\r\n      this.executeCreepTask(creep, tasks);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute the assigned task for a specific creep\r\n   * \r\n   * @param creep - The creep to execute a task for\r\n   * @param tasks - Available tasks in the room\r\n   */\r\n  private executeCreepTask(creep: Creep, tasks: Task[]): void {\r\n    // Get creep's assigned task\r\n    const taskId = creep.memory.task;\r\n    \r\n    if (!taskId) {\r\n      // Creep has no task - assign one\r\n      this.assignTask(creep, tasks);\r\n      return;\r\n    }\r\n    \r\n    const task = tasks.find(t => t.id === taskId);\r\n    \r\n    if (!task) {\r\n      // Task no longer exists - clear and reassign\r\n      console.log(`⚠️ ${creep.name}: Task ${taskId} not found, reassigning`);\r\n      creep.memory.task = undefined;\r\n      this.assignTask(creep, tasks);\r\n      return;\r\n    }\r\n    \r\n    // Get executor for this task type\r\n    const executor = ExecutorFactory.getExecutor(task.type);\r\n    if (!executor) {\r\n      console.log(`⚠️ ${creep.name}: No executor for task type ${task.type}`);\r\n      return;\r\n    }\r\n    \r\n    // Execute the task\r\n    console.log(`⚙️ ${creep.name}: Executing ${task.type} (${task.id})`);\r\n    const result = executor.execute(creep, task);\r\n    console.log(`📊 ${creep.name}: Result = ${result.status}, ${result.message}`);\r\n    \r\n    // Handle result\r\n    this.handleTaskResult(creep, task, result);\r\n  }\r\n\r\n  /**\r\n   * Assign a task to an idle creep\r\n   * \r\n   * Finds the highest priority task that needs more creeps assigned\r\n   * \r\n   * @param creep - The creep to assign a task to\r\n   * @param tasks - Available tasks\r\n   */\r\n  private assignTask(creep: Creep, tasks: Task[]): void {\r\n    // Find highest priority task needing creeps\r\n    const availableTask = tasks.find(t => \r\n      t.assignedCreeps.length < t.creepsNeeded &&\r\n      !t.assignedCreeps.includes(creep.name)\r\n    );\r\n    \r\n    if (availableTask) {\r\n      creep.memory.task = availableTask.id;\r\n      creep.memory.targetId = availableTask.targetId; // Set targetId so Archivist can count us\r\n      availableTask.assignedCreeps.push(creep.name);\r\n      console.log(`📋 ${creep.name} assigned to ${availableTask.type} (target: ${availableTask.targetId})`);\r\n    } else {\r\n      // No tasks available - assign idle task\r\n      creep.memory.task = 'idle';\r\n      creep.memory.targetId = undefined;\r\n      console.log(`💤 ${creep.name} idle - no tasks available`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle the result of a task execution\r\n   * \r\n   * @param creep - The creep that executed the task\r\n   * @param task - The task that was executed\r\n   * @param result - The result of the execution\r\n   */\r\n  private handleTaskResult(creep: Creep, task: Task, result: TaskResult): void {\r\n    if (result.status === TaskStatus.COMPLETED) {\r\n      // Task complete - clear assignment\r\n      creep.memory.task = undefined;\r\n      creep.memory.targetId = undefined;\r\n      const index = task.assignedCreeps.indexOf(creep.name);\r\n      if (index > -1) {\r\n        task.assignedCreeps.splice(index, 1);\r\n      }\r\n      console.log(`✅ ${creep.name} completed ${task.type}`);\r\n    } else if (result.status === TaskStatus.FAILED) {\r\n      // Task failed - log and clear\r\n      console.log(`❌ ${creep.name} failed ${task.type}: ${result.message || 'Unknown error'}`);\r\n      creep.memory.task = undefined;\r\n      creep.memory.targetId = undefined;\r\n      const index = task.assignedCreeps.indexOf(creep.name);\r\n      if (index > -1) {\r\n        task.assignedCreeps.splice(index, 1);\r\n      }\r\n    } else if (result.status === TaskStatus.BLOCKED) {\r\n      // Task blocked - log and clear for reassignment\r\n      console.log(`🚫 ${creep.name} blocked on ${task.type}: ${result.message || 'Task blocked'}`);\r\n      creep.memory.task = undefined;\r\n      const index = task.assignedCreeps.indexOf(creep.name);\r\n      if (index > -1) {\r\n        task.assignedCreeps.splice(index, 1);\r\n      }\r\n    }\r\n    // IN_PROGRESS: Continue normally next tick\r\n  }\r\n}\r\n","import { LegatusArchivus } from '../magistrates/LegatusArchivus';\r\nimport { LegatusOfficio } from '../magistrates/LegatusOfficio';\r\nimport { LegatusGenetor } from '../magistrates/LegatusGenetor';\r\nimport { LegatusFabrum } from '../magistrates/LegatusFabrum';\r\nimport { LegatusViae } from '../magistrates/LegatusViae';\r\nimport { LegatusLegionum } from '../magistrates/LegatusLegionum';\r\n\r\n/**\r\n * Room-specific magistrate instances\r\n */\r\ninterface RoomMagistrates {\r\n  archivist: LegatusArchivus;\r\n  taskmaster: LegatusOfficio;\r\n  broodmother: LegatusGenetor;\r\n  architect: LegatusFabrum;\r\n  trailblazer: LegatusViae;\r\n  legionCommander: LegatusLegionum;\r\n}\r\n\r\n/**\r\n * The Empire - The Principate\r\n * \r\n * The highest authority in Project Imperium. Orchestrates all subordinate systems\r\n * and executes the grand strategy each tick.\r\n * \r\n * Responsibilities:\r\n * - Initialize all Magistrate instances per room\r\n * - Execute the main decision cycle each tick\r\n * - Handle empire-wide state management\r\n * - Maintain the magistrate execution chain\r\n */\r\nexport class Empire {\r\n  private isInitialized: boolean = false;\r\n  private magistratesByRoom: Map<string, RoomMagistrates> = new Map();\r\n\r\n  constructor() {\r\n    console.log('🏛️ The Empire awakens...');\r\n  }\r\n\r\n  /**\r\n   * Main execution function - called every game tick\r\n   */\r\n  public run(): void {\r\n    if (!this.isInitialized) {\r\n      this.initialize();\r\n    }\r\n\r\n    // TODO: This will be expanded after Magistrate classes are built\r\n    this.executeImperialStrategy();\r\n  }\r\n\r\n  private initialize(): void {\r\n    console.log('⚔️ Ave Imperator! Project Imperium initializing...');\r\n    \r\n    // TODO: Initialize Consuls (after they are created)\r\n    // TODO: Initialize Magistrates for each room\r\n    \r\n    this.isInitialized = true;\r\n  }\r\n\r\n  private executeImperialStrategy(): void {\r\n    // High-level empire logic - coordinate all rooms\r\n    // Each room has its own magistrate council\r\n    \r\n    for (const roomName in Game.rooms) {\r\n      const room = Game.rooms[roomName];\r\n      \r\n      // Only manage rooms we control\r\n      if (room.controller && room.controller.my) {\r\n        this.manageColonia(room);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Manage a single colony (room) through its magistrate council\r\n   * Executes the full decision and execution chain\r\n   */\r\n  private manageColonia(room: Room): void {\r\n    // Get or create magistrates for this room\r\n    if (!this.magistratesByRoom.has(room.name)) {\r\n      this.magistratesByRoom.set(room.name, {\r\n        archivist: new LegatusArchivus(room.name),\r\n        taskmaster: new LegatusOfficio(room.name),\r\n        broodmother: new LegatusGenetor(room.name),\r\n        architect: new LegatusFabrum(room.name),\r\n        trailblazer: new LegatusViae(room.name),\r\n        legionCommander: new LegatusLegionum(room.name)\r\n      });\r\n    }\r\n\r\n    const magistrates = this.magistratesByRoom.get(room.name)!;\r\n\r\n    // Initialize room memory for tasks if needed\r\n    if (!room.memory.tasks) {\r\n      room.memory.tasks = [];\r\n    }\r\n\r\n    // Execute the Magistrate chain in order\r\n    // 1. Archivist observes the room state\r\n    const report = magistrates.archivist.run(room);\r\n    console.log(`📊 ${room.name} Report: energyDeficit=${report.energyDeficit}, sources=${report.sources.length}, upgraderShortage=${report.controller.upgraderRecommendation - report.controller.upgraderCount}`);\r\n    \r\n    // Debug source info\r\n    report.sources.forEach((s, i) => {\r\n      console.log(`   Source ${i}: energy=${s.energy}, harvesters=${s.harvestersPresent}/${s.harvestersNeeded}`);\r\n    });\r\n    \r\n    // 2. Taskmaster generates tasks based on the report\r\n    const newTasks = magistrates.taskmaster.run(report);\r\n    console.log(`📋 ${room.name}: Generated ${newTasks.length} tasks`);\r\n    if (newTasks.length > 0) {\r\n      newTasks.forEach(t => console.log(`   - ${t.type} (priority ${t.priority}, needs ${t.creepsNeeded} creeps)`));\r\n    }\r\n    \r\n    // Store tasks in room memory for persistence\r\n    room.memory.tasks = newTasks;\r\n    \r\n    // 3. Broodmother spawns creeps based on tasks\r\n    magistrates.broodmother.run(newTasks);\r\n    \r\n    // 4. Legion Commander executes tasks with existing creeps\r\n    magistrates.legionCommander.run(newTasks);\r\n    \r\n    // 5. Architect handles construction\r\n    magistrates.architect.run();\r\n    \r\n    // 6. Trailblazer handles pathfinding and movement\r\n    magistrates.trailblazer.run();\r\n  }\r\n}\r\n","import { Empire } from './principate/Empire';\r\n\r\n// Initialize the Empire once (persists across ticks via global scope)\r\nconst empire = new Empire();\r\n\r\n// This is the main game loop - called every tick by Screeps\r\nexport const loop = (): void => {\r\n  try {\r\n    // Clear dead creep memory\r\n    for (const name in Memory.creeps) {\r\n      if (!(name in Game.creeps)) {\r\n        delete Memory.creeps[name];\r\n      }\r\n    }\r\n\r\n    // Execute the Empire's master plan\r\n    empire.run();\r\n  } catch (error) {\r\n    console.log(`❌ CRITICAL ERROR in main loop: ${error}`);\r\n    if (error instanceof Error) {\r\n      console.log(`Stack: ${error.stack}`);\r\n    }\r\n  }\r\n};\r\n"],"names":[],"mappings":"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"}