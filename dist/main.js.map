{"version":3,"file":"main.js","sources":["../src/world/spawns/manager.ts","../src/world/creeps/miner.ts","../src/world/creeps/hauler.ts","../src/world/creeps/upgrader.ts","../src/world/creeps/builder.ts","../src/world/creeps/behaviors.ts","../src/world/creeps/spawning.ts","../src/world/creeps/tasks.ts","../src/world/creeps/index.ts","../src/world/visuals.ts","../src/world/structures.ts","../src/world/empire.ts","../src/world/rooms/orchestrator.ts","../src/world/creeps/legatus.ts","../src/world/spawns/bodies.ts","../src/utils/traveler.ts","../src/utils/console.ts","../virtual-build-info","../src/world/stats.ts","../src/main.ts"],"sourcesContent":["/**\r\n * SPAWN MANAGER MODULE\r\n * \r\n * Manages creep spawning strategy and body design for RCL1 foundation.\r\n * \r\n * Spawning Priority (RCL1):\r\n * 1. Minimum 2 miners (critical - economy collapses without them)\r\n * 2. Minimum 2 upgraders (prevent controller downgrade)\r\n * 3. Builders only if construction sites exist (max 2)\r\n * 4. Scale up upgraders if excess energy (max 4)\r\n * \r\n * Body Design Philosophy:\r\n * - Simple [WORK, CARRY, MOVE] repeating pattern\r\n * - Scales automatically with available energy\r\n * - Cost per unit: 200 energy\r\n * - Balanced: 1 WORK (mining/building), 1 CARRY (transport), 1 MOVE (speed)\r\n */\r\n\r\n/**\r\n * Manages spawning for a single spawn structure.\r\n * Evaluates current room state and spawns the highest priority creep.\r\n * \r\n * @param spawn - The spawn structure to manage\r\n * @param room - The room the spawn is in\r\n * @param minerCount - Current number of miner creeps\r\n * @param upgraderCount - Current number of upgrader creeps\r\n * @param builderCount - Current number of builder creeps\r\n * \r\n * @remarks\r\n * This function should be called once per tick per spawn.\r\n * It will only spawn one creep per call (spawn can only spawn one at a time).\r\n * \r\n * @example\r\n * ```typescript\r\n * const spawn = Game.spawns['Spawn1'];\r\n * const room = spawn.room;\r\n * const creeps = room.find(FIND_MY_CREEPS);\r\n * const minerCount = creeps.filter(c => c.memory.role === 'miner').length;\r\n * const upgraderCount = creeps.filter(c => c.memory.role === 'upgrader').length;\r\n * const builderCount = creeps.filter(c => c.memory.role === 'builder').length;\r\n * \r\n * manageSpawn(spawn, room, minerCount, upgraderCount, builderCount);\r\n * ```\r\n */\r\nexport function manageSpawn(\r\n  spawn: StructureSpawn,\r\n  room: Room,\r\n  minerCount: number,\r\n  upgraderCount: number,\r\n  builderCount: number\r\n): void {\r\n  // Don't try to spawn if already spawning\r\n  if (spawn.spawning) return;\r\n\r\n  const energy = room.energyAvailable;\r\n  const constructionSites = room.find(FIND_MY_CONSTRUCTION_SITES);\r\n\r\n  // PRIORITY 1: Emergency - Always maintain minimum miners\r\n  // Without miners, no energy flows and the economy collapses\r\n  if (minerCount < 2) {\r\n    spawnMiner(spawn, room, energy);\r\n    return;\r\n  }\r\n\r\n  // PRIORITY 2: Maintain upgraders to prevent controller downgrade\r\n  // Controller downgrade would reset RCL progress and waste time\r\n  if (upgraderCount < 2) {\r\n    spawnUpgrader(spawn, room, energy);\r\n    return;\r\n  }\r\n\r\n  // PRIORITY 3: Spawn builder if construction sites exist\r\n  // Only spawn builders when there's work for them to do\r\n  if (constructionSites.length > 0 && builderCount < 2) {\r\n    spawnBuilder(spawn, room, energy);\r\n    return;\r\n  }\r\n\r\n  // PRIORITY 4: Expansion - Add more upgraders if we have energy to spare\r\n  // More upgraders = faster RCL progression\r\n  // Only spawn if we have at least 550 energy (can afford decent body)\r\n  if (upgraderCount < 4 && energy >= 550) {\r\n    spawnUpgrader(spawn, room, energy);\r\n    return;\r\n  }\r\n\r\n  // No spawning needed at this time\r\n}\r\n\r\n/**\r\n * Spawns a miner creep with optimal body for available energy.\r\n * \r\n * @param spawn - The spawn structure to use\r\n * @param room - The room to spawn in\r\n * @param energy - Available energy for spawning\r\n */\r\nfunction spawnMiner(spawn: StructureSpawn, room: Room, energy: number): void {\r\n  const body = getBody(energy);\r\n  const result = spawn.spawnCreep(body, `miner_${Game.time}`, {\r\n    memory: { role: 'miner', room: room.name, working: false }\r\n  });\r\n  \r\n  if (result === OK) {\r\n    console.log(`🌾 Spawning miner with ${energy} energy (${body.length} parts)`);\r\n  }\r\n  // Possible errors: ERR_NOT_ENOUGH_ENERGY, ERR_NAME_EXISTS, ERR_BUSY\r\n}\r\n\r\n/**\r\n * Spawns an upgrader creep with optimal body for available energy.\r\n * \r\n * @param spawn - The spawn structure to use\r\n * @param room - The room to spawn in\r\n * @param energy - Available energy for spawning\r\n */\r\nfunction spawnUpgrader(spawn: StructureSpawn, room: Room, energy: number): void {\r\n  const body = getBody(energy);\r\n  const result = spawn.spawnCreep(body, `upgrader_${Game.time}`, {\r\n    memory: { role: 'upgrader', room: room.name, working: false }\r\n  });\r\n  \r\n  if (result === OK) {\r\n    console.log(`⬆️ Spawning upgrader with ${energy} energy (${body.length} parts)`);\r\n  }\r\n}\r\n\r\n/**\r\n * Spawns a builder creep with optimal body for available energy.\r\n * \r\n * @param spawn - The spawn structure to use\r\n * @param room - The room to spawn in\r\n * @param energy - Available energy for spawning\r\n */\r\nfunction spawnBuilder(spawn: StructureSpawn, room: Room, energy: number): void {\r\n  const body = getBody(energy);\r\n  const result = spawn.spawnCreep(body, `builder_${Game.time}`, {\r\n    memory: { role: 'builder', room: room.name, working: false }\r\n  });\r\n  \r\n  if (result === OK) {\r\n    console.log(`🔨 Spawning builder with ${energy} energy (${body.length} parts)`);\r\n  }\r\n}\r\n\r\n/**\r\n * Designs an optimal creep body based on available energy.\r\n * \r\n * Pattern: [WORK, CARRY, MOVE] repeating\r\n * - WORK: 100 energy (harvests 2 energy/tick, builds 5 progress/tick)\r\n * - CARRY: 50 energy (holds 50 energy)\r\n * - MOVE: 50 energy (moves 1 tile/tick on roads, 1 tile/2 ticks on plain)\r\n * \r\n * Cost per unit: 200 energy\r\n * \r\n * Examples:\r\n * - 300 energy → [W, C, M] (minimum viable)\r\n * - 550 energy → [W, C, M, W, C, M] (2 units)\r\n * - 800 energy → [W, C, M, W, C, M, W, C, M] (3 units)\r\n * \r\n * @param energy - Available energy for body design\r\n * @returns Array of body part constants\r\n * \r\n * @remarks\r\n * Max body size is 50 parts (hard limit in Screeps).\r\n * This function caps at 12 parts (4 units) to keep CPU cost reasonable.\r\n * \r\n * The [W,C,M] pattern ensures:\r\n * - Balanced performance (work + carry + mobility)\r\n * - No bottlenecks (can work and carry simultaneously)\r\n * - Efficient movement (1 MOVE per 2 parts)\r\n */\r\nexport function getBody(energy: number): BodyPartConstant[] {\r\n  const body: BodyPartConstant[] = [];\r\n  \r\n  // Start with basic unit cost\r\n  const unitCost = 200; // WORK (100) + CARRY (50) + MOVE (50)\r\n  let remainingEnergy = energy;\r\n\r\n  // Add [W, C, M] units until we run out of energy or hit size limit\r\n  // Cap at 12 parts (4 units) to keep CPU cost reasonable for RCL1\r\n  while (remainingEnergy >= unitCost && body.length < 12) {\r\n    body.push(WORK, CARRY, MOVE);\r\n    remainingEnergy -= unitCost;\r\n  }\r\n\r\n  // Minimum viable creep: At least one [W, C, M] unit\r\n  // This ensures the creep can actually perform its job\r\n  if (body.length === 0) {\r\n    body.push(WORK, CARRY, MOVE); // Force at least one unit (200 energy)\r\n  }\r\n\r\n  return body;\r\n}\r\n\r\n/**\r\n * Gets a human-readable summary of spawn status.\r\n * Useful for debugging and console output.\r\n * \r\n * @param spawn - The spawn to get status for\r\n * @returns Status string\r\n * \r\n * @example\r\n * ```typescript\r\n * const status = getSpawnStatus(Game.spawns['Spawn1']);\r\n * console.log(status); // \"Spawning harvester_12345 (50% complete)\"\r\n * ```\r\n */\r\nexport function getSpawnStatus(spawn: StructureSpawn): string {\r\n  if (spawn.spawning) {\r\n    const progress = Math.round((1 - spawn.spawning.remainingTime / spawn.spawning.needTime) * 100);\r\n    return `Spawning ${spawn.spawning.name} (${progress}% complete)`;\r\n  }\r\n  return 'Idle';\r\n}\r\n","/**\r\n * MINER BEHAVIOR MODULE\r\n * \r\n * The miner is the backbone of your economy in Screeps.\r\n * It gathers energy from sources and delivers it to spawn/extensions.\r\n * \r\n * RCL1 Strategy:\r\n * - Mine from the nearest active source\r\n * - Deliver energy to spawn first (ensures spawning never stops)\r\n * - If spawn is full, deliver to extensions (RCL2+)\r\n * - If all structures are full, help upgrade the controller\r\n * \r\n * State Machine:\r\n * - working: false → Creep is empty, needs to mine\r\n * - working: true → Creep is full, needs to deliver energy\r\n */\r\n\r\n/**\r\n * Main behavior function for miner role.\r\n * Called once per game tick for each miner creep.\r\n * \r\n * @param creep - The creep to run miner behavior on\r\n * \r\n * @example\r\n * ```typescript\r\n * const miner = Game.creeps['miner_12345'];\r\n * runMiner(miner);\r\n * ```\r\n */\r\nexport function runMiner(creep: Creep): void {\r\n  // State machine: Switch between mining and delivering\r\n  // When completely full, switch to \"working\" (delivering) mode\r\n  if (creep.store.getFreeCapacity() === 0) {\r\n    creep.memory.working = true;\r\n  }\r\n  // When completely empty, switch to mining mode\r\n  if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\r\n    creep.memory.working = false;\r\n  }\r\n\r\n  if (!creep.memory.working) {\r\n    // MINING MODE: Get energy from source\r\n    mineEnergy(creep);\r\n  } else {\r\n    // DELIVERING MODE: Deliver energy to structures\r\n    deliverEnergy(creep);\r\n  }\r\n}\r\n\r\n/**\r\n * Mines energy from a source.\r\n * \r\n * Supports both task-assigned and mobile mining:\r\n * - If creep has no CARRY parts (stationary miner): \r\n *   Will automatically stay at assigned/nearest source\r\n * - If creep has CARRY parts (mobile miner):\r\n *   Can be assigned to specific source or roams freely\r\n * \r\n * Flow:\r\n * 1. Check if creep has a task assignment (e.g., 'harvest' from 'SourceB')\r\n * 2. If assigned, travel to and mine from that specific source\r\n * 3. If not assigned, find nearest active source (mobile behavior)\r\n * 4. Mine when in range, travel when not\r\n * \r\n * @param creep - The creep that should mine\r\n * \r\n * @remarks\r\n * Creeps without CARRY parts naturally stay put since they can't\r\n * move energy anyway. Creeps with CARRY parts can be assigned to\r\n * specific sources or left to roam.\r\n */\r\nfunction mineEnergy(creep: Creep): void {\r\n  let source: Source | null = null;\r\n\r\n  // Check if creep has a harvest task with a target source\r\n  if (creep.memory.task && creep.memory.task.type === 'harvest') {\r\n    const targetName = creep.memory.task.targetId;\r\n    if (targetName) {\r\n      // Convert target name (e.g., 'SourceB') to source object\r\n      // SourceA = index 0, SourceB = index 1, etc.\r\n      const sourceIndex = targetName.charCodeAt(targetName.length - 1) - 'A'.charCodeAt(0);\r\n      const sources = creep.room.find(FIND_SOURCES);\r\n      if (sources[sourceIndex]) {\r\n        source = sources[sourceIndex];\r\n      }\r\n    }\r\n  }\r\n\r\n  // If no assigned source, find nearest active source (mobile behavior)\r\n  if (!source) {\r\n    source = creep.pos.findClosestByPath(FIND_SOURCES_ACTIVE);\r\n  }\r\n\r\n  if (source) {\r\n    // Try to mine. Returns OK if successful, or an error code\r\n    const result = creep.harvest(source);\r\n    \r\n    if (result === ERR_NOT_IN_RANGE) {\r\n      // Too far away, move closer\r\n      creep.travelTo(source);\r\n    }\r\n    // Other possible errors (ERR_NOT_ENOUGH_RESOURCES, ERR_BUSY, etc.)\r\n    // are handled automatically by the game engine\r\n  }\r\n}\r\n\r\n/**\r\n * Delivers energy to spawn, extensions, or controller.\r\n * \r\n * Priority system:\r\n * 1. Spawn first (critical - enables spawning new creeps)\r\n * 2. Extensions next (RCL2+, increases spawn capacity)\r\n * 3. Controller if all structures are full (don't waste time)\r\n * \r\n * @param creep - The creep that should deliver energy\r\n * \r\n * @remarks\r\n * This ensures your spawn never runs out of energy, which would\r\n * halt creep production and potentially collapse your economy.\r\n */\r\nfunction deliverEnergy(creep: Creep): void {\r\n  // Find all spawn and extension structures that need energy\r\n  const targets = creep.room.find(FIND_MY_STRUCTURES, {\r\n    filter: (structure) => {\r\n      return (\r\n        (structure.structureType === STRUCTURE_SPAWN ||\r\n         structure.structureType === STRUCTURE_EXTENSION) &&\r\n        structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0\r\n      );\r\n    }\r\n  });\r\n\r\n  if (targets.length > 0) {\r\n    // Priority: Spawn first, then closest extension\r\n    const spawn = targets.find(t => t.structureType === STRUCTURE_SPAWN);\r\n    const target = spawn || targets[0];\r\n    \r\n    const result = creep.transfer(target, RESOURCE_ENERGY);\r\n    \r\n    if (result === ERR_NOT_IN_RANGE) {\r\n      creep.travelTo(target);\r\n    }\r\n  } else {\r\n    // All spawn/extensions full, help with upgrading\r\n    // This prevents wasting miner time when storage is full\r\n    upgradeControllerFallback(creep);\r\n  }\r\n}\r\n\r\n/**\r\n * Fallback behavior: Upgrade controller when no delivery targets.\r\n * \r\n * This prevents miners from idling when spawn and extensions\r\n * are full. Instead, they contribute to controller progress.\r\n * \r\n * @param creep - The creep that should upgrade\r\n */\r\nfunction upgradeControllerFallback(creep: Creep): void {\r\n  const controller = creep.room.controller;\r\n  \r\n  if (controller) {\r\n    const result = creep.upgradeController(controller);\r\n    \r\n    if (result === ERR_NOT_IN_RANGE) {\r\n      creep.travelTo(controller);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * HAULER BEHAVIOR\r\n * \r\n * Dedicated transport creep focused on energy movement.\r\n * Haulers can be task-assigned to specific structures or sources.\r\n * \r\n * Strategy:\r\n * - If assigned to a source: Pick up from nearby dropped energy/containers, haul to spawn/extensions, idle at source\r\n * - If assigned to a structure: Pick up from that structure and haul to spawn/extensions\r\n * - If not assigned: Generic hauler that picks up from anywhere and delivers\r\n * \r\n * Best for: Rooms with complex energy flows (multiple sources, distant structures)\r\n */\r\n\r\n/**\r\n * Main behavior for hauler role.\r\n * Respects task assignments to specific structures or sources.\r\n * \r\n * @param creep - The creep to run hauler behavior on\r\n */\r\nexport function runHauler(creep: Creep): void {\r\n  // Get assignment target if available\r\n  let targetStructure: RoomObject | null = null;\r\n  let isSourceAssignment = false;\r\n\r\n  if (creep.memory.task && creep.memory.task.targetId) {\r\n    const targetName = creep.memory.task.targetId;\r\n    \r\n    // Try to interpret as source (SourceA, SourceB, etc.)\r\n    if (targetName.startsWith('Source')) {\r\n      const sourceIndex = targetName.charCodeAt(targetName.length - 1) - 'A'.charCodeAt(0);\r\n      const sources = creep.room.find(FIND_SOURCES);\r\n      if (sources[sourceIndex]) {\r\n        targetStructure = sources[sourceIndex];\r\n        isSourceAssignment = true;\r\n      }\r\n    } else {\r\n      // Try to find as named structure (SpawnA, StorageA, ContainerA, etc.)\r\n      const allStructures = creep.room.find(FIND_MY_STRUCTURES);\r\n      targetStructure = allStructures.find(s => {\r\n        return s.pos.x > 0; // placeholder - in reality you'd need better naming\r\n      }) || null;\r\n\r\n      // Fallback: If target looks like \"ContainerX\", find containers\r\n      if (!targetStructure && targetName.startsWith('Container')) {\r\n        const containers = creep.room.find(FIND_STRUCTURES, {\r\n          filter: (s) => s.structureType === STRUCTURE_CONTAINER\r\n        });\r\n        targetStructure = containers[0] || null;\r\n      }\r\n    }\r\n  }\r\n\r\n  // State machine: Switch between picking up and delivering\r\n  if (creep.store.getFreeCapacity() === 0) {\r\n    creep.memory.working = true;\r\n  }\r\n  if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\r\n    creep.memory.working = false;\r\n  }\r\n\r\n  if (!creep.memory.working) {\r\n    // PICKUP MODE: Find energy to transport\r\n    if (isSourceAssignment && targetStructure) {\r\n      // Assigned to source: Pick up from surroundings\r\n      pickupFromSource(creep, targetStructure as Source);\r\n    } else if (targetStructure) {\r\n      // Assigned to structure: Pick up from that structure\r\n      pickupFromStructure(creep, targetStructure);\r\n    } else {\r\n      // Generic pickup\r\n      pickupEnergy(creep);\r\n    }\r\n  } else {\r\n    // DELIVERY MODE: Move energy to structures\r\n    deliverEnergy(creep);\r\n  }\r\n}\r\n\r\n/**\r\n * Pick up energy from a source's surroundings.\r\n * \r\n * Priority for sources:\r\n * 1. Dropped energy around the source\r\n * 2. Containers near the source\r\n * 3. Idle at source (wait for more energy)\r\n * \r\n * @param creep - The hauler creep\r\n * @param source - The source structure\r\n */\r\nfunction pickupFromSource(creep: Creep, source: Source): void {\r\n  // Look for dropped energy near the source (within 3 squares)\r\n  const nearbyEnergy = source.pos.findInRange(FIND_DROPPED_RESOURCES, 3, {\r\n    filter: (resource) => resource.resourceType === RESOURCE_ENERGY\r\n  });\r\n\r\n  if (nearbyEnergy.length > 0) {\r\n    const closest = creep.pos.findClosestByPath(nearbyEnergy);\r\n    if (closest) {\r\n      const result = creep.pickup(closest);\r\n      if (result === ERR_NOT_IN_RANGE) {\r\n        creep.travelTo(closest);\r\n      }\r\n      return;\r\n    }\r\n  }\r\n\r\n  // Look for containers near the source\r\n  const nearbyContainers = source.pos.findInRange(FIND_STRUCTURES, 3, {\r\n    filter: (s) => {\r\n      return (\r\n        s.structureType === STRUCTURE_CONTAINER &&\r\n        (s as any).store.getUsedCapacity(RESOURCE_ENERGY) > 0\r\n      );\r\n    }\r\n  });\r\n\r\n  if (nearbyContainers.length > 0) {\r\n    const closest = creep.pos.findClosestByPath(nearbyContainers);\r\n    if (closest) {\r\n      const result = creep.withdraw(closest as any, RESOURCE_ENERGY);\r\n      if (result === ERR_NOT_IN_RANGE) {\r\n        creep.travelTo(closest);\r\n      }\r\n      return;\r\n    }\r\n  }\r\n\r\n  // Nothing found - move to source and idle\r\n  if (!creep.pos.isEqualTo(source.pos)) {\r\n    creep.travelTo(source);\r\n  }\r\n}\r\n\r\n/**\r\n * Pick up energy from a specific structure.\r\n * \r\n * @param creep - The hauler creep\r\n * @param structure - The target structure\r\n */\r\nfunction pickupFromStructure(creep: Creep, structure: RoomObject): void {\r\n  const result = creep.withdraw(structure as any, RESOURCE_ENERGY);\r\n  \r\n  if (result === ERR_NOT_IN_RANGE) {\r\n    creep.travelTo(structure);\r\n  } else if (result === ERR_NOT_ENOUGH_RESOURCES) {\r\n    // Structure is empty, stay nearby and wait\r\n    if (!creep.pos.isEqualTo(structure.pos)) {\r\n      creep.travelTo(structure);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Pick up energy from available sources.\r\n * \r\n * Priority:\r\n * 1. Dropped energy on ground (fastest to pick up)\r\n * 2. Containers (stored energy)\r\n * 3. Idle\r\n * \r\n * @param creep - The hauler creep\r\n */\r\nfunction pickupEnergy(creep: Creep): void {\r\n  // First, look for dropped energy on the ground\r\n  const droppedEnergy = creep.pos.findClosestByPath(FIND_DROPPED_RESOURCES, {\r\n    filter: (resource) => resource.resourceType === RESOURCE_ENERGY\r\n  });\r\n\r\n  if (droppedEnergy) {\r\n    const result = creep.pickup(droppedEnergy);\r\n    if (result === ERR_NOT_IN_RANGE) {\r\n      creep.travelTo(droppedEnergy);\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Look for containers with energy\r\n  const containers = creep.room.find(FIND_STRUCTURES, {\r\n    filter: (structure) => {\r\n      return (\r\n        structure.structureType === STRUCTURE_CONTAINER &&\r\n        (structure as any).store.getUsedCapacity(RESOURCE_ENERGY) > 0\r\n      );\r\n    }\r\n  });\r\n\r\n  if (containers.length > 0) {\r\n    const container = creep.pos.findClosestByPath(containers);\r\n    if (container) {\r\n      const result = creep.withdraw(container as any, RESOURCE_ENERGY);\r\n      if (result === ERR_NOT_IN_RANGE) {\r\n        creep.travelTo(container);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Deliver energy to priority structures.\r\n * \r\n * Priority:\r\n * 1. Spawn (critical for spawning)\r\n * 2. Extensions (capacity for spawning)\r\n * 3. Storage/Containers (long-term storage)\r\n * \r\n * @param creep - The hauler creep\r\n */\r\nfunction deliverEnergy(creep: Creep): void {\r\n  // Find structures that need energy\r\n  const targets = creep.room.find(FIND_MY_STRUCTURES, {\r\n    filter: (structure) => {\r\n      return (\r\n        (structure.structureType === STRUCTURE_SPAWN ||\r\n         structure.structureType === STRUCTURE_EXTENSION) &&\r\n        (structure as any).store.getFreeCapacity(RESOURCE_ENERGY) > 0\r\n      );\r\n    }\r\n  });\r\n\r\n  if (targets.length > 0) {\r\n    // Priority: Spawn first\r\n    let target: any = targets.find(t => t.structureType === STRUCTURE_SPAWN);\r\n    if (!target) {\r\n      target = targets[0];\r\n    }\r\n\r\n    if (target) {\r\n      const result = creep.transfer(target, RESOURCE_ENERGY);\r\n      if (result === ERR_NOT_IN_RANGE) {\r\n        creep.travelTo(target);\r\n      }\r\n    }\r\n  } else {\r\n    // Spawn/extensions full, try storage\r\n    const storage = creep.room.find(FIND_MY_STRUCTURES, {\r\n      filter: (s) => {\r\n        return (\r\n          s.structureType === STRUCTURE_STORAGE &&\r\n          (s as any).store.getFreeCapacity(RESOURCE_ENERGY) > 0\r\n        );\r\n      }\r\n    });\r\n\r\n    if (storage.length > 0) {\r\n      const target = storage[0];\r\n      const result = creep.transfer(target as any, RESOURCE_ENERGY);\r\n      if (result === ERR_NOT_IN_RANGE) {\r\n        creep.travelTo(target);\r\n      }\r\n    }\r\n  }\r\n}\r\n","/**\r\n * UPGRADER BEHAVIOR MODULE\r\n * \r\n * Upgraders maintain and improve your Room Controller Level (RCL).\r\n * They withdraw energy from spawn/extensions and upgrade the controller.\r\n * \r\n * Why upgraders matter:\r\n * - Prevent controller downgrade (critical at low RCL)\r\n * - Unlock new structures and capabilities at each RCL\r\n * - RCL1→2 unlocks extensions (300 energy capacity each)\r\n * - RCL2→3 unlocks towers, walls, ramparts\r\n * \r\n * State Machine:\r\n * - working: false → Creep is empty, needs energy\r\n * - working: true → Creep has energy, should upgrade\r\n */\r\n\r\n/**\r\n * Main behavior function for upgrader role.\r\n * Called once per game tick for each upgrader creep.\r\n * \r\n * @param creep - The creep to run upgrader behavior on\r\n * \r\n * @example\r\n * ```typescript\r\n * const upgrader = Game.creeps['upgrader_12345'];\r\n * runUpgrader(upgrader);\r\n * ```\r\n */\r\nexport function runUpgrader(creep: Creep): void {\r\n  // State machine: Switch between withdrawing and upgrading\r\n  // When empty, switch to withdrawing mode\r\n  if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\r\n    creep.memory.working = false;\r\n  }\r\n  // When full, switch to upgrading mode\r\n  if (creep.store.getFreeCapacity() === 0) {\r\n    creep.memory.working = true;\r\n  }\r\n\r\n  if (!creep.memory.working) {\r\n    // WITHDRAWING MODE: Get energy from spawn/extensions\r\n    withdrawEnergy(creep);\r\n  } else {\r\n    // UPGRADING MODE: Upgrade the controller\r\n    upgradeController(creep);\r\n  }\r\n}\r\n\r\n/**\r\n * Withdraws energy from spawn or extensions.\r\n * \r\n * Strategy:\r\n * 1. Find spawn and extensions with available energy\r\n * 2. Prefer spawn first (leave extensions for spawning if possible)\r\n * 3. If spawn is empty, use closest extension\r\n * 4. Move and withdraw\r\n * \r\n * @param creep - The creep that should withdraw energy\r\n * \r\n * @remarks\r\n * This creates a \"reserve\" strategy where extensions are primarily\r\n * used for spawning, and upgraders take from spawn when possible.\r\n */\r\nfunction withdrawEnergy(creep: Creep): void {\r\n  // Find spawn and extensions with energy available\r\n  const sources = creep.room.find(FIND_MY_STRUCTURES, {\r\n    filter: (structure) => {\r\n      return (\r\n        (structure.structureType === STRUCTURE_SPAWN ||\r\n         structure.structureType === STRUCTURE_EXTENSION) &&\r\n        structure.store.getUsedCapacity(RESOURCE_ENERGY) > 0\r\n      );\r\n    }\r\n  });\r\n\r\n  if (sources.length > 0) {\r\n    // Prefer spawn first (reserve extensions for spawning), then closest\r\n    const spawn = sources.find(s => s.structureType === STRUCTURE_SPAWN);\r\n    const target = spawn || sources[0];\r\n    \r\n    const result = creep.withdraw(target, RESOURCE_ENERGY);\r\n    \r\n    if (result === ERR_NOT_IN_RANGE) {\r\n      creep.travelTo(target);\r\n    }\r\n  }\r\n  // If no sources found, creep will wait until energy is available\r\n}\r\n\r\n/**\r\n * Upgrades the room controller with carried energy.\r\n * \r\n * The controller is the heart of your room:\r\n * - Upgrading increases progress towards next RCL\r\n * - Each upgrade action consumes 1 energy per WORK part\r\n * - Controller downgrades if not upgraded regularly\r\n * \r\n * @param creep - The creep that should upgrade the controller\r\n * \r\n * @remarks\r\n * At RCL1, controller downgrade timer is 20,000 ticks (~6.7 hours).\r\n * At RCL2+, this increases significantly.\r\n */\r\nfunction upgradeController(creep: Creep): void {\r\n  const controller = creep.room.controller;\r\n  \r\n  if (controller) {\r\n    const result = creep.upgradeController(controller);\r\n    \r\n    if (result === ERR_NOT_IN_RANGE) {\r\n      creep.travelTo(controller);\r\n    }\r\n    // Possible errors: ERR_NOT_ENOUGH_RESOURCES (out of energy),\r\n    // ERR_INVALID_TARGET (controller doesn't exist), etc.\r\n  }\r\n}\r\n","/**\r\n * BUILDER BEHAVIOR MODULE\r\n * \r\n * Builders construct structures from construction sites.\r\n * They withdraw energy and build roads, extensions, towers, etc.\r\n * \r\n * RCL1 Strategy:\r\n * - Only spawn builders when construction sites exist\r\n * - Withdraw energy from spawn/extensions\r\n * - Build the nearest construction site\r\n * - If no sites exist, help upgrade controller (don't idle)\r\n * \r\n * Construction priorities (managed externally):\r\n * - Extensions (increase spawn energy capacity)\r\n * - Roads (reduce creep fatigue, increase efficiency)\r\n * - Containers (energy storage near sources)\r\n * \r\n * State Machine:\r\n * - working: false → Creep is empty, needs energy\r\n * - working: true → Creep has energy, should build\r\n */\r\n\r\n/**\r\n * Main behavior function for builder role.\r\n * Called once per game tick for each builder creep.\r\n * \r\n * @param creep - The creep to run builder behavior on\r\n * \r\n * @example\r\n * ```typescript\r\n * const builder = Game.creeps['builder_12345'];\r\n * runBuilder(builder);\r\n * ```\r\n */\r\nexport function runBuilder(creep: Creep): void {\r\n  // State machine: Switch between withdrawing and building\r\n  // When empty, switch to withdrawing mode\r\n  if (creep.store.getUsedCapacity(RESOURCE_ENERGY) === 0) {\r\n    creep.memory.working = false;\r\n  }\r\n  // When full, switch to building mode\r\n  if (creep.store.getFreeCapacity() === 0) {\r\n    creep.memory.working = true;\r\n  }\r\n\r\n  if (!creep.memory.working) {\r\n    // WITHDRAWING MODE: Get energy from spawn/extensions\r\n    withdrawEnergy(creep);\r\n  } else {\r\n    // BUILDING MODE: Build construction sites or upgrade if none exist\r\n    buildOrUpgrade(creep);\r\n  }\r\n}\r\n\r\n/**\r\n * Withdraws energy from spawn or extensions.\r\n * \r\n * Strategy:\r\n * 1. Find spawn and extensions with available energy\r\n * 2. Prefer spawn first (same as upgrader strategy)\r\n * 3. Move and withdraw\r\n * \r\n * @param creep - The creep that should withdraw energy\r\n * \r\n * @remarks\r\n * Builders use the same withdrawal strategy as upgraders to\r\n * minimize competition for extension energy during spawning.\r\n */\r\nfunction withdrawEnergy(creep: Creep): void {\r\n  // Find spawn and extensions with energy available\r\n  const sources = creep.room.find(FIND_MY_STRUCTURES, {\r\n    filter: (structure) => {\r\n      return (\r\n        (structure.structureType === STRUCTURE_SPAWN ||\r\n         structure.structureType === STRUCTURE_EXTENSION) &&\r\n        structure.store.getUsedCapacity(RESOURCE_ENERGY) > 0\r\n      );\r\n    }\r\n  });\r\n\r\n  if (sources.length > 0) {\r\n    // Prefer spawn first, then closest extension\r\n    const spawn = sources.find(s => s.structureType === STRUCTURE_SPAWN);\r\n    const target = spawn || sources[0];\r\n    \r\n    const result = creep.withdraw(target, RESOURCE_ENERGY);\r\n    \r\n    if (result === ERR_NOT_IN_RANGE) {\r\n      creep.travelTo(target);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Builds construction sites or upgrades controller as fallback.\r\n * \r\n * Priority:\r\n * 1. Build nearest construction site\r\n * 2. If no sites, upgrade controller (prevent idling)\r\n * \r\n * @param creep - The creep that should build\r\n * \r\n * @remarks\r\n * Construction sites are created manually or by planning code.\r\n * This function just executes the building, not the planning.\r\n * \r\n * Each build action consumes 5 energy and adds 5 progress to site.\r\n * A creep with multiple WORK parts builds faster (5 progress per WORK).\r\n */\r\nfunction buildOrUpgrade(creep: Creep): void {\r\n  // Find the nearest construction site\r\n  const site = creep.pos.findClosestByPath(FIND_MY_CONSTRUCTION_SITES);\r\n  \r\n  if (site) {\r\n    // Construction site exists, build it\r\n    const result = creep.build(site);\r\n    \r\n    if (result === ERR_NOT_IN_RANGE) {\r\n      creep.travelTo(site);\r\n    }\r\n  } else {\r\n    // No construction sites, help upgrade controller instead\r\n    // This prevents builders from idling when construction is complete\r\n    upgradeControllerFallback(creep);\r\n  }\r\n}\r\n\r\n/**\r\n * Fallback behavior: Upgrade controller when no construction sites.\r\n * \r\n * This prevents builders from idling and wasting CPU when there's\r\n * nothing to build. They contribute to RCL progress instead.\r\n * \r\n * @param creep - The creep that should upgrade\r\n */\r\nfunction upgradeControllerFallback(creep: Creep): void {\r\n  const controller = creep.room.controller;\r\n  \r\n  if (controller) {\r\n    const result = creep.upgradeController(controller);\r\n    \r\n    if (result === ERR_NOT_IN_RANGE) {\r\n      creep.travelTo(controller);\r\n    }\r\n  }\r\n}\r\n","/**\r\n * CREEP BEHAVIOR CONFIGURATION SYSTEM\r\n * \r\n * This module defines creep behaviors for each RCL level.\r\n * Each RCL can have different strategies, spawning priorities, and role distributions.\r\n * \r\n * Architecture:\r\n * - BehaviorConfig: Defines what roles exist at an RCL and their spawn priorities\r\n * - rclBehaviors: Maps RCL level → BehaviorConfig\r\n * - getBehaviorConfig: Gets the active config for a room's current RCL\r\n */\r\n\r\n/**\r\n * Configuration for a creep role\r\n */\r\nexport interface RoleConfig {\r\n  /** Name of the role (harvester, builder, upgrader, etc.) */\r\n  name: string;\r\n  \r\n  /** Priority for spawning (higher = spawn first). Range: 0-100 */\r\n  priority: number;\r\n  \r\n  /** Desired number of this role in the room */\r\n  targetCount: number;\r\n  \r\n  /** Body to spawn this creep with (part array) */\r\n  body: BodyPartConstant[];\r\n  \r\n  /** Optional: Special behavior flags or options */\r\n  options?: Record<string, any>;\r\n}\r\n\r\n/**\r\n * Complete behavior configuration for an RCL level\r\n */\r\nexport interface BehaviorConfig {\r\n  rcl: number;\r\n  name: string;\r\n  description: string;\r\n  roles: RoleConfig[];\r\n}\r\n\r\n/**\r\n * RCL1 Behavior Configuration\r\n * \r\n * At RCL1, we focus on the core economy:\r\n * - Miners: Gather energy from sources\r\n * - Upgraders: Keep controller from downgrading\r\n * - Builders: Build towards extensions for RCL2\r\n * \r\n * Note: No spawning/extensions yet, so minimal infrastructure.\r\n */\r\nexport const rcl1Behavior: BehaviorConfig = {\r\n  rcl: 1,\r\n  name: 'RCL1 Foundation',\r\n  description: 'Core economy: mine, upgrade, build',\r\n  roles: [\r\n    {\r\n      name: 'miner',\r\n      priority: 100,\r\n      targetCount: 2,\r\n      body: [WORK, WORK, CARRY, CARRY, MOVE, MOVE],\r\n      options: { comment: 'Dual work parts for faster mining' }\r\n    },\r\n    {\r\n      name: 'upgrader',\r\n      priority: 90,\r\n      targetCount: 1,\r\n      body: [WORK, CARRY, MOVE],\r\n      options: { comment: 'Keep controller from downgrading' }\r\n    },\r\n    {\r\n      name: 'builder',\r\n      priority: 80,\r\n      targetCount: 1,\r\n      body: [WORK, CARRY, MOVE],\r\n      options: { comment: 'Build extensions for RCL2' }\r\n    }\r\n  ]\r\n};\r\n\r\n/**\r\n * RCL2 Behavior Configuration\r\n * \r\n * At RCL2, we unlock extensions and expand capacity.\r\n * Uses flexible miner bodies and dedicated haulers.\r\n * \r\n * Miner body strategy:\r\n * - With NO CARRY parts (e.g., WORK/WORK/MOVE): Acts as stationary miner\r\n *   Can be assigned to a specific source via task system\r\n *   Mines continuously without moving energy\r\n * - With CARRY parts (e.g., WORK/WORK/CARRY/MOVE): Mobile miner\r\n *   Can roam between sources or be task-assigned\r\n *   Delivers energy to spawn/extensions\r\n */\r\nexport const rcl2Behavior: BehaviorConfig = {\r\n  rcl: 2,\r\n  name: 'RCL2 Expansion',\r\n  description: 'With extensions: flexible miners and specialized support roles',\r\n  roles: [\r\n    {\r\n      name: 'miner',\r\n      priority: 100,\r\n      targetCount: 2,\r\n      body: [WORK, WORK, WORK, CARRY, MOVE, MOVE],\r\n      options: { comment: 'Flexible miner - roams or tasks to specific source' }\r\n    },\r\n    {\r\n      name: 'hauler',\r\n      priority: 90,\r\n      targetCount: 2,\r\n      body: [CARRY, CARRY, CARRY, CARRY, MOVE, MOVE],\r\n      options: { comment: 'Dedicated energy transport specialist' }\r\n    },\r\n    {\r\n      name: 'builder',\r\n      priority: 85,\r\n      targetCount: 2,\r\n      body: [WORK, WORK, CARRY, CARRY, MOVE, MOVE],\r\n      options: { comment: 'Construction specialist' }\r\n    },\r\n    {\r\n      name: 'upgrader',\r\n      priority: 80,\r\n      targetCount: 2,\r\n      body: [WORK, WORK, WORK, CARRY, MOVE],\r\n      options: { comment: 'Fast controller upgrade' }\r\n    }\r\n  ]\r\n};\r\n\r\n/**\r\n * Map of RCL level to behavior configuration\r\n */\r\nconst rclBehaviors: Record<number, BehaviorConfig> = {\r\n  1: rcl1Behavior,\r\n  2: rcl2Behavior\r\n};\r\n\r\n/**\r\n * Get the behavior configuration for a room's current RCL\r\n * \r\n * @param rcl - The room's controller level\r\n * @returns The behavior config for this RCL, or RCL1 as fallback\r\n * \r\n * @example\r\n * ```typescript\r\n * const config = getBehaviorConfig(room.controller!.level);\r\n * const harvesters = config.roles.filter(r => r.name === 'harvester');\r\n * ```\r\n */\r\nexport function getBehaviorConfig(rcl: number): BehaviorConfig {\r\n  return rclBehaviors[rcl] || rclBehaviors[1];\r\n}\r\n\r\n/**\r\n * Get role configuration from the active RCL behavior\r\n * \r\n * @param rcl - The room's controller level\r\n * @param roleName - The role to look up\r\n * @returns The role config, or undefined if not found\r\n */\r\nexport function getRoleConfig(rcl: number, roleName: string): RoleConfig | undefined {\r\n  const config = getBehaviorConfig(rcl);\r\n  return config.roles.find(r => r.name === roleName);\r\n}\r\n\r\n/**\r\n * Get all roles for an RCL, sorted by spawn priority (highest first)\r\n * \r\n * @param rcl - The room's controller level\r\n * @returns Array of roles sorted by priority (descending)\r\n */\r\nexport function getRolesByPriority(rcl: number): RoleConfig[] {\r\n  const config = getBehaviorConfig(rcl);\r\n  return [...config.roles].sort((a, b) => b.priority - a.priority);\r\n}\r\n","/**\r\n * CREEP SPAWNING LOGIC BASED ON BEHAVIOR CONFIG\r\n * \r\n * This module uses the behavior configuration system to:\r\n * - Determine which roles should be spawned\r\n * - Check if we're below target counts\r\n * - Generate appropriate bodies based on config\r\n */\r\n\r\nimport {\r\n  getBehaviorConfig\r\n} from './behaviors';\r\n\r\n/**\r\n * Spawn request with priority and role info\r\n */\r\nexport interface SpawnRequest {\r\n  role: string;\r\n  body: BodyPartConstant[];\r\n  priority: number;\r\n  reason: string;\r\n}\r\n\r\n/**\r\n * Get all roles that need spawning (below target count)\r\n * \r\n * @param room - The room to check\r\n * @returns Array of SpawnRequests sorted by priority (highest first)\r\n * \r\n * @example\r\n * ```typescript\r\n * const requests = getSpawnRequests(room);\r\n * const topPriority = requests[0];\r\n * console.log(`Should spawn ${topPriority.role} (priority ${topPriority.priority})`);\r\n * ```\r\n */\r\nexport function getSpawnRequests(room: Room): SpawnRequest[] {\r\n  const config = getBehaviorConfig(room.controller?.level || 1);\r\n  const requests: SpawnRequest[] = [];\r\n\r\n  // Count current creeps by role\r\n  const creepsByRole = countCreepsByRole(room);\r\n\r\n  // Check each role to see if we need more\r\n  for (const roleConfig of config.roles) {\r\n    const currentCount = creepsByRole[roleConfig.name] || 0;\r\n\r\n    if (currentCount < roleConfig.targetCount) {\r\n      requests.push({\r\n        role: roleConfig.name,\r\n        body: roleConfig.body,\r\n        priority: roleConfig.priority,\r\n        reason: `${roleConfig.name} (${currentCount}/${roleConfig.targetCount})`\r\n      });\r\n    }\r\n  }\r\n\r\n  // Sort by priority (highest first)\r\n  return requests.sort((a, b) => b.priority - a.priority);\r\n}\r\n\r\n/**\r\n * Count creeps in room grouped by role\r\n * \r\n * @param room - The room to count creeps in\r\n * @returns Object with role names as keys and counts as values\r\n */\r\nfunction countCreepsByRole(room: Room): Record<string, number> {\r\n  const counts: Record<string, number> = {};\r\n\r\n  for (const creep of room.find(FIND_MY_CREEPS)) {\r\n    const role = creep.memory.role || 'unknown';\r\n    counts[role] = (counts[role] || 0) + 1;\r\n  }\r\n\r\n  return counts;\r\n}\r\n\r\n/**\r\n * Get a human-readable summary of current vs target creep composition\r\n * \r\n * @param room - The room to analyze\r\n * @returns Formatted status string\r\n * \r\n * @example\r\n * ```\r\n * Harvesters: 2/2 ✓ | Upgraders: 1/1 ✓ | Builders: 0/1 ⚠️\r\n * ```\r\n */\r\nexport function getSpawnStatus(room: Room): string {\r\n  const config = getBehaviorConfig(room.controller?.level || 1);\r\n  const counts = countCreepsByRole(room);\r\n  const parts: string[] = [];\r\n\r\n  for (const roleConfig of config.roles) {\r\n    const current = counts[roleConfig.name] || 0;\r\n    const target = roleConfig.targetCount;\r\n    const status = current >= target ? '✓' : '⚠️';\r\n    parts.push(`${roleConfig.name}: ${current}/${target} ${status}`);\r\n  }\r\n\r\n  return parts.join(' | ');\r\n}\r\n\r\n/**\r\n * Get the next role that should be spawned (if any)\r\n * \r\n * @param room - The room to check\r\n * @returns SpawnRequest for the highest priority role that needs spawning, or undefined\r\n */\r\nexport function getNextSpawnRequest(room: Room): SpawnRequest | undefined {\r\n  const requests = getSpawnRequests(room);\r\n  return requests.length > 0 ? requests[0] : undefined;\r\n}\r\n","/**\r\n * CREEP TASK SYSTEM\r\n * \r\n * Allows assigning simple tasks to creeps via console.\r\n * Tasks override normal role behavior when active.\r\n * \r\n * Example tasks:\r\n * - harvest(sourceId)\r\n * - deliver(structureId)\r\n * - build(siteId)\r\n * - upgrade()\r\n * - move(x, y, roomName)\r\n */\r\n\r\nexport type TaskType = 'harvest' | 'deliver' | 'build' | 'upgrade' | 'move' | 'repair' | 'dismantle' | 'idle';\r\n\r\n/**\r\n * A task assigned to a creep\r\n */\r\nexport interface Task {\r\n  type: TaskType;\r\n  targetId?: string;           // For harvest, deliver, build, repair, dismantle\r\n  targetPos?: { x: number; y: number; roomName: string };  // For move\r\n  priority: 'low' | 'normal' | 'high';\r\n  assignedAt: number;\r\n  expiresAt?: number;          // Optional: task expires after N ticks\r\n  status: 'pending' | 'active' | 'completed' | 'failed';\r\n}\r\n\r\n/**\r\n * Get task assigned to a creep\r\n * \r\n * @param creep - The creep to check\r\n * @returns The current task, or undefined\r\n */\r\nexport function getTask(creep: Creep): Task | undefined {\r\n  if (!creep.memory.task) {\r\n    return undefined;\r\n  }\r\n  return creep.memory.task as Task;\r\n}\r\n\r\n/**\r\n * Assign a task to a creep\r\n * \r\n * @param creep - The creep to assign to\r\n * @param task - The task to assign\r\n */\r\nexport function assignTask(creep: Creep, task: Task): void {\r\n  task.assignedAt = Game.time;\r\n  task.status = 'pending';\r\n  creep.memory.task = task;\r\n}\r\n\r\n/**\r\n * Clear task from a creep\r\n * \r\n * @param creep - The creep to clear\r\n */\r\nexport function clearTask(creep: Creep): void {\r\n  creep.memory.task = undefined;\r\n}\r\n\r\n/**\r\n * Create a harvest task\r\n * \r\n * @param sourceId - The source's id\r\n * @returns Task object\r\n */\r\nexport function createHarvestTask(sourceId: string): Task {\r\n  return {\r\n    type: 'harvest',\r\n    targetId: sourceId,\r\n    priority: 'normal',\r\n    assignedAt: Game.time,\r\n    status: 'pending'\r\n  };\r\n}\r\n\r\n/**\r\n * Create a deliver task\r\n * \r\n * @param structureId - The structure's id (spawn, extension, container, etc.)\r\n * @returns Task object\r\n */\r\nexport function createDeliverTask(structureId: string): Task {\r\n  return {\r\n    type: 'deliver',\r\n    targetId: structureId,\r\n    priority: 'normal',\r\n    assignedAt: Game.time,\r\n    status: 'pending'\r\n  };\r\n}\r\n\r\n/**\r\n * Create a build task\r\n * \r\n * @param siteId - The construction site's id\r\n * @returns Task object\r\n */\r\nexport function createBuildTask(siteId: string): Task {\r\n  return {\r\n    type: 'build',\r\n    targetId: siteId,\r\n    priority: 'normal',\r\n    assignedAt: Game.time,\r\n    status: 'pending'\r\n  };\r\n}\r\n\r\n/**\r\n * Create an upgrade task\r\n * \r\n * @returns Task object\r\n */\r\nexport function createUpgradeTask(): Task {\r\n  return {\r\n    type: 'upgrade',\r\n    priority: 'normal',\r\n    assignedAt: Game.time,\r\n    status: 'pending'\r\n  };\r\n}\r\n\r\n/**\r\n * Create a move task\r\n * \r\n * @param x - Target X coordinate\r\n * @param y - Target Y coordinate\r\n * @param roomName - Target room\r\n * @returns Task object\r\n */\r\nexport function createMoveTask(x: number, y: number, roomName: string): Task {\r\n  return {\r\n    type: 'move',\r\n    targetPos: { x, y, roomName },\r\n    priority: 'normal',\r\n    assignedAt: Game.time,\r\n    status: 'pending'\r\n  };\r\n}\r\n\r\n/**\r\n * Create a repair task\r\n * \r\n * @param structureId - The structure's id\r\n * @returns Task object\r\n */\r\nexport function createRepairTask(structureId: string): Task {\r\n  return {\r\n    type: 'repair',\r\n    targetId: structureId,\r\n    priority: 'normal',\r\n    assignedAt: Game.time,\r\n    status: 'pending'\r\n  };\r\n}\r\n\r\n/**\r\n * Create an idle task (do nothing)\r\n * \r\n * @returns Task object\r\n */\r\nexport function createIdleTask(): Task {\r\n  return {\r\n    type: 'idle',\r\n    priority: 'low',\r\n    assignedAt: Game.time,\r\n    status: 'pending'\r\n  };\r\n}\r\n\r\n/**\r\n * Execute a task for a creep\r\n * \r\n * @param creep - The creep executing the task\r\n * @param task - The task to execute\r\n * @returns true if task is completed, false if still active\r\n */\r\nexport function executeTask(creep: Creep, task: Task): boolean {\r\n  // Check if task has expired\r\n  if (task.expiresAt && Game.time > task.expiresAt) {\r\n    return true; // Task expired, mark as done\r\n  }\r\n\r\n  task.status = 'active';\r\n\r\n  switch (task.type) {\r\n    case 'harvest': {\r\n      if (!task.targetId) return true;\r\n      const source = Game.getObjectById(task.targetId as Id<Source>);\r\n      if (!source) return true;\r\n\r\n      const result = creep.harvest(source);\r\n      if (result === ERR_NOT_IN_RANGE) {\r\n        creep.travelTo(source);\r\n      } else if (result === OK) {\r\n        // Harvesting...\r\n      }\r\n      return false;\r\n    }\r\n\r\n    case 'deliver': {\r\n      if (!task.targetId) return true;\r\n      const target = Game.getObjectById(task.targetId as Id<AnyStoreStructure>);\r\n      if (!target) return true;\r\n\r\n      const result = creep.transfer(target, RESOURCE_ENERGY);\r\n      if (result === ERR_NOT_IN_RANGE) {\r\n        creep.travelTo(target);\r\n      } else if (result === OK) {\r\n        // Delivered\r\n      }\r\n      return false;\r\n    }\r\n\r\n    case 'build': {\r\n      if (!task.targetId) return true;\r\n      const site = Game.getObjectById(task.targetId as Id<ConstructionSite>);\r\n      if (!site) return true;\r\n\r\n      const result = creep.build(site);\r\n      if (result === ERR_NOT_IN_RANGE) {\r\n        creep.travelTo(site);\r\n      } else if (result === OK) {\r\n        // Building\r\n      }\r\n      return false;\r\n    }\r\n\r\n    case 'upgrade': {\r\n      const controller = creep.room.controller;\r\n      if (!controller) return true;\r\n\r\n      const result = creep.upgradeController(controller);\r\n      if (result === ERR_NOT_IN_RANGE) {\r\n        creep.travelTo(controller);\r\n      } else if (result === OK) {\r\n        // Upgrading\r\n      }\r\n      return false;\r\n    }\r\n\r\n    case 'move': {\r\n      if (!task.targetPos) return true;\r\n      const pos = new RoomPosition(task.targetPos.x, task.targetPos.y, task.targetPos.roomName);\r\n      const range = creep.pos.getRangeTo(pos);\r\n\r\n      if (range > 0) {\r\n        creep.travelTo(pos);\r\n      }\r\n      return range === 0; // Complete when arrived\r\n    }\r\n\r\n    case 'repair': {\r\n      if (!task.targetId) return true;\r\n      const structure = Game.getObjectById(task.targetId as Id<Structure>);\r\n      if (!structure) return true;\r\n\r\n      const result = creep.repair(structure);\r\n      if (result === ERR_NOT_IN_RANGE) {\r\n        creep.travelTo(structure);\r\n      } else if (result === OK) {\r\n        // Repairing\r\n      }\r\n      return false;\r\n    }\r\n\r\n    case 'idle': {\r\n      // Do nothing, task never completes automatically\r\n      return false;\r\n    }\r\n\r\n    default:\r\n      return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Get task status as a human-readable string\r\n */\r\nexport function getTaskDescription(task: Task): string {\r\n  switch (task.type) {\r\n    case 'harvest': {\r\n      const source = Game.getObjectById(task.targetId as Id<Source>);\r\n      return `Harvest from ${source ? source.pos : task.targetId}`;\r\n    }\r\n    case 'deliver': {\r\n      const target = Game.getObjectById(task.targetId as Id<AnyStoreStructure>);\r\n      return `Deliver to ${target ? target.pos : task.targetId}`;\r\n    }\r\n    case 'build': {\r\n      const site = Game.getObjectById(task.targetId as Id<ConstructionSite>);\r\n      return `Build ${site ? site.pos : task.targetId}`;\r\n    }\r\n    case 'upgrade':\r\n      return 'Upgrade controller';\r\n    case 'move':\r\n      return `Move to ${task.targetPos?.x},${task.targetPos?.y}`;\r\n    case 'repair': {\r\n      const structure = Game.getObjectById(task.targetId as Id<Structure>);\r\n      return `Repair ${structure ? structure.pos : task.targetId}`;\r\n    }\r\n    case 'idle':\r\n      return 'Idle (do nothing)';\r\n    default:\r\n      return 'Unknown task';\r\n  }\r\n}\r\n","/**\r\n * CREEP DISPATCHER MODULE\r\n * \r\n * Central dispatcher for all creep role behaviors.\r\n * This module imports role-specific behaviors and routes each creep\r\n * to the correct handler based on its role.\r\n * \r\n * Architecture:\r\n * - Each role has its own file (miner.ts, upgrader.ts, builder.ts)\r\n * - behaviors.ts defines RCL-specific configurations\r\n * - This index exports a unified `runCreep` function\r\n * - Main loop calls `runCreep` for each creep\r\n * \r\n * Adding new roles:\r\n * 1. Create new file (e.g., src/world/creeps/repairer.ts)\r\n * 2. Import it here: import { runRepairer } from './repairer';\r\n * 3. Add case to switch statement below\r\n * 4. Add role to appropriate RCL config in behaviors.ts\r\n */\r\n\r\nimport { runMiner } from './miner';\r\nimport { runHauler } from './hauler';\r\nimport { runUpgrader } from './upgrader';\r\nimport { runBuilder } from './builder';\r\n\r\n/**\r\n * Dispatches a creep to its role-specific behavior.\r\n * \r\n * This is the single entry point for running creep behaviors.\r\n * It reads the creep's role from memory and calls the appropriate function.\r\n * \r\n * @param creep - The creep to run behavior for\r\n * \r\n * @remarks\r\n * If a creep has an unknown role, a warning is logged but no error is thrown.\r\n * This prevents one bad creep from crashing the entire game loop.\r\n * \r\n * @example\r\n * ```typescript\r\n * const creeps = room.find(FIND_MY_CREEPS);\r\n * creeps.forEach(creep => runCreep(creep));\r\n * ```\r\n */\r\nexport function runCreep(creep: Creep): void {\r\n  // Dispatch based on role stored in creep memory\r\n  switch (creep.memory.role) {\r\n    case 'miner':\r\n      runMiner(creep);\r\n      break;\r\n    \r\n    case 'hauler':\r\n      runHauler(creep);\r\n      break;\r\n    \r\n    case 'upgrader':\r\n      runUpgrader(creep);\r\n      break;\r\n    \r\n    case 'builder':\r\n      runBuilder(creep);\r\n      break;\r\n    \r\n    default:\r\n      // Unknown role - log warning but don't crash\r\n      console.log(`⚠️ Unknown role '${creep.memory.role}' for creep ${creep.name}`);\r\n      break;\r\n  }\r\n}\r\n\r\n/**\r\n * Re-export individual role functions for advanced use cases.\r\n * Most code should use `runCreep`, but these are available if needed.\r\n */\r\nexport { runMiner } from './miner';\r\nexport { runUpgrader } from './upgrader';\r\nexport { runBuilder } from './builder';\r\n\r\n// Export behavior configuration system\r\nexport {\r\n  getBehaviorConfig,\r\n  getRoleConfig,\r\n  getRolesByPriority,\r\n  rcl1Behavior,\r\n  rcl2Behavior,\r\n  type BehaviorConfig,\r\n  type RoleConfig\r\n} from './behaviors';\r\n\r\n// Export spawn request utilities\r\nexport {\r\n  getSpawnRequests,\r\n  getNextSpawnRequest,\r\n  getSpawnStatus,\r\n  type SpawnRequest\r\n} from './spawning';\r\n\r\n// Export task system\r\nexport {\r\n  getTask,\r\n  assignTask,\r\n  clearTask,\r\n  executeTask,\r\n  createHarvestTask,\r\n  createDeliverTask,\r\n  createBuildTask,\r\n  createUpgradeTask,\r\n  createMoveTask,\r\n  createRepairTask,\r\n  createIdleTask,\r\n  getTaskDescription,\r\n  type Task,\r\n  type TaskType\r\n} from './tasks';\r\n","/**\r\n * ROOM VISUAL DISPLAY SYSTEM\r\n * \r\n * Renders structure names and labels as visual markers on the map.\r\n * Persists display state for 3 ticks when activated.\r\n * Labels are stored in memory to survive ticks.\r\n */\r\n\r\n/**\r\n * Display structure names as room visuals\r\n * \r\n * @param roomName - Name of room to display labels in\r\n * @param duration - How many ticks to display (default 3)\r\n */\r\nexport function showNames(roomName: string, duration: number = 3): void {\r\n  if (!Memory.empire) {\r\n    Memory.empire = {};\r\n  }\r\n  if (!Memory.empire.visuals) {\r\n    Memory.empire.visuals = {};\r\n  }\r\n\r\n  Memory.empire.visuals[roomName] = {\r\n    expiresAt: Game.time + duration\r\n  };\r\n\r\n  console.log(`👁️  Displaying structure names in ${roomName} for ${duration} ticks`);\r\n}\r\n\r\n/**\r\n * Hide structure name displays\r\n * \r\n * @param roomName - Name of room to hide labels in\r\n */\r\nexport function hideNames(roomName: string): void {\r\n  if (Memory.empire?.visuals?.[roomName]) {\r\n    delete Memory.empire.visuals[roomName];\r\n  }\r\n  console.log(`🚫 Hidden structure names in ${roomName}`);\r\n}\r\n\r\n/**\r\n * Check if names should be displayed in a room\r\n */\r\nexport function shouldShowNames(roomName: string): boolean {\r\n  if (!Memory.empire?.visuals?.[roomName]) {\r\n    return false;\r\n  }\r\n\r\n  const visual = Memory.empire.visuals[roomName];\r\n  return Game.time <= visual.expiresAt;\r\n}\r\n\r\n/**\r\n * Render all visible structure names in a room as visual text\r\n * Call this each tick in your room orchestrator\r\n */\r\nexport function renderStructureNames(room: Room): void {\r\n  if (!shouldShowNames(room.name)) {\r\n    return;\r\n  }\r\n\r\n  const visual = new RoomVisual(room.name);\r\n  \r\n  // Get all structures from registry\r\n  const registry = (Memory.structures as Record<string, any>) || {};\r\n  \r\n  for (const [id, info] of Object.entries(registry)) {\r\n    if (info.roomName !== room.name) continue;\r\n\r\n    // Get the actual object in the room\r\n    const obj = Game.getObjectById(id as Id<AnyStructure>);\r\n    if (!obj || !obj.pos) continue;\r\n\r\n    // Draw the name at the structure's position\r\n    let color = '#00FF00'; // Green by default\r\n\r\n    // Color by type for better visibility\r\n    if (info.type === 'source') {\r\n      color = '#FFFF00'; // Yellow for sources\r\n    } else if (info.type === 'controller') {\r\n      color = '#0066FF'; // Blue for controller\r\n    } else if (info.locked) {\r\n      color = '#FF0000'; // Red if locked\r\n    } else if (info.type === 'site') {\r\n      color = '#FF9900'; // Orange for construction sites\r\n    }\r\n\r\n    // Draw text label above the structure\r\n    visual.text(info.name, obj.pos.x, obj.pos.y - 0.5, {\r\n      color,\r\n      font: 0.6,\r\n      align: 'center',\r\n      backgroundColor: '#000000'\r\n    });\r\n\r\n    // Draw a small circle indicator\r\n    visual.circle(obj.pos.x, obj.pos.y, {\r\n      radius: 0.3,\r\n      fill: 'transparent',\r\n      stroke: color\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Get visual display status for a room\r\n */\r\nexport function getVisualStatus(roomName: string): string {\r\n  if (!shouldShowNames(roomName)) {\r\n    return `👁️  Labels: OFF`;\r\n  }\r\n\r\n  const expiresAt = Memory.empire?.visuals?.[roomName]?.expiresAt || 0;\r\n  const ticksRemaining = expiresAt - Game.time;\r\n  return `👁️  Labels: ON (${ticksRemaining} ticks remaining)`;\r\n}\r\n\r\n/**\r\n * Get all rooms with active visuals\r\n */\r\nexport function getActiveVisualRooms(): string[] {\r\n  if (!Memory.empire?.visuals) {\r\n    return [];\r\n  }\r\n\r\n  return Object.entries(Memory.empire.visuals)\r\n    .filter(([_, visual]) => Game.time <= visual.expiresAt)\r\n    .map(([roomName, _]) => roomName);\r\n}\r\n","/**\r\n * STRUCTURE REGISTRY & NAMING SYSTEM\r\n * \r\n * Automatically assigns human-readable names to structures.\r\n * Stores mapping between IDs and names in Memory.\r\n * \r\n * Examples:\r\n * - Sources: SourceA, SourceB\r\n * - Spawns: SpawnMain, SpawnBackup\r\n * - Extensions: ExtensionA, ExtensionB\r\n * - Containers: ContainerA, ContainerB\r\n * - Controllers: ControllerMain\r\n */\r\n\r\nexport interface StructureInfo {\r\n  id: string;\r\n  name: string;\r\n  type: string;\r\n  roomName: string;\r\n  locked: boolean;\r\n  createdAt: number;\r\n}\r\n\r\n/**\r\n * Get or create the structures registry in memory\r\n */\r\nfunction getRegistry(): Record<string, StructureInfo> {\r\n  if (!Memory.structures) {\r\n    Memory.structures = {};\r\n  }\r\n  return Memory.structures as Record<string, StructureInfo>;\r\n}\r\n\r\n/**\r\n * Register a structure with a name\r\n */\r\nfunction registerStructure(id: string, name: string, type: string, roomName: string): void {\r\n  const registry = getRegistry();\r\n  registry[id] = {\r\n    id,\r\n    name,\r\n    type,\r\n    roomName,\r\n    locked: false,\r\n    createdAt: Game.time\r\n  };\r\n}\r\n\r\n/**\r\n * Get name for a structure by ID\r\n */\r\nexport function getStructureName(id: string): string {\r\n  const registry = getRegistry();\r\n  return registry[id]?.name || id;\r\n}\r\n\r\n/**\r\n * Get ID for a structure by name\r\n */\r\nexport function getStructureId(name: string): string | undefined {\r\n  const registry = getRegistry();\r\n  for (const [id, info] of Object.entries(registry)) {\r\n    if (info.name === name) {\r\n      return id;\r\n    }\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Scan room and auto-name structures and construction sites\r\n */\r\nexport function scanRoom(room: Room): void {\r\n  const registry = getRegistry();\r\n\r\n  // Sources\r\n  const sources = room.find(FIND_SOURCES);\r\n  sources.forEach((source, index) => {\r\n    if (!registry[source.id]) {\r\n      const letter = String.fromCharCode(65 + index); // A, B, C...\r\n      registerStructure(source.id, `Source${letter}`, 'source', room.name);\r\n    }\r\n  });\r\n\r\n  // Spawns\r\n  const spawns = room.find(FIND_MY_SPAWNS);\r\n  spawns.forEach((spawn, index) => {\r\n    if (!registry[spawn.id]) {\r\n      const name = index === 0 ? 'SpawnMain' : `SpawnBackup${index}`;\r\n      registerStructure(spawn.id, name, 'spawn', room.name);\r\n    }\r\n  });\r\n\r\n  // Extensions\r\n  const extensions = room.find(FIND_MY_STRUCTURES, {\r\n    filter: s => s.structureType === STRUCTURE_EXTENSION\r\n  });\r\n  extensions.forEach((ext, index) => {\r\n    if (!registry[ext.id]) {\r\n      const letter = String.fromCharCode(65 + index);\r\n      registerStructure(ext.id, `Extension${letter}`, 'extension', room.name);\r\n    }\r\n  });\r\n\r\n  // Containers (they're resources, not structures in the Screeps API)\r\n  // Skip containers in this scan as they're handled separately\r\n\r\n  // Storage\r\n  const storage = room.find(FIND_MY_STRUCTURES, {\r\n    filter: s => s.structureType === STRUCTURE_STORAGE\r\n  });\r\n  storage.forEach(stor => {\r\n    if (!registry[stor.id]) {\r\n      registerStructure(stor.id, 'Storage', 'storage', room.name);\r\n    }\r\n  });\r\n\r\n  // Controller\r\n  if (room.controller && !registry[room.controller.id]) {\r\n    registerStructure(room.controller.id, 'Controller', 'controller', room.name);\r\n  }\r\n\r\n  // Construction sites - name them site1, site2, etc.\r\n  const sites = room.find(FIND_MY_CONSTRUCTION_SITES);\r\n  sites.forEach(site => {\r\n    if (!registry[site.id]) {\r\n      // Find the next available site number\r\n      let siteNum = 1;\r\n      while (Object.values(registry).some(s => s.name === `site${siteNum}` && s.roomName === room.name)) {\r\n        siteNum++;\r\n      }\r\n      registerStructure(site.id, `site${siteNum}`, 'site', room.name);\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Lock a structure (prevent actions on it)\r\n */\r\nexport function lockStructure(nameOrId: string): boolean {\r\n  const registry = getRegistry();\r\n  const id = registry[nameOrId] ? nameOrId : getStructureId(nameOrId);\r\n\r\n  if (!id || !registry[id]) {\r\n    return false;\r\n  }\r\n\r\n  registry[id].locked = true;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Unlock a structure\r\n */\r\nexport function unlockStructure(nameOrId: string): boolean {\r\n  const registry = getRegistry();\r\n  const id = registry[nameOrId] ? nameOrId : getStructureId(nameOrId);\r\n\r\n  if (!id || !registry[id]) {\r\n    return false;\r\n  }\r\n\r\n  registry[id].locked = false;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Check if a structure is locked\r\n */\r\nexport function isLocked(nameOrId: string): boolean {\r\n  const registry = getRegistry();\r\n  const id = registry[nameOrId] ? nameOrId : getStructureId(nameOrId);\r\n\r\n  if (!id || !registry[id]) {\r\n    return false;\r\n  }\r\n\r\n  return registry[id].locked;\r\n}\r\n\r\n/**\r\n * Get all structures in a room\r\n */\r\nexport function getStructuresInRoom(roomName: string): StructureInfo[] {\r\n  const registry = getRegistry();\r\n  return Object.values(registry).filter(s => s.roomName === roomName);\r\n}\r\n\r\n/**\r\n * Get all structures of a type\r\n */\r\nexport function getStructuresByType(type: string, roomName?: string): StructureInfo[] {\r\n  const registry = getRegistry();\r\n  return Object.values(registry).filter(s => \r\n    s.type === type && (!roomName || s.roomName === roomName)\r\n  );\r\n}\r\n\r\n/**\r\n * Rename a structure\r\n */\r\nexport function renameStructure(oldNameOrId: string, newName: string): boolean {\r\n  const registry = getRegistry();\r\n  const id = registry[oldNameOrId] ? oldNameOrId : getStructureId(oldNameOrId);\r\n\r\n  if (!id || !registry[id]) {\r\n    return false;\r\n  }\r\n\r\n  // Check if new name is already taken\r\n  for (const [otherId, info] of Object.entries(registry)) {\r\n    if (otherId !== id && info.name === newName) {\r\n      return false; // Name conflict\r\n    }\r\n  }\r\n\r\n  registry[id].name = newName;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Get structure info\r\n */\r\nexport function getStructureInfo(nameOrId: string): StructureInfo | undefined {\r\n  const registry = getRegistry();\r\n  const id = registry[nameOrId] ? nameOrId : getStructureId(nameOrId);\r\n\r\n  if (!id) {\r\n    return undefined;\r\n  }\r\n\r\n  return registry[id];\r\n}\r\n\r\n/**\r\n * Get all locked structures\r\n */\r\nexport function getLockedStructures(roomName?: string): StructureInfo[] {\r\n  const registry = getRegistry();\r\n  return Object.values(registry).filter(s => \r\n    s.locked && (!roomName || s.roomName === roomName)\r\n  );\r\n}\r\n\r\n/**\r\n * List all structures (for debugging)\r\n */\r\nexport function listStructures(roomName?: string): void {\r\n  const registry = getRegistry();\r\n  const structures = roomName\r\n    ? Object.values(registry).filter(s => s.roomName === roomName)\r\n    : Object.values(registry);\r\n\r\n  if (structures.length === 0) {\r\n    console.log('No structures registered');\r\n    return;\r\n  }\r\n\r\n  console.log('\\nRegistered Structures:');\r\n  console.log('─'.repeat(80));\r\n\r\n  for (const info of structures) {\r\n    const locked = info.locked ? '🔒' : '🔓';\r\n    console.log(\r\n      `${locked} ${info.name.padEnd(20)} | ${info.type.padEnd(12)} | ${info.roomName} | ${info.id.substring(0, 8)}...`\r\n    );\r\n  }\r\n\r\n  console.log('');\r\n}\r\n\r\n/**\r\n * Auto-rename completed construction sites to final names\r\n * Called each tick to detect completed sites and rename them\r\n */\r\nexport function updateConstructionSites(room: Room): void {\r\n  const registry = getRegistry();\r\n\r\n  // Find all completed structures that were built from sites\r\n  const completedStructures = room.find(FIND_MY_STRUCTURES);\r\n\r\n  completedStructures.forEach(struct => {\r\n    // Check if this structure is NOT in the registry with a permanent name\r\n    const existing = Object.values(registry).find(s => s.id === struct.id);\r\n\r\n    // If it's not registered, register it\r\n    if (!existing) {\r\n      let name = '';\r\n      const type = struct.structureType;\r\n\r\n      // Generate name based on type and existing count\r\n      switch (type) {\r\n        case STRUCTURE_EXTENSION: {\r\n          const count = Object.values(registry).filter(s => s.type === 'extension' && s.roomName === room.name).length;\r\n          const letter = String.fromCharCode(65 + count);\r\n          name = `Extension${letter}`;\r\n          break;\r\n        }\r\n        case STRUCTURE_TOWER: {\r\n          const count = Object.values(registry).filter(s => s.type === 'tower' && s.roomName === room.name).length;\r\n          const letter = String.fromCharCode(65 + count);\r\n          name = `Tower${letter}`;\r\n          break;\r\n        }\r\n        case STRUCTURE_STORAGE:\r\n          name = 'Storage';\r\n          break;\r\n        case STRUCTURE_RAMPART: {\r\n          const count = Object.values(registry).filter(s => s.type === 'rampart' && s.roomName === room.name).length;\r\n          const letter = String.fromCharCode(65 + count);\r\n          name = `Rampart${letter}`;\r\n          break;\r\n        }\r\n        default:\r\n          name = `${type}${Game.time}`;\r\n      }\r\n\r\n      registerStructure(struct.id, name, type, room.name);\r\n    }\r\n  });\r\n\r\n  // Check for completed construction sites and rename them\r\n  const sites = room.find(FIND_MY_CONSTRUCTION_SITES);\r\n  const siteIds = new Set(sites.map(s => s.id));\r\n\r\n  // If a registered site is no longer in the construction list, it was completed\r\n  const registryArray = Object.entries(registry);\r\n  for (const [id, info] of registryArray) {\r\n    if (info.roomName === room.name && info.type === 'site' && !siteIds.has(id as any)) {\r\n      // Site completed! Remove the site entry - it will be picked up as a new structure above\r\n      delete registry[id];\r\n    }\r\n  }\r\n}\r\n\r\n","/**\r\n * EMPIRE MANAGEMENT MODULE\r\n * \r\n * Manages empire-wide settings and policies that affect behavior across all rooms.\r\n * Two operational modes:\r\n * - COMMAND: Direct manual control - you make all decisions\r\n * - DELEGATE: Automatic AI control - empire handles spawning, construction, etc.\r\n */\r\n\r\nexport type EmpireMode = 'command' | 'delegate';\r\n\r\n/**\r\n * Initialize empire memory if not present\r\n */\r\nfunction initializeEmpireMemory(): void {\r\n  if (!Memory.empire) {\r\n    Memory.empire = {};\r\n  }\r\n  \r\n  if (!(Memory.empire as any).mode) {\r\n    (Memory.empire as any).mode = 'delegate';\r\n    (Memory.empire as any).modeChangedAt = Game.time;\r\n  }\r\n}\r\n\r\n/**\r\n * Get current empire mode\r\n * \r\n * @returns Current mode: 'command' or 'delegate'\r\n */\r\nexport function getMode(): EmpireMode {\r\n  initializeEmpireMemory();\r\n  return (Memory.empire as any).mode || 'delegate';\r\n}\r\n\r\n/**\r\n * Set empire mode\r\n * \r\n * @param mode - 'command' or 'delegate'\r\n * @returns true if mode changed, false if already in that mode\r\n */\r\nexport function setMode(mode: EmpireMode): boolean {\r\n  initializeEmpireMemory();\r\n  const currentMode = (Memory.empire as any).mode;\r\n\r\n  if (currentMode === mode) {\r\n    return false;\r\n  }\r\n\r\n  (Memory.empire as any).mode = mode;\r\n  (Memory.empire as any).modeChangedAt = Game.time;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Get ticks since last mode change\r\n */\r\nexport function getTicksSinceModeChange(): number {\r\n  initializeEmpireMemory();\r\n  const changedAt = (Memory.empire as any).modeChangedAt || 0;\r\n  return Game.time - changedAt;\r\n}\r\n\r\n/**\r\n * Check if in command mode\r\n */\r\nexport function isCommandMode(): boolean {\r\n  return getMode() === 'command';\r\n}\r\n\r\n/**\r\n * Check if in delegate mode\r\n */\r\nexport function isDelegateMode(): boolean {\r\n  return getMode() === 'delegate';\r\n}\r\n\r\n/**\r\n * Display mode information\r\n */\r\nexport function displayModeInfo(): void {\r\n  const mode = getMode();\r\n  const ticksSince = getTicksSinceModeChange();\r\n  \r\n  const modeEmoji = mode === 'command' ? '⚔️' : '📋';\r\n  const modeDescription = mode === 'command' \r\n    ? 'Direct Control - You are in command of all operations'\r\n    : 'Delegation Mode - AI handles spawn priorities and construction';\r\n\r\n  console.log(`\\n${'═'.repeat(60)}`);\r\n  console.log(`${modeEmoji} EMPIRE MODE: ${mode.toUpperCase()}`);\r\n  console.log(`${'═'.repeat(60)}`);\r\n  console.log(`${modeDescription}`);\r\n  console.log(`Mode active for: ${ticksSince} ticks`);\r\n  console.log(`${'═'.repeat(60)}\\n`);\r\n}\r\n","/**\r\n * ROOM ORCHESTRATOR MODULE\r\n * \r\n * Coordinates all activities within a single room.\r\n * This is the \"conductor\" that brings together spawning, creep behaviors,\r\n * and room-level strategy.\r\n * \r\n * Responsibilities:\r\n * - Run spawn manager to maintain creep population\r\n * - Dispatch creep behaviors based on role\r\n * - Report room statistics for debugging\r\n * - Handle room-level optimizations (future: tower management, link logic, etc.)\r\n * \r\n * RCL1 Focus:\r\n * - Simple priority-based spawning\r\n * - Role-based creep behaviors\r\n * - Energy flow optimization\r\n */\r\n\r\nimport { manageSpawn } from '../spawns/manager';\r\nimport { runCreep } from '../creeps';\r\nimport { renderStructureNames } from '../visuals';\r\nimport { updateConstructionSites } from '../structures';\r\nimport { isCommandMode } from '../empire';\r\n\r\n/**\r\n * Runs all logic for a single owned room.\r\n * Called once per tick for each room under your control.\r\n * \r\n * This is the main orchestration function that:\r\n * 1. Counts creeps by role\r\n * 2. Manages spawning via spawn manager\r\n * 3. Runs behavior for each creep\r\n * 4. Reports statistics\r\n * \r\n * @param room - The room to orchestrate\r\n * \r\n * @remarks\r\n * This function should only be called for rooms with a controller\r\n * that you own (room.controller.my === true).\r\n * \r\n * @example\r\n * ```typescript\r\n * for (const roomName in Game.rooms) {\r\n *   const room = Game.rooms[roomName];\r\n *   if (room.controller && room.controller.my) {\r\n *     runRoom(room);\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport function runRoom(room: Room): void {\r\n  // Find the primary spawn in this room\r\n  const spawn = room.find(FIND_MY_SPAWNS)[0];\r\n  if (!spawn) {\r\n    // No spawn in this room, can't do much yet\r\n    return;\r\n  }\r\n\r\n  // Update construction sites each tick (rename completed ones)\r\n  updateConstructionSites(room);\r\n\r\n  // Get all creeps in this room\r\n  const creeps = room.find(FIND_MY_CREEPS);\r\n  \r\n  // Count creeps by role for spawn manager\r\n  const roleCounts = countCreepsByRole(creeps);\r\n  const { minerCount, upgraderCount, builderCount } = roleCounts;\r\n\r\n  // Log room statistics for debugging (every 100 ticks to reduce console spam)\r\n  if (Game.time % 100 === 0) {\r\n    logRoomStats(room, roleCounts);\r\n  }\r\n\r\n  // Manage spawning based on current population\r\n  // SKIP automatic spawning in COMMAND mode - user has full manual control\r\n  // In DELEGATE mode, AI automatically spawns creeps based on priorities\r\n  if (!isCommandMode()) {\r\n    manageSpawn(spawn, room, minerCount, upgraderCount, builderCount);\r\n  }\r\n\r\n  // Run behavior for each creep in the room\r\n  runCreeps(creeps);\r\n\r\n  // Render structure name visuals if enabled\r\n  renderStructureNames(room);\r\n}\r\n\r\n/**\r\n * Counts creeps by their role.\r\n * \r\n * @param creeps - Array of creeps to count\r\n * @returns Object with counts for each role\r\n * \r\n * @remarks\r\n * This is more efficient than filtering multiple times,\r\n * and makes it easy to add new roles in the future.\r\n */\r\nfunction countCreepsByRole(creeps: Creep[]): {\r\n  minerCount: number;\r\n  upgraderCount: number;\r\n  builderCount: number;\r\n} {\r\n  const miners = creeps.filter(c => c.memory.role === 'miner');\r\n  const upgraders = creeps.filter(c => c.memory.role === 'upgrader');\r\n  const builders = creeps.filter(c => c.memory.role === 'builder');\r\n\r\n  return {\r\n    minerCount: miners.length,\r\n    upgraderCount: upgraders.length,\r\n    builderCount: builders.length\r\n  };\r\n}\r\n\r\n/**\r\n * Logs room statistics to console for debugging.\r\n * \r\n * Shows:\r\n * - Room name\r\n * - Creep counts by role (H=harvesters, U=upgraders, B=builders)\r\n * - Current RCL (Room Controller Level)\r\n * \r\n * @param room - The room to log stats for\r\n * @param roleCounts - Counts of creeps by role\r\n * \r\n * @remarks\r\n * This is useful for debugging and monitoring room performance.\r\n * In production, you might want to reduce console spam by logging\r\n * only every N ticks or when values change.\r\n */\r\nfunction logRoomStats(\r\n  room: Room,\r\n  roleCounts: { minerCount: number; upgraderCount: number; builderCount: number }\r\n): void {\r\n  const { minerCount, upgraderCount, builderCount } = roleCounts;\r\n  const rcl = room.controller ? room.controller.level : 0;\r\n  \r\n  console.log(\r\n    `📊 ${room.name}: M=${minerCount}, U=${upgraderCount}, B=${builderCount}, RCL=${rcl}`\r\n  );\r\n}\r\n\r\n/**\r\n * Runs behavior for all creeps in the room.\r\n * \r\n * Dispatches each creep to its role-specific behavior function\r\n * via the unified creep dispatcher.\r\n * \r\n * @param creeps - Array of creeps to run\r\n * \r\n * @remarks\r\n * The actual role logic is in src/world/creeps/*.ts files.\r\n * This function just iterates and dispatches to the right handler.\r\n */\r\nfunction runCreeps(creeps: Creep[]): void {\r\n  creeps.forEach(creep => {\r\n    runCreep(creep);\r\n  });\r\n}\r\n","/**\r\n * LEGATUS OF OFICIO - THE TASKMASTER\r\n * \r\n * Central command processor for creep management.\r\n * Stores room context and task queues, relaying commands to creeps.\r\n * Reduces per-creep memory overhead by centralizing command dispatch.\r\n * \r\n * The Legatus receives orders and distributes them to the appropriate creeps,\r\n * tracking execution state without burdening individual creep memory.\r\n */\r\n\r\nexport interface LegaCommand {\r\n  type: 'harvest' | 'deliver' | 'build' | 'upgrade' | 'move' | 'repair' | 'idle';\r\n  target?: string; // Structure/resource name or position\r\n  priority?: 'low' | 'normal' | 'high';\r\n  issuedAt: number;\r\n}\r\n\r\ninterface CreepAssignment {\r\n  creepName: string;\r\n  command: LegaCommand;\r\n  assignedAt: number;\r\n}\r\n\r\ninterface RoomLegatus {\r\n  room: string;\r\n  assignments: CreepAssignment[];\r\n  lastUpdated: number;\r\n}\r\n\r\n/**\r\n * Get the Legatus registry for a room\r\n */\r\nfunction getLegatus(roomName: string): RoomLegatus {\r\n  if (!Memory.empire) {\r\n    Memory.empire = {};\r\n  }\r\n  if (!Memory.empire.legatus) {\r\n    Memory.empire.legatus = {};\r\n  }\r\n\r\n  const legatus = Memory.empire.legatus as Record<string, RoomLegatus>;\r\n\r\n  if (!legatus[roomName]) {\r\n    legatus[roomName] = {\r\n      room: roomName,\r\n      assignments: [],\r\n      lastUpdated: Game.time\r\n    };\r\n  }\r\n\r\n  return legatus[roomName];\r\n}\r\n\r\n/**\r\n * Issue a command to all creeps of a specific role\r\n * \r\n * @param room - Room where the command applies\r\n * @param role - Role to target (e.g., 'harvester', 'builder')\r\n * @param command - The command to issue\r\n */\r\nexport function issueCommandToRole(room: Room, role: string, command: LegaCommand): number {\r\n  const legatus = getLegatus(room.name);\r\n  const creeps = room.find(FIND_MY_CREEPS).filter(c => c.memory.role === role);\r\n\r\n  let assignedCount = 0;\r\n  for (const creep of creeps) {\r\n    legatus.assignments.push({\r\n      creepName: creep.name,\r\n      command,\r\n      assignedAt: Game.time\r\n    });\r\n    assignedCount++;\r\n  }\r\n\r\n  legatus.lastUpdated = Game.time;\r\n  return assignedCount;\r\n}\r\n\r\n/**\r\n * Issue a command to a specific creep\r\n * \r\n * @param creepName - Name of the creep\r\n * @param roomName - Room name for registry lookup\r\n * @param command - The command to issue\r\n */\r\nexport function issueCommandToCreep(creepName: string, roomName: string, command: LegaCommand): boolean {\r\n  const legatus = getLegatus(roomName);\r\n\r\n  // Remove any existing assignment for this creep\r\n  legatus.assignments = legatus.assignments.filter(a => a.creepName !== creepName);\r\n\r\n  // Add new assignment\r\n  legatus.assignments.push({\r\n    creepName,\r\n    command,\r\n    assignedAt: Game.time\r\n  });\r\n\r\n  legatus.lastUpdated = Game.time;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Get current command for a creep from Legatus\r\n * \r\n * @param creep - The creep to get command for\r\n * @returns The command, or undefined if none\r\n */\r\nexport function getCreepCommand(creep: Creep): LegaCommand | undefined {\r\n  const legatus = getLegatus(creep.room.name);\r\n\r\n  // Find assignment for this creep\r\n  for (const assignment of legatus.assignments) {\r\n    if (assignment.creepName === creep.name) {\r\n      return assignment.command;\r\n    }\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * Clear command for a creep\r\n * \r\n * @param creepName - Name of creep\r\n * @param roomName - Room name\r\n */\r\nexport function clearCreepCommand(creepName: string, roomName: string): void {\r\n  const legatus = getLegatus(roomName);\r\n  legatus.assignments = legatus.assignments.filter(a => a.creepName !== creepName);\r\n  legatus.lastUpdated = Game.time;\r\n}\r\n\r\n/**\r\n * Get all current assignments in a room\r\n * \r\n * @param roomName - Room to query\r\n * @returns Array of assignments\r\n */\r\nexport function getRoomAssignments(roomName: string): CreepAssignment[] {\r\n  const legatus = getLegatus(roomName);\r\n  return legatus.assignments;\r\n}\r\n\r\n/**\r\n * Get assignments for a specific creep\r\n * \r\n * @param creepName - Name of creep\r\n * @param roomName - Room name\r\n * @returns Assignment if found, undefined otherwise\r\n */\r\nexport function getCreepAssignment(creepName: string, roomName: string): CreepAssignment | undefined {\r\n  const legatus = getLegatus(roomName);\r\n  return legatus.assignments.find(a => a.creepName === creepName);\r\n}\r\n\r\n/**\r\n * Clear all assignments in a room\r\n * \r\n * @param roomName - Room to clear\r\n */\r\nexport function clearRoomAssignments(roomName: string): void {\r\n  const legatus = getLegatus(roomName);\r\n  legatus.assignments = [];\r\n  legatus.lastUpdated = Game.time;\r\n}\r\n\r\n/**\r\n * Get status of Legatus in a room\r\n */\r\nexport function getLegaStatus(roomName: string): string {\r\n  const legatus = getLegatus(roomName);\r\n  return `🎯 Legatus ${roomName}: ${legatus.assignments.length} active assignments`;\r\n}\r\n\r\n/**\r\n * List all assignments in a room (for debugging)\r\n */\r\nexport function listLegaAssignments(roomName: string): void {\r\n  const legatus = getLegatus(roomName);\r\n\r\n  if (legatus.assignments.length === 0) {\r\n    console.log(`📋 Legatus ${roomName}: No assignments`);\r\n    return;\r\n  }\r\n\r\n  console.log(`\\n📋 Legatus ${roomName}: ${legatus.assignments.length} assignments`);\r\n  console.log('─'.repeat(80));\r\n\r\n  for (const assignment of legatus.assignments) {\r\n    const ageInTicks = Game.time - assignment.assignedAt;\r\n    console.log(\r\n      `${assignment.creepName.padEnd(25)} | ${assignment.command.type.padEnd(10)} | Age: ${ageInTicks} ticks`\r\n    );\r\n  }\r\n\r\n  console.log('');\r\n}\r\n","/**\r\n * BODY CONFIG REGISTRY\r\n * \r\n * Stores named body configurations for easy creep spawning.\r\n * Allows preset bodies and dynamic body construction.\r\n * \r\n * Examples:\r\n * - registerBody('harvester1', [WORK, CARRY, MOVE])\r\n * - registerBody('scout', [MOVE])\r\n * - spawnCreep('Scout1', 'scout', 'scout', 'W1N1')\r\n */\r\n\r\nexport interface BodyConfig {\r\n  name: string;\r\n  parts: BodyPartConstant[];\r\n  role: string;\r\n  createdAt: number;\r\n}\r\n\r\n/**\r\n * Get or create the body registry in memory\r\n */\r\nfunction getBodyRegistry(): Record<string, BodyConfig> {\r\n  if (!Memory.empire) {\r\n    Memory.empire = {};\r\n  }\r\n  if (!Memory.empire.bodyConfigs) {\r\n    Memory.empire.bodyConfigs = {};\r\n  }\r\n  return Memory.empire.bodyConfigs as Record<string, BodyConfig>;\r\n}\r\n\r\n/**\r\n * Register a named body configuration\r\n * \r\n * @param name - Name of the body type (e.g., 'harvester_basic', 'scout')\r\n * @param parts - Array of body parts (e.g., [WORK, CARRY, MOVE])\r\n * @param role - Optional: the role this body is designed for\r\n */\r\nexport function registerBody(name: string, parts: BodyPartConstant[], role: string = 'generic'): void {\r\n  const registry = getBodyRegistry();\r\n  registry[name] = {\r\n    name,\r\n    parts,\r\n    role,\r\n    createdAt: Game.time\r\n  };\r\n}\r\n\r\n/**\r\n * Get a registered body configuration\r\n * \r\n * @param nameOrArray - Name of registered body, or array of parts\r\n * @returns Array of body parts, or undefined if not found\r\n */\r\nexport function getBodyConfig(nameOrArray: string | BodyPartConstant[]): BodyPartConstant[] | undefined {\r\n  // If it's already an array, return it\r\n  if (Array.isArray(nameOrArray)) {\r\n    return nameOrArray;\r\n  }\r\n\r\n  // Otherwise look it up\r\n  const registry = getBodyRegistry();\r\n  return registry[nameOrArray]?.parts;\r\n}\r\n\r\n/**\r\n * List all registered body configurations\r\n */\r\nexport function listBodyConfigs(role?: string): void {\r\n  const registry = getBodyRegistry();\r\n  const configs = role\r\n    ? Object.values(registry).filter(c => c.role === role)\r\n    : Object.values(registry);\r\n\r\n  if (configs.length === 0) {\r\n    console.log('📦 No body configurations registered');\r\n    return;\r\n  }\r\n\r\n  console.log(`\\n📦 Body Configurations${role ? ` (${role})` : ''}:`);\r\n  console.log('─'.repeat(80));\r\n\r\n  for (const config of configs) {\r\n    const partNames = config.parts.map(p => {\r\n      switch (p) {\r\n        case WORK: return 'W';\r\n        case CARRY: return 'C';\r\n        case MOVE: return 'M';\r\n        case ATTACK: return 'A';\r\n        case HEAL: return 'H';\r\n        case RANGED_ATTACK: return 'R';\r\n        case TOUGH: return 'T';\r\n        case CLAIM: return 'CL';\r\n        default: return p;\r\n      }\r\n    }).join('');\r\n\r\n    console.log(`  ${config.name.padEnd(25)} | ${config.role.padEnd(15)} | [${partNames}]`);\r\n  }\r\n\r\n  console.log('');\r\n}\r\n\r\n/**\r\n * Delete a registered body configuration\r\n */\r\nexport function deleteBodyConfig(name: string): boolean {\r\n  const registry = getBodyRegistry();\r\n  if (!registry[name]) {\r\n    return false;\r\n  }\r\n  delete registry[name];\r\n  return true;\r\n}\r\n\r\n/**\r\n * Get body cost (energy required to spawn)\r\n */\r\nexport function getBodyCost(nameOrArray: string | BodyPartConstant[]): number {\r\n  const parts = getBodyConfig(nameOrArray);\r\n  if (!parts) {\r\n    return 0;\r\n  }\r\n\r\n  let cost = 0;\r\n  for (const part of parts) {\r\n    cost += BODYPART_COST[part];\r\n  }\r\n  return cost;\r\n}\r\n\r\n/**\r\n * Register default/preset body types\r\n * Called once on startup\r\n */\r\nexport function registerDefaultBodies(): void {\r\n  // RCL1 Miner - balanced for early game\r\n  registerBody('miner_basic', [WORK, CARRY, MOVE], 'miner');\r\n\r\n  // RCL1 Upgrader\r\n  registerBody('upgrader_basic', [WORK, CARRY, MOVE], 'upgrader');\r\n\r\n  // RCL1 Builder\r\n  registerBody('builder_basic', [WORK, CARRY, MOVE], 'builder');\r\n\r\n  // Scout - minimal, just movement\r\n  registerBody('scout', [MOVE], 'scout');\r\n\r\n  // Hauler - lots of carry, minimal work\r\n  registerBody('hauler', [CARRY, CARRY, CARRY, MOVE, MOVE], 'hauler');\r\n\r\n  // Worker - balanced work and carry\r\n  registerBody('worker', [WORK, WORK, CARRY, MOVE], 'worker');\r\n}\r\n","/**\r\n * To start using Traveler, require it in main.js:\r\n * Example: var Traveler = require('Traveler.js');\r\n */\r\n\r\ndeclare const _: any;\r\n\r\nexport class Traveler {\r\n\r\n    private static structureMatrixCache: {[roomName: string]: CostMatrix} = {};\r\n    private static creepMatrixCache: {[roomName: string]: CostMatrix} = {};\r\n    private static creepMatrixTick: number;\r\n    private static structureMatrixTick: number;\r\n\r\n    /**\r\n     * move creep to destination\r\n     * @param creep\r\n     * @param destination\r\n     * @param options\r\n     * @returns {number}\r\n     */\r\n\r\n    public static travelTo(creep: Creep, destination: HasPos|RoomPosition, options: TravelToOptions = {}): number {\r\n\r\n        // uncomment if you would like to register hostile rooms entered\r\n        // this.updateRoomStatus(creep.room);\r\n\r\n        if (!destination) {\r\n            return ERR_INVALID_ARGS;\r\n        }\r\n\r\n        if (creep.fatigue > 0) {\r\n            Traveler.circle(creep.pos, \"aqua\", .3);\r\n            return ERR_TIRED;\r\n        }\r\n\r\n        destination = this.normalizePos(destination);\r\n\r\n        // manage case where creep is nearby destination\r\n        let rangeToDestination = creep.pos.getRangeTo(destination);\r\n        if (options.range && rangeToDestination <= options.range) {\r\n            return OK;\r\n        } else if (rangeToDestination <= 1) {\r\n            if (rangeToDestination === 1 && !options.range) {\r\n                let direction = creep.pos.getDirectionTo(destination);\r\n                if (options.returnData) {\r\n                    options.returnData.nextPos = destination;\r\n                    options.returnData.path = direction.toString();\r\n                }\r\n                return creep.move(direction);\r\n            }\r\n            return OK;\r\n        }\r\n\r\n        // initialize data object\r\n        if (!creep.memory._trav) {\r\n            delete creep.memory._travel;\r\n            creep.memory._trav = {};\r\n        }\r\n        let travelData = creep.memory._trav as TravelData;\r\n\r\n        let state = this.deserializeState(travelData, destination);\r\n\r\n        // uncomment to visualize destination\r\n        // this.circle(destination.pos, \"orange\");\r\n\r\n        // check if creep is stuck\r\n        if (this.isStuck(creep, state)) {\r\n            state.stuckCount++;\r\n            Traveler.circle(creep.pos, \"magenta\", state.stuckCount * .2);\r\n        } else {\r\n            state.stuckCount = 0;\r\n        }\r\n\r\n        // handle case where creep is stuck\r\n        if (!options.stuckValue) { options.stuckValue = DEFAULT_STUCK_VALUE; }\r\n        if (state.stuckCount >= options.stuckValue && Math.random() > .5) {\r\n            options.ignoreCreeps = false;\r\n            options.freshMatrix = true;\r\n            delete travelData.path;\r\n        }\r\n\r\n        // TODO:handle case where creep moved by some other function, but destination is still the same\r\n\r\n        // delete path cache if destination is different\r\n        if (!this.samePos(state.destination, destination)) {\r\n            if (options.movingTarget && state.destination.isNearTo(destination)) {\r\n                travelData.path = (travelData.path || \"\") + state.destination.getDirectionTo(destination);\r\n                state.destination = destination;\r\n            } else {\r\n                delete travelData.path;\r\n            }\r\n        }\r\n\r\n        if (options.repath && Math.random() < options.repath) {\r\n            // add some chance that you will find a new path randomly\r\n            delete travelData.path;\r\n        }\r\n\r\n        // pathfinding\r\n        let newPath = false;\r\n        if (!travelData.path) {\r\n            newPath = true;\r\n            if (creep.spawning) { return ERR_BUSY; }\r\n\r\n            state.destination = destination;\r\n\r\n            let cpu = Game.cpu.getUsed();\r\n            let ret = this.findTravelPath(creep.pos, destination, options);\r\n\r\n            let cpuUsed = Game.cpu.getUsed() - cpu;\r\n            state.cpu = _.round(cpuUsed + state.cpu);\r\n            if (state.cpu > REPORT_CPU_THRESHOLD) {\r\n                // see note at end of file for more info on this\r\n                console.log(`TRAVELER: heavy cpu use: ${creep.name}, cpu: ${state.cpu} origin: ${\r\n                    creep.pos}, dest: ${destination}`);\r\n            }\r\n\r\n            let color = \"orange\";\r\n            if (ret.incomplete) {\r\n                // uncommenting this is a great way to diagnose creep behavior issues\r\n                // console.log(`TRAVELER: incomplete path for ${creep.name}`);\r\n                color = \"red\";\r\n            }\r\n\r\n            if (options.returnData) {\r\n                options.returnData.pathfinderReturn = ret;\r\n            }\r\n\r\n            travelData.path = Traveler.serializePath(creep.pos, ret.path, color);\r\n            state.stuckCount = 0;\r\n        }\r\n\r\n        this.serializeState(creep, destination, state, travelData);\r\n\r\n        if (!travelData.path || travelData.path.length === 0) {\r\n            return ERR_NO_PATH;\r\n        }\r\n\r\n        // consume path\r\n        if (state.stuckCount === 0 && !newPath) {\r\n            travelData.path = travelData.path!.substr(1);\r\n        }\r\n\r\n        let nextDirection = parseInt(travelData.path![0], 10);\r\n        if (options.returnData) {\r\n            if (nextDirection) {\r\n                let nextPos = Traveler.positionAtDirection(creep.pos, nextDirection);\r\n                if (nextPos) { options.returnData.nextPos = nextPos; }\r\n            }\r\n            options.returnData.state = state;\r\n            options.returnData.path = travelData.path;\r\n        }\r\n        return creep.move(nextDirection as DirectionConstant);\r\n    }\r\n\r\n    /**\r\n     * make position objects consistent so that either can be used as an argument\r\n     * @param destination\r\n     * @returns {any}\r\n     */\r\n\r\n    public static normalizePos(destination: HasPos|RoomPosition): RoomPosition {\r\n        if (!(destination instanceof RoomPosition)) {\r\n            return destination.pos;\r\n        }\r\n        return destination;\r\n    }\r\n\r\n    /**\r\n     * check if room should be avoided by findRoute algorithm\r\n     * @param roomName\r\n     * @returns {RoomMemory|number}\r\n     */\r\n\r\n    public static checkAvoid(roomName: string) {\r\n        return Memory.rooms && Memory.rooms[roomName] && Memory.rooms[roomName].avoid;\r\n    }\r\n\r\n    /**\r\n     * check if a position is an exit\r\n     * @param pos\r\n     * @returns {boolean}\r\n     */\r\n\r\n    public static isExit(pos: Coord): boolean {\r\n        return pos.x === 0 || pos.y === 0 || pos.x === 49 || pos.y === 49;\r\n    }\r\n\r\n    /**\r\n     * check two coordinates match\r\n     * @param pos1\r\n     * @param pos2\r\n     * @returns {boolean}\r\n     */\r\n\r\n    public static sameCoord(pos1: Coord, pos2: Coord): boolean {\r\n        return pos1.x === pos2.x && pos1.y === pos2.y;\r\n    }\r\n\r\n    /**\r\n     * check if two positions match\r\n     * @param pos1\r\n     * @param pos2\r\n     * @returns {boolean}\r\n     */\r\n\r\n    public static samePos(pos1: RoomPosition, pos2: RoomPosition) {\r\n        return this.sameCoord(pos1, pos2) && pos1.roomName === pos2.roomName;\r\n    }\r\n\r\n    /**\r\n     * draw a circle at position\r\n     * @param pos\r\n     * @param color\r\n     * @param opacity\r\n     */\r\n\r\n    public static circle(pos: RoomPosition, color: string, opacity?: number) {\r\n        new RoomVisual(pos.roomName).circle(pos, {\r\n            radius: .45, fill: \"transparent\", stroke: color, strokeWidth: .15, opacity: opacity});\r\n    }\r\n\r\n    /**\r\n     * update memory on whether a room should be avoided based on controller owner\r\n     * @param room\r\n     */\r\n\r\n    public static updateRoomStatus(room: Room) {\r\n        if (!room) { return; }\r\n        if (room.controller) {\r\n            if (room.controller.owner && !room.controller.my) {\r\n                room.memory.avoid = true;\r\n            } else {\r\n                delete room.memory.avoid;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * find a path from origin to destination\r\n     * @param origin\r\n     * @param destination\r\n     * @param options\r\n     * @returns {PathfinderReturn}\r\n     */\r\n\r\n    public static findTravelPath(origin: RoomPosition|HasPos, destination: RoomPosition|HasPos,\r\n                                 options: TravelToOptions = {}): PathfinderReturn {\r\n\r\n        _.defaults(options, {\r\n            ignoreCreeps: true,\r\n            maxOps: DEFAULT_MAXOPS,\r\n            range: 1,\r\n        });\r\n\r\n        if (options.movingTarget) {\r\n            options.range = 0;\r\n        }\r\n\r\n        origin = this.normalizePos(origin);\r\n        destination = this.normalizePos(destination);\r\n        let originRoomName = origin.roomName;\r\n        let destRoomName = destination.roomName;\r\n\r\n        // check to see whether findRoute should be used\r\n        let roomDistance = Game.map.getRoomLinearDistance(origin.roomName, destination.roomName);\r\n        let allowedRooms = options.route;\r\n        if (!allowedRooms && (options.useFindRoute || (options.useFindRoute === undefined && roomDistance > 2))) {\r\n            let route = this.findRoute(origin.roomName, destination.roomName, options);\r\n            if (route) { allowedRooms = route; }\r\n        }\r\n\r\n        let roomsSearched = 0;\r\n\r\n        let callback = (roomName: string): CostMatrix | boolean => {\r\n\r\n            if (allowedRooms) {\r\n                if (!allowedRooms[roomName]) {\r\n                    return false;\r\n                }\r\n            } else if (!options.allowHostile && Traveler.checkAvoid(roomName)\r\n                && roomName !== destRoomName && roomName !== originRoomName) {\r\n                return false;\r\n            }\r\n\r\n            roomsSearched++;\r\n\r\n            let matrix;\r\n            let room = Game.rooms[roomName];\r\n            if (room) {\r\n                if (options.ignoreStructures) {\r\n                    matrix = new PathFinder.CostMatrix();\r\n                    if (!options.ignoreCreeps) {\r\n                        Traveler.addCreepsToMatrix(room, matrix);\r\n                    }\r\n                } else if (options.ignoreCreeps || roomName !== originRoomName) {\r\n                    matrix = this.getStructureMatrix(room, options.freshMatrix);\r\n                } else {\r\n                    matrix = this.getCreepMatrix(room);\r\n                }\r\n\r\n                if (options.obstacles) {\r\n                    matrix = matrix.clone();\r\n                    for (let obstacle of options.obstacles) {\r\n                        if (obstacle.pos.roomName !== roomName) { continue; }\r\n                        matrix.set(obstacle.pos.x, obstacle.pos.y, 0xff);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (options.roomCallback) {\r\n                if (!matrix) { matrix = new PathFinder.CostMatrix(); }\r\n                let outcome = options.roomCallback(roomName, matrix.clone());\r\n                if (outcome !== undefined) {\r\n                    return outcome;\r\n                }\r\n            }\r\n\r\n            return matrix as CostMatrix;\r\n        };\r\n\r\n        let ret = PathFinder.search(origin, {pos: destination, range: options.range!}, {\r\n            maxOps: options.maxOps,\r\n            maxRooms: options.maxRooms,\r\n            plainCost: options.offRoad ? 1 : options.ignoreRoads ? 1 : 2,\r\n            swampCost: options.offRoad ? 1 : options.ignoreRoads ? 5 : 10,\r\n            roomCallback: callback,\r\n        } );\r\n\r\n        if (ret.incomplete && options.ensurePath) {\r\n\r\n            if (options.useFindRoute === undefined) {\r\n\r\n                // handle case where pathfinder failed at a short distance due to not using findRoute\r\n                // can happen for situations where the creep would have to take an uncommonly indirect path\r\n                // options.allowedRooms and options.routeCallback can also be used to handle this situation\r\n                if (roomDistance <= 2) {\r\n                    console.log(`TRAVELER: path failed without findroute, trying with options.useFindRoute = true`);\r\n                    console.log(`from: ${origin}, destination: ${destination}`);\r\n                    options.useFindRoute = true;\r\n                    ret = this.findTravelPath(origin, destination, options);\r\n                    console.log(`TRAVELER: second attempt was ${ret.incomplete ? \"not \" : \"\"}successful`);\r\n                    return ret;\r\n                }\r\n\r\n                // TODO: handle case where a wall or some other obstacle is blocking the exit assumed by findRoute\r\n            } else {\r\n\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * find a viable sequence of rooms that can be used to narrow down pathfinder's search algorithm\r\n     * @param origin\r\n     * @param destination\r\n     * @param options\r\n     * @returns {{}}\r\n     */\r\n\r\n    public static findRoute(origin: string, destination: string,\r\n                            options: TravelToOptions = {}): {[roomName: string]: boolean } | void {\r\n\r\n        let restrictDistance = options.restrictDistance || Game.map.getRoomLinearDistance(origin, destination) + 10;\r\n        let allowedRooms = { [ origin ]: true, [ destination ]: true };\r\n\r\n        let highwayBias = 1;\r\n        if (options.preferHighway) {\r\n            highwayBias = 2.5;\r\n            if (options.highwayBias) {\r\n                highwayBias = options.highwayBias;\r\n            }\r\n        }\r\n\r\n        let ret = Game.map.findRoute(origin, destination, {\r\n            routeCallback: (roomName: string) => {\r\n\r\n                if (options.routeCallback) {\r\n                    let outcome = options.routeCallback(roomName);\r\n                    if (outcome !== undefined) {\r\n                        return outcome;\r\n                    }\r\n                }\r\n\r\n                let rangeToRoom = Game.map.getRoomLinearDistance(origin, roomName);\r\n                if (rangeToRoom > restrictDistance) {\r\n                    // room is too far out of the way\r\n                    return Number.POSITIVE_INFINITY;\r\n                }\r\n\r\n                if (!options.allowHostile && Traveler.checkAvoid(roomName) &&\r\n                    roomName !== destination && roomName !== origin) {\r\n                    // room is marked as \"avoid\" in room memory\r\n                    return Number.POSITIVE_INFINITY;\r\n                }\r\n\r\n                let parsed;\r\n                if (options.preferHighway) {\r\n                    parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(roomName) as any;\r\n                    let isHighway = (parsed[1] % 10 === 0) || (parsed[2] % 10 === 0);\r\n                    if (isHighway) {\r\n                        return 1;\r\n                    }\r\n                }\r\n                // SK rooms are avoided when there is no vision in the room, harvested-from SK rooms are allowed\r\n                if (!options.allowSK && !Game.rooms[roomName]) {\r\n                    if (!parsed) { parsed = /^[WE]([0-9]+)[NS]([0-9]+)$/.exec(roomName) as any; }\r\n                    let fMod = parsed[1] % 10;\r\n                    let sMod = parsed[2] % 10;\r\n                    let isSK =  !(fMod === 5 && sMod === 5) &&\r\n                        ((fMod >= 4) && (fMod <= 6)) &&\r\n                        ((sMod >= 4) && (sMod <= 6));\r\n                    if (isSK) {\r\n                        return 10 * highwayBias;\r\n                    }\r\n                }\r\n\r\n                return highwayBias;\r\n            },\r\n        });\r\n\r\n        if (!_.isArray(ret)) {\r\n            console.log(`couldn't findRoute to ${destination}`);\r\n            return;\r\n        }\r\n        for (let value of ret as any[]) {\r\n            allowedRooms[value.room] = true;\r\n        }\r\n\r\n        return allowedRooms;\r\n    }\r\n\r\n    /**\r\n     * check how many rooms were included in a route returned by findRoute\r\n     * @param origin\r\n     * @param destination\r\n     * @returns {number}\r\n     */\r\n\r\n    public static routeDistance(origin: string, destination: string): number | void {\r\n        let linearDistance = Game.map.getRoomLinearDistance(origin, destination);\r\n        if (linearDistance >= 32) {\r\n            return linearDistance;\r\n        }\r\n\r\n        let allowedRooms = this.findRoute(origin, destination);\r\n        if (allowedRooms) {\r\n            return Object.keys(allowedRooms).length;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * build a cost matrix based on structures in the room. Will be cached for more than one tick. Requires vision.\r\n     * @param room\r\n     * @param freshMatrix\r\n     * @returns {any}\r\n     */\r\n\r\n    public static getStructureMatrix(room: Room, freshMatrix?: boolean): CostMatrix {\r\n        if (!this.structureMatrixCache[room.name] || (freshMatrix && Game.time !== this.structureMatrixTick)) {\r\n            this.structureMatrixTick = Game.time;\r\n            let matrix = new PathFinder.CostMatrix();\r\n            this.structureMatrixCache[room.name] = Traveler.addStructuresToMatrix(room, matrix, 1);\r\n        }\r\n        return this.structureMatrixCache[room.name];\r\n    }\r\n\r\n    /**\r\n     * build a cost matrix based on creeps and structures in the room. Will be cached for one tick. Requires vision.\r\n     * @param room\r\n     * @returns {any}\r\n     */\r\n\r\n    public static getCreepMatrix(room: Room) {\r\n        if (!this.creepMatrixCache[room.name] || Game.time !== this.creepMatrixTick) {\r\n            this.creepMatrixTick = Game.time;\r\n            this.creepMatrixCache[room.name] = Traveler.addCreepsToMatrix(room,\r\n                this.getStructureMatrix(room, true).clone());\r\n        }\r\n        return this.creepMatrixCache[room.name];\r\n    }\r\n\r\n    /**\r\n     * add structures to matrix so that impassible structures can be avoided and roads given a lower cost\r\n     * @param room\r\n     * @param matrix\r\n     * @param roadCost\r\n     * @returns {CostMatrix}\r\n     */\r\n\r\n    public static addStructuresToMatrix(room: Room, matrix: CostMatrix, roadCost: number): CostMatrix {\r\n\r\n        let impassibleStructures: any[] = [];\r\n        for (let structure of room.find<any>(FIND_STRUCTURES)) {\r\n            if (structure instanceof StructureRampart) {\r\n                if (!structure.my && !structure.isPublic) {\r\n                    impassibleStructures.push(structure);\r\n                }\r\n            } else if (structure instanceof StructureRoad) {\r\n                matrix.set(structure.pos.x, structure.pos.y, roadCost);\r\n            } else if (structure instanceof StructureContainer) {\r\n                matrix.set(structure.pos.x, structure.pos.y, 5);\r\n            } else if (!(structure instanceof ConstructionSite)) {\r\n                impassibleStructures.push(structure as any);\r\n            }\r\n        }\r\n\r\n        for (let site of room.find<any>(114 as any)) {\r\n            if (site instanceof ConstructionSite) {\r\n                if (site.structureType === STRUCTURE_CONTAINER || site.structureType === STRUCTURE_ROAD\r\n                    || site.structureType === STRUCTURE_RAMPART) { continue; }\r\n                matrix.set(site.pos.x, site.pos.y, 0xff);\r\n            }\r\n        }\r\n\r\n        for (let structure of impassibleStructures) {\r\n            matrix.set(structure.pos.x, structure.pos.y, 0xff);\r\n        }\r\n\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * add creeps to matrix so that they will be avoided by other creeps\r\n     * @param room\r\n     * @param matrix\r\n     * @returns {CostMatrix}\r\n     */\r\n\r\n    public static addCreepsToMatrix(room: Room, matrix: CostMatrix): CostMatrix {\r\n        room.find<any>(101 as any).forEach((creep: any) => matrix.set(creep.pos.x, creep.pos.y, 0xff) );\r\n        return matrix;\r\n    }\r\n\r\n    /**\r\n     * serialize a path, traveler style. Returns a string of directions.\r\n     * @param startPos\r\n     * @param path\r\n     * @param color\r\n     * @returns {string}\r\n     */\r\n\r\n    public static serializePath(startPos: RoomPosition, path: RoomPosition[], color = \"orange\"): string {\r\n        let serializedPath = \"\";\r\n        let lastPosition = startPos;\r\n        this.circle(startPos, color);\r\n        for (let position of path) {\r\n            if (position.roomName === lastPosition.roomName) {\r\n                new RoomVisual(position.roomName)\r\n                    .line(position, lastPosition, {color: color, lineStyle: \"dashed\"});\r\n                serializedPath += lastPosition.getDirectionTo(position);\r\n            }\r\n            lastPosition = position;\r\n        }\r\n        return serializedPath;\r\n    }\r\n\r\n    /**\r\n     * returns a position at a direction relative to origin\r\n     * @param origin\r\n     * @param direction\r\n     * @returns {RoomPosition}\r\n     */\r\n\r\n    public static positionAtDirection(origin: RoomPosition, direction: number): RoomPosition | void {\r\n        let offsetX = [0, 0, 1, 1, 1, 0, -1, -1, -1];\r\n        let offsetY = [0, -1, -1, 0, 1, 1, 1, 0, -1];\r\n        let x = origin.x + offsetX[direction];\r\n        let y = origin.y + offsetY[direction];\r\n        if (x > 49 || x < 0 || y > 49 || y < 0) { return; }\r\n        return new RoomPosition(x, y, origin.roomName);\r\n    }\r\n\r\n    /**\r\n     * convert room avoidance memory from the old pattern to the one currently used\r\n     * @param cleanup\r\n     */\r\n\r\n    public static patchMemory(cleanup = false) {\r\n        if (!Memory.empire) { return; }\r\n        if (!(Memory.empire as any).hostileRooms) { return; }\r\n        let count = 0;\r\n        for (let roomName in (Memory.empire as any).hostileRooms) {\r\n            if ((Memory.empire as any).hostileRooms[roomName]) {\r\n                if (!Memory.rooms[roomName]) { Memory.rooms[roomName] = {} as any; }\r\n                Memory.rooms[roomName].avoid = true;\r\n                count++;\r\n            }\r\n            if (cleanup) {\r\n                delete (Memory.empire as any).hostileRooms[roomName];\r\n            }\r\n        }\r\n        if (cleanup) {\r\n            delete (Memory.empire as any).hostileRooms;\r\n        }\r\n\r\n        console.log(`TRAVELER: room avoidance data patched for ${count} rooms`);\r\n    }\r\n\r\n    private static deserializeState(travelData: TravelData, destination: RoomPosition): TravelState {\r\n        let state = {} as TravelState;\r\n        if (travelData.state) {\r\n            state.lastCoord = {x: travelData.state[STATE_PREV_X], y: travelData.state[STATE_PREV_Y] };\r\n            state.cpu = travelData.state[STATE_CPU];\r\n            state.stuckCount = travelData.state[STATE_STUCK];\r\n            state.destination = new RoomPosition(travelData.state[STATE_DEST_X], travelData.state[STATE_DEST_Y],\r\n                travelData.state[STATE_DEST_ROOMNAME]);\r\n        } else {\r\n            state.cpu = 0;\r\n            state.destination = destination;\r\n        }\r\n        return state;\r\n    }\r\n\r\n    private static serializeState(creep: Creep, destination: RoomPosition, state: TravelState, travelData: TravelData) {\r\n        travelData.state = [creep.pos.x, creep.pos.y, state.stuckCount, state.cpu, destination.x, destination.y,\r\n            destination.roomName];\r\n    }\r\n\r\n    private static isStuck(creep: Creep, state: TravelState): boolean {\r\n        let stuck = false;\r\n        if (state.lastCoord !== undefined) {\r\n            if (this.sameCoord(creep.pos, state.lastCoord)) {\r\n                // didn't move\r\n                stuck = true;\r\n            } else if (this.isExit(creep.pos) && this.isExit(state.lastCoord)) {\r\n                // moved against exit\r\n                stuck = true;\r\n            }\r\n        }\r\n\r\n        return stuck;\r\n    }\r\n}\r\n\r\n// this might be higher than you wish, setting it lower is a great way to diagnose creep behavior issues. When creeps\r\n// need to repath to often or they aren't finding valid paths, it can sometimes point to problems elsewhere in your code\r\nconst REPORT_CPU_THRESHOLD = 1000;\r\n\r\nconst DEFAULT_MAXOPS = 20000;\r\nconst DEFAULT_STUCK_VALUE = 2;\r\nconst STATE_PREV_X = 0;\r\nconst STATE_PREV_Y = 1;\r\nconst STATE_STUCK = 2;\r\nconst STATE_CPU = 3;\r\nconst STATE_DEST_X = 4;\r\nconst STATE_DEST_Y = 5;\r\nconst STATE_DEST_ROOMNAME = 6;\r\n\r\n// assigns a function to Creep.prototype: creep.travelTo(destination)\r\nCreep.prototype.travelTo = function(destination: RoomPosition|{pos: RoomPosition}, options?: TravelToOptions) {\r\n    return Traveler.travelTo(this, destination, options);\r\n};","/**\r\n * CONSOLE COMMAND SYSTEM\r\n * \r\n * Provides a comprehensive command-line interface for controlling your colony.\r\n * All commands are called via console.log and global functions.\r\n * \r\n * Usage:\r\n * ```\r\n * > help()                          // Show all commands\r\n * > status()                        // Full colony status\r\n * > status('W1N1')                  // Room-specific status\r\n * > spawn('miner', 'W1N1')          // Spawn a role in a room\r\n * > despawn('creep_name')           // Delete a creep\r\n * > pos(10, 20, 'W1N1')             // Go to position\r\n * > memory()                        // View full memory\r\n * > memory('creep_name')            // View creep memory\r\n * > config()                        // View behavior config\r\n * ```\r\n */\r\n\r\nimport {\r\n  getBehaviorConfig,\r\n  getSpawnRequests,\r\n  getSpawnStatus\r\n} from '../world/creeps';\r\n\r\nimport {\r\n  setMode,\r\n  displayModeInfo\r\n} from '../world/empire';\r\n\r\nimport {\r\n  getTask,\r\n  assignTask,\r\n  clearTask,\r\n  createHarvestTask,\r\n  createDeliverTask,\r\n  createBuildTask,\r\n  createUpgradeTask,\r\n  createMoveTask,\r\n  createRepairTask,\r\n  createIdleTask,\r\n  getTaskDescription\r\n} from '../world/creeps/tasks';\r\n\r\nimport {\r\n  scanRoom,\r\n  lockStructure,\r\n  unlockStructure,\r\n  getLockedStructures,\r\n  listStructures,\r\n  renameStructure,\r\n  showNames as visualShowNames,\r\n  hideNames as visualHideNames,\r\n  getRoomAssignments,\r\n  listLegaAssignments,\r\n  getLegaStatus\r\n} from '../world';\r\n\r\nimport {\r\n  registerBody,\r\n  getBodyConfig,\r\n  listBodyConfigs,\r\n  getBodyCost\r\n} from '../world/spawns/bodies';\r\n\r\n/**\r\n * Get the current room (first owned room, or first room with a creep)\r\n */\r\nfunction getCurrentRoom(): string | null {\r\n  // Try to find a room with a creep first (most likely user context)\r\n  for (const creep of Object.values(Game.creeps)) {\r\n    if (creep.room?.controller?.my) {\r\n      return creep.room.name;\r\n    }\r\n  }\r\n\r\n  // Fall back to first owned room\r\n  for (const room of Object.values(Game.rooms)) {\r\n    if (room.controller?.my) {\r\n      return room.name;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Generate an auto-incremented name for a creep based on role\r\n * \r\n * @param role - The role name (e.g., 'harvester', 'hauler')\r\n * @returns Auto-generated name (e.g., 'H1', 'H2', 'U1', 'B1')\r\n */\r\nfunction generateCreepName(role: string): string {\r\n  // Get role abbreviation (first letter, uppercase)\r\n  const abbr = role.charAt(0).toUpperCase();\r\n  \r\n  // Find highest existing number for this role\r\n  let maxNum = 0;\r\n  const pattern = new RegExp(`^${abbr}(\\\\d+)$`);\r\n  \r\n  for (const creep of Object.values(Game.creeps)) {\r\n    const match = creep.name.match(pattern);\r\n    if (match) {\r\n      const num = parseInt(match[1], 10);\r\n      if (num > maxNum) {\r\n        maxNum = num;\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Return next number\r\n  return `${abbr}${maxNum + 1}`;\r\n}\r\n\r\n/**\r\n * Print a formatted header\r\n */\r\nfunction header(text: string): void {\r\n  console.log(`\\n${'═'.repeat(60)}`);\r\n  console.log(`║ ${text.padEnd(58)} ║`);\r\n  console.log(`${'═'.repeat(60)}\\n`);\r\n}\r\n\r\n/**\r\n * Print a section separator\r\n */\r\nfunction section(text: string): void {\r\n  console.log(`\\n${'─'.repeat(60)}`);\r\n  console.log(`${text}`);\r\n  console.log(`${'─'.repeat(60)}`);\r\n}\r\n\r\n/**\r\n * HELP - Display all available commands\r\n * \r\n * @example help()\r\n */\r\nexport function help(): void {\r\n  header('SCREEPS CONSOLE COMMANDS');\r\n\r\n  section('VIEWING STATUS');\r\n  console.log('  status()             - Full colony status (all rooms)');\r\n  console.log('  status(roomName)     - Status for specific room');\r\n  console.log('  memory()             - View full Memory object');\r\n  console.log('  memory(creepName)    - View specific creep memory');\r\n  console.log('  config()             - View behavior configuration');\r\n\r\n  section('SPAWNING & CREEPS');\r\n  console.log('  spawn(role)                      - Spawn a creep (auto-name, current room)');\r\n  console.log('  spawn(role, room)                - Spawn a creep (auto-name)');\r\n  console.log('  spawnCreep(name, role, body)     - Spawn with name & body (current room)');\r\n  console.log('  spawnCreep(name, role, body, room) - Spawn with name & body');\r\n  console.log('  spawnWith(role, body, task, target) - Spawn AND assign task (one command)');\r\n  console.log('  spawnWith(role, body, task, target, room) - Spawn & task in specific room');\r\n  console.log('  despawn(creepName)               - Delete a creep');\r\n  console.log('  creeps(room?)                    - List all creeps (or by room)');\r\n\r\n  section('BODY CONFIGURATIONS');\r\n  console.log('  bodies()             - List all registered body configs');\r\n  console.log('  bodies(role)         - List bodies for a role');\r\n  console.log('  regBody(name, arr, role) - Register a body config');\r\n\r\n  section('MOVEMENT & TARGETING');\r\n  console.log('  goto(x, y, room)     - Move all creeps to position');\r\n  console.log('  goto(target)         - Go to creep/structure/source');\r\n\r\n  section('TASK ASSIGNMENT');\r\n  console.log('  task(name, type, id) - Assign task to creep');\r\n  console.log('  tasks()              - View all assigned tasks');\r\n  console.log('  tasks(room)          - View tasks in room');\r\n  console.log('  untask(name)         - Clear task from creep');\r\n  console.log('');\r\n  console.log('  Task types: harvest, deliver, build, upgrade, repair, move, idle');\r\n  console.log('  Example: task(\"miner_1\", \"harvest\", \"SourceA\")');\r\n  console.log('  Quick spawn+task: spawnWith(\"miner\", [WORK, WORK, CARRY, MOVE], \"harvest\", \"SourceA\")');\r\n\r\n  section('STRUCTURE REGISTRY');\r\n  console.log('  scan()               - Scan current room structures (or all if none)');\r\n  console.log('  scan(room)           - Register structures in a room');\r\n  console.log('  structures()         - List all registered structures');\r\n  console.log('  structures(room)     - List structures in a room');\r\n  console.log('  rename(old, new)     - Rename a structure');\r\n\r\n  section('STRUCTURE LOCKING');\r\n  console.log('  lock(name)           - Lock a structure (prevent actions)');\r\n  console.log('  unlock(name)         - Unlock a structure');\r\n  console.log('  locked()             - View all locked structures');\r\n  console.log('  locked(room)         - View locked structures in room');\r\n\r\n  section('VISUAL LABELS');\r\n  console.log('  showNames()          - Display labels on current room (3 ticks)');\r\n  console.log('  showNames(room)      - Display structure names on map (3 ticks)');\r\n  console.log('  showNames(room, dur) - Display labels for duration ticks');\r\n  console.log('  hideNames()          - Hide labels on current room');\r\n  console.log('  hideNames(room)      - Hide structure name displays');\r\n\r\n  section('LEGATUS COMMANDS');\r\n  console.log('  legaStatus()         - Show Legatus assignments (current room)');\r\n  console.log('  legaStatus(room)     - Show Legatus assignments in room');\r\n  console.log('  legaList()           - List all assignments (current room)');\r\n  console.log('  legaList(room)       - List all assignments in room');\r\n\r\n  section('ROOM MANAGEMENT');\r\n  console.log('  rooms()              - List all owned rooms');\r\n  console.log('  room(name)           - Get Room object');\r\n\r\n  section('BUILDING & CONSTRUCTION');\r\n  console.log('  plan()               - Show construction plan');\r\n  console.log('  build(structType)    - Plan a structure to build');\r\n  console.log('  cancel()             - Cancel construction sites');\r\n\r\n  section('DEBUGGING');\r\n  console.log('  flag(x, y, room)     - Place a flag (for visual reference)');\r\n  console.log('  clear()              - Clear console output');\r\n\r\n  section('EMPIRE MODE');\r\n  console.log('  mode()               - Display current empire mode');\r\n  console.log('  mode(\"command\")      - Switch to COMMAND mode (direct control)');\r\n  console.log('  mode(\"delegate\")     - Switch to DELEGATE mode (automatic AI)');\r\n\r\n  console.log('\\n💡 Most room-based commands default to current room if not specified\\n');\r\n}\r\n\r\n/**\r\n * STATUS - Display colony-wide status\r\n * \r\n * @param roomName - Optional: show only this room\r\n * @example status()\r\n * @example status('W1N1')\r\n */\r\nexport function status(roomName?: string): void {\r\n  const rooms = roomName ? [Game.rooms[roomName]] : Object.values(Game.rooms);\r\n  const ownedRooms = rooms.filter(r => r.controller?.my);\r\n\r\n  if (ownedRooms.length === 0) {\r\n    console.log('⚠️  No rooms under control');\r\n    return;\r\n  }\r\n\r\n  header('COLONY STATUS');\r\n\r\n  for (const room of ownedRooms) {\r\n    section(`Room: ${room.name} | RCL: ${room.controller?.level || 0}`);\r\n\r\n    // Room stats\r\n    console.log(`Progress: ${room.controller?.progress || 0}/${room.controller?.progressTotal || 0}`);\r\n    console.log(`Energy: ${room.energyAvailable}/${room.energyCapacityAvailable}`);\r\n\r\n    // Creep composition\r\n    console.log(`\\n📋 Creep Status:`);\r\n    console.log(getSpawnStatus(room));\r\n\r\n    // Spawn requests\r\n    const requests = getSpawnRequests(room);\r\n    if (requests.length > 0) {\r\n      console.log(`\\n🔄 Next to spawn: ${requests[0].reason}`);\r\n    }\r\n\r\n    // Structures\r\n    const spawns = room.find(FIND_MY_SPAWNS);\r\n    const extensions = room.find(FIND_MY_STRUCTURES, {\r\n      filter: s => s.structureType === STRUCTURE_EXTENSION\r\n    });\r\n    console.log(`\\n🏗️  Structures: ${spawns.length} spawn(s), ${extensions.length} extension(s)`);\r\n\r\n    // Construction sites\r\n    const sites = room.find(FIND_MY_CONSTRUCTION_SITES);\r\n    if (sites.length > 0) {\r\n      console.log(`⚙️  Construction: ${sites.length} site(s)`);\r\n    }\r\n  }\r\n\r\n  console.log();\r\n}\r\n\r\n/**\r\n * SPAWN - Spawn a creep of a given role\r\n * \r\n * @param role - Role name (miner, upgrader, builder)\r\n * @param roomName - Optional: Room to spawn in (defaults to current room)\r\n * @returns The new creep, or false if failed\r\n * \r\n * @example spawn('miner', 'W1N1')\r\n * @example spawn('miner')\r\n */\r\nexport function spawn(role: string, roomName?: string): Creep | false {\r\n  const targetRoom = roomName || getCurrentRoom();\r\n  if (!targetRoom) {\r\n    console.log(`❌ No room specified and no current room found`);\r\n    return false;\r\n  }\r\n\r\n  const room = Game.rooms[targetRoom];\r\n  if (!room) {\r\n    console.log(`❌ Room not found: ${targetRoom}`);\r\n    return false;\r\n  }\r\n\r\n  const config = getBehaviorConfig(room.controller?.level || 1);\r\n  const roleConfig = config.roles.find(r => r.name === role);\r\n\r\n  if (!roleConfig) {\r\n    console.log(`❌ Unknown role: ${role}`);\r\n    console.log(`Available roles: ${config.roles.map(r => r.name).join(', ')}`);\r\n    return false;\r\n  }\r\n\r\n  const spawns = room.find(FIND_MY_SPAWNS);\r\n  if (spawns.length === 0) {\r\n    console.log(`❌ No spawns in room`);\r\n    return false;\r\n  }\r\n\r\n  const spawn = spawns[0];\r\n  const creepName = `${role}_${Game.time}`;\r\n\r\n  const result = spawn.spawnCreep(roleConfig.body, creepName, {\r\n    memory: {\r\n      role,\r\n      room: targetRoom,\r\n      working: false\r\n    }\r\n  });\r\n\r\n  if (result === OK) {\r\n    console.log(`✅ Spawned ${creepName}`);\r\n    return Game.creeps[creepName];\r\n  } else {\r\n    console.log(`❌ Spawn failed: ${result}`);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * DESPAWN - Delete a creep\r\n * \r\n * @param creepName - Name of creep to delete\r\n * @example despawn('miner_12345')\r\n */\r\nexport function despawn(creepName: string): void {\r\n  const creep = Game.creeps[creepName];\r\n  if (!creep) {\r\n    console.log(`❌ Creep not found: ${creepName}`);\r\n    return;\r\n  }\r\n\r\n  creep.suicide();\r\n  console.log(`💀 Killed ${creepName}`);\r\n}\r\n\r\n/**\r\n * SPAWNCREEP - Spawn a creep with specific name and body configuration\r\n * \r\n * @param creepName - Custom name for the creep (e.g., 'Harvester1'), or omit to auto-generate\r\n * @param role - Role name (harvester, upgrader, builder)\r\n * @param bodyTypeOrArray - Body config name (e.g., 'harvester_basic') or array of parts\r\n * @param roomName - Optional: Room to spawn in (defaults to current room)\r\n * @returns The new creep, or false if failed\r\n * \r\n * @example spawnCreep('M1', 'miner', [WORK, WORK, MOVE]) - Named\r\n * @example spawnCreep('miner', [WORK, WORK, MOVE]) - Auto-named (generates M1, M2, etc)\r\n * @example spawnCreep('upgrader', [WORK, CARRY, MOVE], 'W1N1') - Auto-named in specific room\r\n */\r\nexport function spawnCreep(\r\n  creepNameOrRole: string,\r\n  roleOrBody?: string | BodyPartConstant[],\r\n  bodyOrRoom?: string | BodyPartConstant[],\r\n  roomName?: string\r\n): Creep | false {\r\n  // Handle overloaded parameters\r\n  // Case 1: spawnCreep(name, role, body, room?) - explicit name\r\n  // Case 2: spawnCreep(role, body, room?) - auto-generate name\r\n  let creepName: string;\r\n  let role: string;\r\n  let bodyTypeOrArray: string | BodyPartConstant[];\r\n  let targetRoomName: string | undefined;\r\n\r\n  if (roleOrBody === undefined || Array.isArray(roleOrBody)) {\r\n    // Case 2: Auto-generate name\r\n    role = creepNameOrRole;\r\n    bodyTypeOrArray = roleOrBody || [];\r\n    targetRoomName = bodyOrRoom as string | undefined;\r\n    creepName = generateCreepName(role);\r\n  } else {\r\n    // Case 1: Explicit name\r\n    creepName = creepNameOrRole;\r\n    role = roleOrBody;\r\n    bodyTypeOrArray = bodyOrRoom || [];\r\n    targetRoomName = roomName;\r\n  }\r\n\r\n  const targetRoom = targetRoomName || getCurrentRoom();\r\n  if (!targetRoom) {\r\n    console.log(`❌ No room specified and no current room found`);\r\n    return false;\r\n  }\r\n\r\n  const room = Game.rooms[targetRoom];\r\n  if (!room) {\r\n    console.log(`❌ Room not found: ${targetRoom}`);\r\n    return false;\r\n  }\r\n\r\n  // Get body parts\r\n  const bodyParts = getBodyConfig(bodyTypeOrArray);\r\n  if (!bodyParts || bodyParts.length === 0) {\r\n    console.log(`❌ Invalid body config: ${bodyTypeOrArray}`);\r\n    console.log(`Available bodies: `);\r\n    listBodyConfigs();\r\n    return false;\r\n  }\r\n\r\n  // Check if name is already taken\r\n  if (Game.creeps[creepName]) {\r\n    console.log(`❌ Creep name already exists: ${creepName}`);\r\n    return false;\r\n  }\r\n\r\n  // Find spawn\r\n  const spawns = room.find(FIND_MY_SPAWNS);\r\n  if (spawns.length === 0) {\r\n    console.log(`❌ No spawns in room`);\r\n    return false;\r\n  }\r\n\r\n  const spawnObj = spawns[0];\r\n\r\n  // Attempt spawn\r\n  const result = spawnObj.spawnCreep(bodyParts, creepName, {\r\n    memory: {\r\n      role,\r\n      room: targetRoom,\r\n      working: false\r\n    }\r\n  });\r\n\r\n  if (result === OK) {\r\n    const cost = getBodyCost(bodyParts);\r\n    console.log(`✅ Spawned ${creepName} (${bodyParts.length} parts, ${cost}E)`);\r\n    return Game.creeps[creepName];\r\n  } else {\r\n    const errorMsg = {\r\n      [ERR_NOT_OWNER]: 'Not your spawn',\r\n      [ERR_NAME_EXISTS]: 'Name already exists',\r\n      [ERR_INVALID_ARGS]: 'Invalid body parts',\r\n      [ERR_NOT_ENOUGH_ENERGY]: `Not enough energy (need ${getBodyCost(bodyParts)}E)`\r\n    }[result as number] || `Error code ${result}`;\r\n    \r\n    console.log(`❌ Spawn failed: ${errorMsg}`);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * CREEPS - List all creeps (optionally filtered by room)\r\n * \r\n * @param roomName - Optional: filter by room\r\n * @example creeps()\r\n * @example creeps('W1N1')\r\n */\r\nexport function creeps(roomName?: string): void {\r\n  const allCreeps = Object.values(Game.creeps);\r\n  const filtered = roomName\r\n    ? allCreeps.filter(c => c.memory.room === roomName)\r\n    : allCreeps;\r\n\r\n  if (filtered.length === 0) {\r\n    console.log('⚠️  No creeps found');\r\n    return;\r\n  }\r\n\r\n  section(`CREEPS (${filtered.length} total)`);\r\n\r\n  for (const creep of filtered) {\r\n    const energy = `${creep.store.getUsedCapacity(RESOURCE_ENERGY)}/${creep.store.getCapacity(RESOURCE_ENERGY)}`;\r\n    const working = creep.memory.working ? '🔨' : '⛏️';\r\n    console.log(`  ${creep.name.padEnd(30)} | Role: ${creep.memory.role?.padEnd(10) || 'unknown'} | Energy: ${energy} | ${working}`);\r\n  }\r\n\r\n  console.log();\r\n}\r\n\r\n/**\r\n * MEMORY - View memory structure\r\n * \r\n * @param key - Optional: view specific key (creep name or memory path)\r\n * @example memory()\r\n * @example memory('miner_12345')\r\n */\r\nexport function memory(key?: string): void {\r\n  if (!key) {\r\n    console.log(JSON.stringify(Memory, null, 2));\r\n    return;\r\n  }\r\n\r\n  // Try to find creep memory\r\n  if (key in Memory.creeps) {\r\n    console.log(JSON.stringify(Memory.creeps[key], null, 2));\r\n    return;\r\n  }\r\n\r\n  // Try as direct memory path\r\n  const value = (Memory as any)[key];\r\n  if (value !== undefined) {\r\n    console.log(JSON.stringify(value, null, 2));\r\n    return;\r\n  }\r\n\r\n  console.log(`⚠️  Key not found: ${key}`);\r\n}\r\n\r\n/**\r\n * CONFIG - Display current behavior configuration\r\n * \r\n * @example config()\r\n * @example config(1)  // for RCL 1\r\n */\r\nexport function config(rcl?: number): void {\r\n  if (rcl === undefined) {\r\n    // Show configs for all controlled rooms\r\n    for (const room of Object.values(Game.rooms)) {\r\n      if (room.controller?.my) {\r\n        config(room.controller.level);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  const cfg = getBehaviorConfig(rcl);\r\n  section(`BEHAVIOR CONFIG - RCL ${rcl}`);\r\n  console.log(`Name: ${cfg.name}`);\r\n  console.log(`Description: ${cfg.description}\\n`);\r\n  console.log('Roles:');\r\n\r\n  for (const role of cfg.roles) {\r\n    console.log(`  ${role.name.padEnd(15)} | Priority: ${role.priority.toString().padEnd(3)} | Target: ${role.targetCount} | Body: ${role.body.join(',')}`);\r\n  }\r\n\r\n  console.log();\r\n}\r\n\r\n/**\r\n * ROOMS - List all owned rooms\r\n * \r\n * @example rooms()\r\n */\r\nexport function rooms(): void {\r\n  const ownedRooms = Object.values(Game.rooms).filter(r => r.controller?.my);\r\n\r\n  if (ownedRooms.length === 0) {\r\n    console.log('⚠️  No rooms under control');\r\n    return;\r\n  }\r\n\r\n  section(`OWNED ROOMS (${ownedRooms.length})`);\r\n\r\n  for (const room of ownedRooms) {\r\n    const creepCount = room.find(FIND_MY_CREEPS).length;\r\n    const spawnCount = room.find(FIND_MY_SPAWNS).length;\r\n    console.log(`  ${room.name.padEnd(10)} | RCL: ${room.controller?.level} | Energy: ${room.energyAvailable}/${room.energyCapacityAvailable} | Creeps: ${creepCount} | Spawns: ${spawnCount}`);\r\n  }\r\n\r\n  console.log();\r\n}\r\n\r\n/**\r\n * ROOM - Get a room object by name\r\n * \r\n * @param name - Room name (e.g., 'W1N1')\r\n * @example room('W1N1')\r\n */\r\nexport function room(name: string): Room | null {\r\n  const r = Game.rooms[name];\r\n  if (!r) {\r\n    console.log(`❌ Room not found: ${name}`);\r\n    return null;\r\n  }\r\n  return r;\r\n}\r\n\r\n/**\r\n * GOTO - Move all creeps to a target position\r\n * \r\n * @param target - Target room position, creep name, or structure\r\n * @example goto(new RoomPosition(25, 25, 'W1N1'))\r\n * @example goto('W1N1', 25, 25)\r\n */\r\nexport function goto(x: number | RoomPosition | string, y?: number, roomName?: string): void {\r\n  let pos: RoomPosition;\r\n\r\n  if (x instanceof RoomPosition) {\r\n    pos = x;\r\n  } else if (typeof x === 'string' && y !== undefined && roomName !== undefined) {\r\n    pos = new RoomPosition(y, roomName as unknown as number, x);\r\n  } else if (typeof x === 'string') {\r\n    // Try to find creep or structure\r\n    const creep = Game.creeps[x];\r\n    if (creep) {\r\n      pos = creep.pos;\r\n    } else {\r\n      console.log(`❌ Target not found: ${x}`);\r\n      return;\r\n    }\r\n  } else {\r\n    console.log('❌ Invalid arguments');\r\n    return;\r\n  }\r\n\r\n  const creeps = Object.values(Game.creeps);\r\n  console.log(`📍 Moving ${creeps.length} creeps to ${pos.x},${pos.y} in ${pos.roomName}`);\r\n\r\n  for (const creep of creeps) {\r\n    creep.travelTo(pos);\r\n  }\r\n}\r\n\r\n/**\r\n * FLAG - Place a flag at a position (for visual reference)\r\n * \r\n * @param x - X coordinate\r\n * @param y - Y coordinate\r\n * @param roomName - Room name\r\n * @example flag(25, 25, 'W1N1')\r\n */\r\nexport function flag(x: number, y: number, roomName: string): void {\r\n  const flagName = `flag_${Game.time}`;\r\n  const result = Game.flags[flagName] ? Game.flags[flagName].remove() : OK;\r\n\r\n  if (result === OK || result === ERR_NOT_FOUND) {\r\n    Game.map.visual.circle(new RoomPosition(x, y, roomName), { radius: 0.5, stroke: 'red' });\r\n    console.log(`🚩 Flag placed at ${x},${y} in ${roomName}`);\r\n  }\r\n}\r\n\r\n/**\r\n * CLEAR - Clear console history\r\n * \r\n * @example clear()\r\n */\r\nexport function clear(): void {\r\n  console.clear?.();\r\n  console.log('✨ Console cleared');\r\n}\r\n\r\n/**\r\n * MODE - Display or switch empire mode\r\n * \r\n * @param newMode - Optional: 'command' or 'delegate' to switch modes\r\n * @example mode()\r\n * @example mode('command')\r\n * @example mode('delegate')\r\n */\r\nexport function mode(newMode?: 'command' | 'delegate'): void {\r\n  if (newMode) {\r\n    const changed = setMode(newMode);\r\n    if (changed) {\r\n      displayModeInfo();\r\n      console.log(`✅ Empire mode switched to ${newMode.toUpperCase()}`);\r\n    } else {\r\n      console.log(`⚠️  Already in ${newMode} mode`);\r\n    }\r\n  } else {\r\n    displayModeInfo();\r\n  }\r\n}\r\n\r\n/**\r\n * TASK - Assign a task to a creep\r\n * \r\n * @param creepName - Name of creep to assign task to\r\n * @param taskType - Type of task: harvest, deliver, build, upgrade, move, repair, idle\r\n * @param targetId - Target ID (for harvest, deliver, build, repair)\r\n * @example task('miner_123', 'harvest', 'abc123def')\r\n * @example task('miner_123', 'upgrade')\r\n * @example task('miner_123', 'move', '25:20:W1N1')\r\n */\r\nexport function task(creepName: string, taskType: string, targetId?: string): void {\r\n  const creep = Game.creeps[creepName];\r\n  if (!creep) {\r\n    console.log(`❌ Creep not found: ${creepName}`);\r\n    return;\r\n  }\r\n\r\n  let t: any;\r\n\r\n  switch (taskType.toLowerCase()) {\r\n    case 'harvest':\r\n      if (!targetId) {\r\n        console.log('❌ harvest requires target source ID');\r\n        return;\r\n      }\r\n      t = createHarvestTask(targetId);\r\n      break;\r\n\r\n    case 'deliver':\r\n      if (!targetId) {\r\n        console.log('❌ deliver requires target structure ID');\r\n        return;\r\n      }\r\n      t = createDeliverTask(targetId);\r\n      break;\r\n\r\n    case 'build':\r\n      if (!targetId) {\r\n        console.log('❌ build requires target site ID');\r\n        return;\r\n      }\r\n      t = createBuildTask(targetId);\r\n      break;\r\n\r\n    case 'upgrade':\r\n      t = createUpgradeTask();\r\n      break;\r\n\r\n    case 'move': {\r\n      if (!targetId) {\r\n        console.log('❌ move requires target position (x:y:roomName)');\r\n        return;\r\n      }\r\n      const parts = targetId.split(':');\r\n      if (parts.length !== 3) {\r\n        console.log('❌ move format: x:y:roomName (e.g., 25:20:W1N1)');\r\n        return;\r\n      }\r\n      const [x, y, roomName] = parts;\r\n      t = createMoveTask(parseInt(x), parseInt(y), roomName);\r\n      break;\r\n    }\r\n\r\n    case 'repair':\r\n      if (!targetId) {\r\n        console.log('❌ repair requires target structure ID');\r\n        return;\r\n      }\r\n      t = createRepairTask(targetId);\r\n      break;\r\n\r\n    case 'idle':\r\n      t = createIdleTask();\r\n      break;\r\n\r\n    default:\r\n      console.log(`❌ Unknown task type: ${taskType}`);\r\n      console.log('Available: harvest, deliver, build, upgrade, move, repair, idle');\r\n      return;\r\n  }\r\n\r\n  assignTask(creep, t);\r\n  console.log(`✅ Assigned task to ${creepName}: ${getTaskDescription(t)}`);\r\n}\r\n\r\n/**\r\n * TASKS - View tasks assigned to creeps\r\n * \r\n * @param roomName - Optional: filter by room\r\n * @example tasks()\r\n * @example tasks('W1N1')\r\n */\r\nexport function tasks(roomName?: string): void {\r\n  const allCreeps = Object.values(Game.creeps);\r\n  const filtered = roomName\r\n    ? allCreeps.filter(c => c.memory.room === roomName)\r\n    : allCreeps;\r\n\r\n  const withTasks = filtered.filter(c => getTask(c));\r\n\r\n  if (withTasks.length === 0) {\r\n    console.log('⚠️  No creeps have assigned tasks');\r\n    return;\r\n  }\r\n\r\n  section(`CREEP TASKS (${withTasks.length})`);\r\n\r\n  for (const creep of withTasks) {\r\n    const t = getTask(creep);\r\n    if (t) {\r\n      console.log(`  ${creep.name.padEnd(30)} | ${getTaskDescription(t)}`);\r\n    }\r\n  }\r\n\r\n  console.log();\r\n}\r\n\r\n/**\r\n * UNTASK - Clear task from a creep\r\n * \r\n * @param creepName - Name of creep to clear task from\r\n * @example untask('miner_123')\r\n */\r\nexport function untask(creepName: string): void {\r\n  const creep = Game.creeps[creepName];\r\n  if (!creep) {\r\n    console.log(`❌ Creep not found: ${creepName}`);\r\n    return;\r\n  }\r\n\r\n  clearTask(creep);\r\n  console.log(`✅ Cleared task from ${creepName}`);\r\n}\r\n\r\n/**\r\n * SCAN - Scan a room and register its structures\r\n * \r\n * @param roomName - Optional: Room to scan (defaults to current room, or all owned rooms if none)\r\n * @example scan()\r\n * @example scan('W1N1')\r\n */\r\nexport function scan(roomName?: string): void {\r\n  let targetRoom: Room | undefined;\r\n\r\n  if (roomName) {\r\n    targetRoom = Game.rooms[roomName];\r\n    if (!targetRoom) {\r\n      console.log(`❌ Room not found: ${roomName}`);\r\n      return;\r\n    }\r\n  } else {\r\n    // Try to get current room, fall back to all owned rooms\r\n    const currentRoomName = getCurrentRoom();\r\n    if (currentRoomName) {\r\n      targetRoom = Game.rooms[currentRoomName];\r\n    }\r\n  }\r\n\r\n  if (targetRoom) {\r\n    scanRoom(targetRoom);\r\n    console.log(`✅ Scanned room ${targetRoom.name}`);\r\n  } else {\r\n    // Scan all owned rooms\r\n    for (const room of Object.values(Game.rooms)) {\r\n      if (room.controller?.my) {\r\n        scanRoom(room);\r\n      }\r\n    }\r\n    console.log('✅ Scanned all owned rooms');\r\n  }\r\n}\r\n\r\n/**\r\n * STRUCTURES - List registered structures\r\n * \r\n * @param roomName - Optional: filter by room\r\n * @example structures()\r\n * @example structures('W1N1')\r\n */\r\nexport function structures(roomName?: string): void {\r\n  listStructures(roomName);\r\n}\r\n\r\n/**\r\n * LOCK - Lock a structure (prevent actions on it)\r\n * \r\n * @param nameOrId - Structure name or ID\r\n * @example lock('SourceA')\r\n * @example lock('SpawnMain')\r\n */\r\nexport function lock(nameOrId: string): void {\r\n  const success = lockStructure(nameOrId);\r\n  if (success) {\r\n    console.log(`🔒 Locked ${nameOrId}`);\r\n  } else {\r\n    console.log(`❌ Structure not found: ${nameOrId}`);\r\n  }\r\n}\r\n\r\n/**\r\n * UNLOCK - Unlock a structure\r\n * \r\n * @param nameOrId - Structure name or ID\r\n * @example unlock('SourceA')\r\n * @example unlock('SpawnMain')\r\n */\r\nexport function unlock(nameOrId: string): void {\r\n  const success = unlockStructure(nameOrId);\r\n  if (success) {\r\n    console.log(`🔓 Unlocked ${nameOrId}`);\r\n  } else {\r\n    console.log(`❌ Structure not found: ${nameOrId}`);\r\n  }\r\n}\r\n\r\n/**\r\n * LOCKED - View all locked structures\r\n * \r\n * @param roomName - Optional: filter by room\r\n * @example locked()\r\n * @example locked('W1N1')\r\n */\r\nexport function locked(roomName?: string): void {\r\n  const lockedStructs = getLockedStructures(roomName);\r\n\r\n  if (lockedStructs.length === 0) {\r\n    console.log('✅ No locked structures');\r\n    return;\r\n  }\r\n\r\n  section(`LOCKED STRUCTURES (${lockedStructs.length})`);\r\n\r\n  for (const info of lockedStructs) {\r\n    console.log(`  🔒 ${info.name.padEnd(25)} | ${info.type} | ${info.roomName}`);\r\n  }\r\n\r\n  console.log();\r\n}\r\n\r\n/**\r\n * RENAME - Rename a structure\r\n * \r\n * @param oldName - Current name or ID\r\n * @param newName - New name\r\n * @example rename('SourceA', 'MainSource')\r\n * @example rename('SpawnMain', 'SpawnPrimary')\r\n */\r\nexport function rename(oldName: string, newName: string): void {\r\n  const success = renameStructure(oldName, newName);\r\n  if (success) {\r\n    console.log(`✅ Renamed ${oldName} → ${newName}`);\r\n  } else {\r\n    console.log(`❌ Failed to rename (not found or name conflict)`);\r\n  }\r\n}\r\n\r\n/**\r\n * SHOWNALES - Display structure names as visual labels on the map\r\n * \r\n * @param roomName - Optional: Room to display labels in (defaults to current room)\r\n * @param duration - How many ticks to persist (default 3)\r\n * @example showNames('W1N1')\r\n * @example showNames()\r\n * @example showNames('W1N1', 10)\r\n */\r\nexport function showNames(roomName?: string, duration: number = 3): void {\r\n  const targetRoom = roomName || getCurrentRoom();\r\n  if (!targetRoom) {\r\n    console.log(`❌ No room specified and no current room found`);\r\n    return;\r\n  }\r\n\r\n  const room = Game.rooms[targetRoom];\r\n  if (!room) {\r\n    console.log(`❌ Room not found: ${targetRoom}`);\r\n    return;\r\n  }\r\n\r\n  visualShowNames(targetRoom, duration);\r\n  console.log(`👁️  Structure labels will display for ${duration} ticks`);\r\n}\r\n\r\n/**\r\n * HIDENAMES - Hide structure name displays\r\n * \r\n * @param roomName - Optional: Room to hide labels in (defaults to current room)\r\n * @example hideNames('W1N1')\r\n * @example hideNames()\r\n */\r\nexport function hideNames(roomName?: string): void {\r\n  const targetRoom = roomName || getCurrentRoom();\r\n  if (!targetRoom) {\r\n    console.log(`❌ No room specified and no current room found`);\r\n    return;\r\n  }\r\n\r\n  visualHideNames(targetRoom);\r\n}\r\n\r\n/**\r\n * LEGASTATUS - Show LegatusOficio status for a room\r\n * \r\n * @param roomName - Optional: Room to query (defaults to current room)\r\n * @example legaStatus('W1N1')\r\n * @example legaStatus()\r\n */\r\nexport function legaStatus(roomName?: string): void {\r\n  const targetRoom = roomName || getCurrentRoom();\r\n  if (!targetRoom) {\r\n    console.log(`❌ No room specified and no current room found`);\r\n    return;\r\n  }\r\n\r\n  const assignments = getRoomAssignments(targetRoom);\r\n  console.log(getLegaStatus(targetRoom));\r\n  \r\n  if (assignments.length > 0) {\r\n    console.log(`\\nActive Assignments:`);\r\n    for (const assignment of assignments) {\r\n      const ageTicks = Game.time - assignment.assignedAt;\r\n      console.log(\r\n        `  ${assignment.creepName.padEnd(30)} → ${assignment.command.type.padEnd(12)} (${ageTicks} ticks)`\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * LEGALIRT - List all Legatus assignments in a room\r\n * \r\n * @param roomName - Optional: Room to list (defaults to current room)\r\n * @example legaList('W1N1')\r\n * @example legaList()\r\n */\r\nexport function legaList(roomName?: string): void {\r\n  const targetRoom = roomName || getCurrentRoom();\r\n  if (!targetRoom) {\r\n    console.log(`❌ No room specified and no current room found`);\r\n    return;\r\n  }\r\n\r\n  listLegaAssignments(targetRoom);\r\n}\r\n\r\n/**\r\n * BODIES - List all registered body configurations\r\n * \r\n * @param role - Optional: filter by role\r\n * @example bodies()\r\n * @example bodies('miner')\r\n */\r\nexport function bodies(role?: string): void {\r\n  listBodyConfigs(role);\r\n}\r\n\r\n/**\r\n * REGBODY - Register a new body configuration\r\n * \r\n * @param name - Name of the body type\r\n * @param partsArray - Array of body parts\r\n * @param role - Optional: role this body is for\r\n * @example regBody('miner_v2', [WORK, WORK, CARRY, MOVE], 'miner')\r\n * @example regBody('scout', [MOVE])\r\n */\r\nexport function regBody(name: string, partsArray: BodyPartConstant[], role: string = 'generic'): void {\r\n  registerBody(name, partsArray, role);\r\n  const cost = getBodyCost(partsArray);\r\n  console.log(`✅ Registered body '${name}' (${partsArray.length} parts, ${cost}E)`);\r\n}\r\n\r\n/**\r\n * SPAWNWITH - Spawn a creep and immediately assign it a task\r\n * \r\n * Convenience command that combines spawnCreep() and task() in one call.\r\n * Useful for quickly spawning and directing creeps without two commands.\r\n * \r\n * @param role - Role name (miner, hauler, builder, upgrader)\r\n * @param body - Array of body parts OR registered body name\r\n * @param taskType - Task type (harvest, deliver, build, upgrade, move, repair, idle)\r\n * @param targetId - Target ID/name for the task (source name, structure ID, position, etc.)\r\n * @param roomName - Optional: room to spawn in (defaults to current room)\r\n * \r\n * @example spawnWith('miner', [WORK, WORK, CARRY, MOVE], 'harvest', 'SourceA')\r\n * @example spawnWith('hauler', [CARRY, CARRY, MOVE], 'deliver', 'Storage')\r\n * @example spawnWith('builder', 'builder_basic', 'build', 'SiteX')\r\n */\r\nexport function spawnWith(\r\n  role: string,\r\n  body: BodyPartConstant[] | string,\r\n  taskType: string,\r\n  targetId: string,\r\n  roomName?: string\r\n): Creep | false {\r\n  // First, spawn the creep\r\n  const creep = spawnCreep(role, body, roomName);\r\n  \r\n  if (!creep) {\r\n    console.log(`❌ Failed to spawn creep, skipping task assignment`);\r\n    return false;\r\n  }\r\n\r\n  // Then assign the task\r\n  task(creep.name, taskType, targetId);\r\n  \r\n  console.log(`✅ Spawned ${creep.name} with task: ${taskType} → ${targetId}`);\r\n  return creep;\r\n}\r\n\r\n/**\r\n * GETSTATS - Retrieve current statistics data from memory\r\n * \r\n * Returns all tracked statistics without logging them autonomously.\r\n * Use this at the end of an RCL to retrieve empirical data for analysis.\r\n * \r\n * @example getstats()                    // Returns full stats object\r\n * @example const data = getstats(); // Capture in console and copy to file\r\n */\r\nexport function getstats(): any {\r\n  if (!Memory.stats) {\r\n    console.log('❌ No statistics data available (not yet tracked)');\r\n    return null;\r\n  }\r\n  return Memory.stats;\r\n}\r\n\r\n/**\r\n * Register all console commands globally\r\n * This is called from main.ts to make all commands available\r\n */\r\nexport function registerConsoleCommands(): void {\r\n  (global as any).help = help;\r\n  (global as any).status = status;\r\n  (global as any).spawn = spawn;\r\n  (global as any).spawnCreep = spawnCreep;\r\n  (global as any).spawnWith = spawnWith;\r\n  (global as any).despawn = despawn;\r\n  (global as any).creeps = creeps;\r\n  (global as any).memory = memory;\r\n  (global as any).config = config;\r\n  (global as any).rooms = rooms;\r\n  (global as any).room = room;\r\n  (global as any).goto = goto;\r\n  (global as any).flag = flag;\r\n  (global as any).clear = clear;\r\n  (global as any).mode = mode;\r\n  (global as any).task = task;\r\n  (global as any).tasks = tasks;\r\n  (global as any).untask = untask;\r\n  (global as any).scan = scan;\r\n  (global as any).structures = structures;\r\n  (global as any).lock = lock;\r\n  (global as any).unlock = unlock;\r\n  (global as any).locked = locked;\r\n  (global as any).rename = rename;\r\n  (global as any).showNames = showNames;\r\n  (global as any).hideNames = hideNames;\r\n  (global as any).legaStatus = legaStatus;\r\n  (global as any).legaList = legaList;\r\n  (global as any).bodies = bodies;\r\n  (global as any).regBody = regBody;\r\n  (global as any).spawnWith = spawnWith;\r\n  (global as any).getstats = getstats;\r\n\r\n  console.log('✅ Console commands registered. Type help() for usage.');\r\n}\r\n","\nexport const BUILD_INFO = {\n  commitHash: 'f21b878',\n  commitMessage: 'Enhance stats tracking: Initialize energy, creepCounts, and spawn objects in Memory.stats. Update RCL history logging to handle undefined values gracefully.',\n  branch: 'main',\n  isDirty: true,\n  buildTime: '2025-10-18T17:52:25.128Z',\n  buildTimestamp: 1760809945129\n};\n\nexport const INIT_VERSION = 'f21b878';\n","/**\r\n * SILENT STATISTICS TRACKING\r\n * \r\n * Tracks RCL progression, creep composition, energy metrics, and performance data\r\n * completely silently in memory. Never logs to console.\r\n * \r\n * Data available at: Memory.stats\r\n */\r\n\r\n/**\r\n * Initialize stats tracking if not already present\r\n */\r\nexport function initializeStats(): void {\r\n  if (!Memory.stats) {\r\n    Memory.stats = {\r\n      rcl: 0,\r\n      ticksAtCurrentRcl: 0,\r\n      creepCounts: {\r\n        miner: 0,\r\n        hauler: 0,\r\n        builder: 0,\r\n        upgrader: 0,\r\n        total: 0\r\n      },\r\n      energy: {\r\n        available: 0,\r\n        capacity: 0,\r\n        harvestedThisTick: 0,\r\n        average5Tick: 0\r\n      },\r\n      spawn: {\r\n        totalSpawned: 0,\r\n        lastSpawnTime: 0,\r\n        avgSpawnTime: 0\r\n      },\r\n      rcl_history: []\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Update stats for current tick\r\n * Called once per tick from main game loop\r\n */\r\nexport function updateStats(room: Room): void {\r\n  if (!Memory.stats) initializeStats();\r\n\r\n  const stats = Memory.stats!;\r\n  \r\n  // Ensure all nested objects exist (safety check for existing memory)\r\n  if (!stats.rcl_history) {\r\n    stats.rcl_history = [];\r\n  }\r\n  if (!stats.energy) {\r\n    stats.energy = {\r\n      available: 0,\r\n      capacity: 0,\r\n      harvestedThisTick: 0,\r\n      average5Tick: 0\r\n    };\r\n  }\r\n  if (!stats.creepCounts) {\r\n    stats.creepCounts = {\r\n      miner: 0,\r\n      hauler: 0,\r\n      builder: 0,\r\n      upgrader: 0,\r\n      total: 0\r\n    };\r\n  }\r\n  if (!stats.spawn) {\r\n    stats.spawn = {\r\n      totalSpawned: 0,\r\n      lastSpawnTime: 0,\r\n      avgSpawnTime: 0\r\n    };\r\n  }\r\n  \r\n  const controller = room.controller;\r\n\r\n  // Update RCL and tick counter\r\n  if (controller) {\r\n    const currentRcl = controller.level;\r\n    if (currentRcl !== stats.rcl) {\r\n      // RCL changed - log to history and reset counter\r\n      stats.rcl_history.push({\r\n        rcl: stats.rcl || 0,\r\n        ticksToComplete: stats.ticksAtCurrentRcl || 0,\r\n        finalCreeps: { ...stats.creepCounts }\r\n      });\r\n      stats.rcl = currentRcl;\r\n      stats.ticksAtCurrentRcl = 0;\r\n    } else {\r\n      stats.ticksAtCurrentRcl = (stats.ticksAtCurrentRcl || 0) + 1;\r\n    }\r\n\r\n    // Update energy\r\n    stats.energy.available = room.energyAvailable;\r\n    stats.energy.capacity = room.energyCapacityAvailable;\r\n  }\r\n\r\n  // Count creeps by role\r\n  const creeps = room.find(FIND_MY_CREEPS);\r\n  const counts = {\r\n    miner: 0,\r\n    hauler: 0,\r\n    builder: 0,\r\n    upgrader: 0,\r\n    total: creeps.length\r\n  };\r\n\r\n  for (const creep of creeps) {\r\n    const role = creep.memory.role as string;\r\n    if (role in counts) {\r\n      (counts[role as keyof typeof counts] as number)++;\r\n    }\r\n  }\r\n\r\n  stats.creepCounts = counts;\r\n\r\n  // Track spawns (simple counter)\r\n  const spawns = room.find(FIND_MY_SPAWNS);\r\n  for (const spawn of spawns) {\r\n    if (spawn.spawning) {\r\n      stats.spawn.lastSpawnTime = Game.time;\r\n    }\r\n  }\r\n\r\n  // Calculate average spawn time (every 100 ticks check if we spawned)\r\n  if (Game.time % 100 === 0 && stats.spawn.lastSpawnTime > 0) {\r\n    const timeSinceLastSpawn = Game.time - stats.spawn.lastSpawnTime;\r\n    if (stats.spawn.avgSpawnTime === 0) {\r\n      stats.spawn.avgSpawnTime = timeSinceLastSpawn;\r\n    } else {\r\n      stats.spawn.avgSpawnTime = (stats.spawn.avgSpawnTime + timeSinceLastSpawn) / 2;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get current stats object\r\n * @returns Current stats from Memory\r\n */\r\nexport function getStats(): any {\r\n  if (!Memory.stats) initializeStats();\r\n  return Memory.stats!;\r\n}\r\n\r\n/**\r\n * Get RCL history (for analysis after completing RCL)\r\n * @returns Array of completed RCL data\r\n */\r\nexport function getRclHistory(): any[] {\r\n  if (!Memory.stats) initializeStats();\r\n  return Memory.stats!.rcl_history || [];\r\n}\r\n\r\n/**\r\n * Clear all stats (useful for starting fresh run)\r\n */\r\nexport function clearStats(): void {\r\n  Memory.stats = undefined;\r\n  initializeStats();\r\n}\r\n","/**\r\n * PROJECT IMPERIUM - RCL1 FOUNDATION\r\n * \r\n * Philosophy: Simple, tested, expandable\r\n * Strategy: Build RCL1 → Prove it works → Add RCL2\r\n * \r\n * \"Festina lente\" - Make haste slowly\r\n */\r\n\r\n/**\r\n * MAIN GAME LOOP\r\n * \r\n * This is the entry point for your Screeps AI.\r\n * Called once per game tick (every ~3 seconds in real-time).\r\n * \r\n * Architecture:\r\n * - src/main.ts - High-level game loop (this file)\r\n * - src/world/* - All game logic (rooms, creeps, spawns)\r\n * - src/types/* - Type definitions\r\n * \r\n * The world module handles:\r\n * - Room orchestration (spawning, creep management, statistics)\r\n * - Creep behaviors (harvester, upgrader, builder roles)\r\n * - Spawn management (priority system, body design)\r\n */\r\n\r\nimport { runRoom } from './world';\r\n// Import Traveler for its side effects: extends Creep.prototype with travelTo()\r\n// This enables all creeps to use: creep.travelTo(destination)\r\nimport './utils/traveler';\r\n// Import console commands and register them globally\r\nimport { registerConsoleCommands } from './utils/console';\r\n// Import empire mode system\r\nimport { displayModeInfo } from './world';\r\n// Import body config registration\r\nimport { registerDefaultBodies } from './world/spawns/bodies';\r\n// Import build information (injected at build time with commit hash)\r\nimport { INIT_VERSION, BUILD_INFO } from 'virtual-build-info';\r\n// Import silent statistics tracking\r\nimport { updateStats } from './world/stats';\r\n\r\n/**\r\n * Main game loop function.\r\n * Executed automatically by the Screeps game engine every tick.\r\n * \r\n * Responsibilities:\r\n * 1. Clean up memory for dead creeps (prevent memory leak)\r\n * 2. Process each owned room\r\n * \r\n * @remarks\r\n * Keep this function lightweight. Heavy logic should be in world module.\r\n * This makes testing easier and keeps the architecture clean.\r\n */\r\nexport const loop = (): void => {\r\n  // Initialize once using commit hash injected at build time\r\n  // INIT_VERSION is automatically updated on every rebuild (even if code doesn't change)\r\n  // because the commit hash changes when you push/commit\r\n  if (!Memory.initialized || (Memory.initVersion as string) !== INIT_VERSION) {\r\n    // Set flags FIRST to prevent double-init if loop runs again\r\n    Memory.initialized = true;\r\n    (Memory.initVersion as any) = INIT_VERSION;\r\n    \r\n    // Log build information on initialization\r\n    console.log('📦 Initializing with build: ' + BUILD_INFO.commitHash);\r\n    if (BUILD_INFO.isDirty) {\r\n      console.log('⚠️  Built from uncommitted changes');\r\n    }\r\n    \r\n    // Then run initialization functions\r\n    registerConsoleCommands();\r\n    displayModeInfo();\r\n    registerDefaultBodies();\r\n    console.log('📦 Default body configurations registered');\r\n  }\r\n\r\n  // Log main tick info (every 100 ticks to reduce console spam)\r\n  if (Game.time % 100 === 0) {\r\n    console.log(`⚔️ Tick ${Game.time} - PROJECT IMPERIUM - RCL1 FOUNDATION`);\r\n  }\r\n\r\n  // Clean up dead creep memory\r\n  // Without this, Memory.creeps grows forever and causes performance issues\r\n  cleanupDeadCreeps();\r\n\r\n  // Process each room we own\r\n  processOwnedRooms();\r\n};\r\n\r\n/**\r\n * Removes memory entries for creeps that no longer exist.\r\n * \r\n * When a creep dies, it's removed from Game.creeps but stays in Memory.creeps.\r\n * This cleanup prevents memory bloat over time.\r\n * \r\n * @remarks\r\n * This is called once per tick at the start of the main loop.\r\n * Memory is limited in Screeps, so cleanup is essential.\r\n */\r\nfunction cleanupDeadCreeps(): void {\r\n  for (const name in Memory.creeps) {\r\n    if (!(name in Game.creeps)) {\r\n      delete Memory.creeps[name];\r\n      console.log(`💀 Creep ${name} has fallen in battle`);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Processes all rooms under your control.\r\n * \r\n * Iterates through Game.rooms and runs logic for each room\r\n * that has a controller you own.\r\n * \r\n * @remarks\r\n * Game.rooms only contains visible rooms (ones you have creeps or structures in).\r\n * Rooms you don't control are skipped.\r\n */\r\nfunction processOwnedRooms(): void {\r\n  for (const roomName in Game.rooms) {\r\n    const room = Game.rooms[roomName];\r\n    \r\n    // Skip rooms we don't own (neutral or enemy rooms)\r\n    if (!room.controller || !room.controller.my) {\r\n      continue;\r\n    }\r\n\r\n    // Run all room logic via world module\r\n    runRoom(room);\r\n    \r\n    // Silently track statistics for data collection (no console logging ever)\r\n    updateStats(room);\r\n  }\r\n}\r\n"],"names":["deliverEnergy","upgradeControllerFallback","withdrawEnergy","countCreepsByRole","showNames","hideNames","visualShowNames","visualHideNames"],"mappings":"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"}