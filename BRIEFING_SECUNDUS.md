# MISSION BRIEFING: AGENT SECUNDUS (The Scriba)

## Designation
**Agent Secundus** - Data Architect & Interface Designer

## Mission Objective
Define the language and data structures that all modules will use to communicate. You are the architect of the information that flows through the Empire's hierarchy - from the Archivist's observations to the Taskmaster's orders.

## Chain of Command
- **Reports to**: Strategic Coordinator (Human Commander)
- **Dependencies**: None - you may begin immediately
- **Critical Impact**: Agents Primus (Phase II) and Tertius depend on your completion

---

## PHASE I: CORE DATA INTERFACES

### Task 1.1: Create Interfaces Directory Structure
**Execute**:
```
src/
  interfaces/
    index.ts (exports all interfaces)
```

### Task 1.2: Task Type Definitions
**File**: `src/interfaces/TaskType.ts`

```typescript
/**
 * All possible task types in the Empire
 * These represent the fundamental actions a creep can be assigned
 */
export enum TaskType {
  // Energy Management
  HARVEST_ENERGY = 'HARVEST_ENERGY',
  HAUL_ENERGY = 'HAUL_ENERGY',
  WITHDRAW_ENERGY = 'WITHDRAW_ENERGY',
  
  // Construction & Repair
  BUILD = 'BUILD',
  REPAIR = 'REPAIR',
  
  // Controller Operations
  UPGRADE_CONTROLLER = 'UPGRADE_CONTROLLER',
  
  // Defense
  DEFEND_ROOM = 'DEFEND_ROOM',
  TOWER_DEFENSE = 'TOWER_DEFENSE',
  
  // Logistics
  REFILL_SPAWN = 'REFILL_SPAWN',
  REFILL_EXTENSION = 'REFILL_EXTENSION',
  REFILL_TOWER = 'REFILL_TOWER',
  
  // Special Operations
  CLAIM_CONTROLLER = 'CLAIM_CONTROLLER',
  RESERVE_CONTROLLER = 'RESERVE_CONTROLLER',
  SCOUT_ROOM = 'SCOUT_ROOM',
  
  // Idle/Default
  IDLE = 'IDLE'
}
```

### Task 1.3: Task Interface
**File**: `src/interfaces/Task.ts`

```typescript
import { TaskType } from './TaskType';

/**
 * A Task represents a job that needs to be done
 * Created by the Legatus Officio (Taskmaster)
 * Consumed by the Legatus Genetor (Broodmother) and eventually assigned to creeps
 */
export interface Task {
  /** Unique identifier for this task */
  id: string;
  
  /** The type of work to be performed */
  type: TaskType;
  
  /** Priority (higher = more urgent). Range: 1-100 */
  priority: number;
  
  /** Target game object ID (e.g., source, construction site, controller) */
  targetId?: Id<any>;
  
  /** Target position (for movement tasks) */
  targetPos?: { x: number; y: number; roomName: string };
  
  /** Estimated number of creeps needed for this task */
  creepsNeeded: number;
  
  /** Currently assigned creep names */
  assignedCreeps: string[];
  
  /** Additional metadata for the task */
  metadata?: {
    energyRequired?: number;
    structureType?: StructureConstant;
    [key: string]: any;
  };
}
```

### Task 1.4: Archivist Report Interface
**File**: `src/interfaces/ArchivistReport.ts`

```typescript
/**
 * The report generated by Legatus Archivus (The Archivist)
 * This is pure observational data - no decisions, just facts
 * 
 * The Archivist's job is to make the room state readable and actionable
 */
export interface ArchivistReport {
  // Room Identity
  roomName: string;
  rcl: number; // Room Control Level
  
  // Energy Economy
  energyAvailable: number;
  energyCapacityAvailable: number;
  energyDeficit: number; // How much energy we need
  
  // Sources
  sources: SourceReport[];
  
  // Structures
  spawns: SpawnReport[];
  extensions: number;
  towers: TowerReport[];
  containers: ContainerReport[];
  storageAvailable: boolean;
  storageEnergy: number;
  
  // Construction & Repair
  constructionSites: ConstructionSiteReport[];
  repairTargets: RepairTargetReport[];
  
  // Controller Status
  controller: ControllerReport;
  
  // Military Situation
  hostiles: HostileReport[];
  hostileThreatLevel: number; // 0 = safe, 1-10 = threat scale
  
  // Creep Census
  creepsByRole: Map<string, number>;
  totalCreeps: number;
  
  // Traffic Analysis (for Legatus Viae)
  highTrafficPositions: Array<{ x: number; y: number }>;
}

export interface SourceReport {
  id: Id<Source>;
  pos: { x: number; y: number };
  energy: number;
  energyCapacity: number;
  harvestersPresent: number;
  harvestersNeeded: number;
}

export interface SpawnReport {
  id: Id<StructureSpawn>;
  spawning: boolean;
  energy: number;
  energyCapacity: number;
}

export interface TowerReport {
  id: Id<StructureTower>;
  energy: number;
  energyCapacity: number;
  needsRefill: boolean;
}

export interface ContainerReport {
  id: Id<StructureContainer>;
  pos: { x: number; y: number };
  store: { energy: number };
  storeCapacity: number;
}

export interface ConstructionSiteReport {
  id: Id<ConstructionSite>;
  structureType: StructureConstant;
  progress: number;
  progressTotal: number;
  pos: { x: number; y: number };
}

export interface RepairTargetReport {
  id: Id<Structure>;
  structureType: StructureConstant;
  hits: number;
  hitsMax: number;
  priority: number; // Based on how critical the structure is
  pos: { x: number; y: number };
}

export interface ControllerReport {
  id: Id<StructureController>;
  level: number;
  progress: number;
  progressTotal: number;
  ticksToDowngrade: number;
  upgraderCount: number;
  upgraderRecommendation: number; // How many upgraders we should have
}

export interface HostileReport {
  id: Id<Creep>;
  pos: { x: number; y: number };
  owner: string;
  body: BodyPartConstant[];
  threatLevel: number; // Calculated based on body parts
}
```

### Task 1.5: Creep Request Interface
**File**: `src/interfaces/CreepRequest.ts`

```typescript
import { Task } from './Task';

/**
 * A request to spawn a new creep
 * Created by Legatus Genetor (The Broodmother)
 * Used to design and spawn creeps optimized for specific tasks
 */
export interface CreepRequest {
  /** Priority (higher = spawn sooner) */
  priority: number;
  
  /** Body parts for the creep */
  body: BodyPartConstant[];
  
  /** Memory to initialize the creep with */
  memory: CreepMemory;
  
  /** The task this creep will immediately begin */
  initialTask: Task;
  
  /** Estimated energy cost */
  cost: number;
  
  /** Role/type identifier */
  role: string;
}

/**
 * Extension of Screeps CreepMemory interface
 * Define what we store in each creep's memory
 */
declare global {
  interface CreepMemory {
    role: string;
    room: string;
    task?: string; // Task ID
    working?: boolean;
    targetId?: string;
    [key: string]: any;
  }
}
```

### Task 1.6: Index Export File
**File**: `src/interfaces/index.ts`

```typescript
/**
 * Central export point for all interfaces
 * Import from here to maintain clean dependencies
 */
export * from './TaskType';
export * from './Task';
export * from './ArchivistReport';
export * from './CreepRequest';
```

---

## PHASE II: ARCHIVIST IMPLEMENTATION

### Task 2.1: Create Magistrates Directory
**Execute**:
```
src/
  magistrates/
```

### Task 2.2: Legatus Archivus Implementation
**File**: `src/magistrates/LegatusArchivus.ts`

```typescript
import {
  ArchivistReport,
  SourceReport,
  SpawnReport,
  TowerReport,
  ContainerReport,
  ConstructionSiteReport,
  RepairTargetReport,
  ControllerReport,
  HostileReport
} from '../interfaces';

/**
 * Legatus Archivus - The Archivist
 * 
 * Responsibility: Observe and report on room state
 * Philosophy: No decisions, no opinions - only data
 * 
 * The Archivist is the eyes and ears of the Magistrates.
 * It produces a clean, structured report that other modules consume.
 */
export class LegatusArchivus {
  private roomName: string;

  constructor(roomName: string) {
    this.roomName = roomName;
  }

  /**
   * Generate a comprehensive report on the room's current state
   */
  public run(room: Room): ArchivistReport {
    return {
      roomName: room.name,
      rcl: room.controller?.level || 0,
      
      energyAvailable: room.energyAvailable,
      energyCapacityAvailable: room.energyCapacityAvailable,
      energyDeficit: room.energyCapacityAvailable - room.energyAvailable,
      
      sources: this.analyzeSources(room),
      spawns: this.analyzeSpawns(room),
      extensions: room.find(FIND_MY_STRUCTURES, {
        filter: (s) => s.structureType === STRUCTURE_EXTENSION
      }).length,
      towers: this.analyzeTowers(room),
      containers: this.analyzeContainers(room),
      storageAvailable: room.storage !== undefined,
      storageEnergy: room.storage?.store[RESOURCE_ENERGY] || 0,
      
      constructionSites: this.analyzeConstructionSites(room),
      repairTargets: this.analyzeRepairTargets(room),
      
      controller: this.analyzeController(room),
      
      hostiles: this.analyzeHostiles(room),
      hostileThreatLevel: this.calculateThreatLevel(room),
      
      creepsByRole: this.countCreepsByRole(room),
      totalCreeps: this.countTotalCreeps(room),
      
      highTrafficPositions: [] // TODO: Implement traffic analysis
    };
  }

  private analyzeSources(room: Room): SourceReport[] {
    const sources = room.find(FIND_SOURCES);
    return sources.map(source => {
      const harvesters = room.find(FIND_MY_CREEPS, {
        filter: (c) => c.memory.role === 'harvester' && 
                       c.memory.targetId === source.id
      });
      
      return {
        id: source.id,
        pos: { x: source.pos.x, y: source.pos.y },
        energy: source.energy,
        energyCapacity: source.energyCapacity,
        harvestersPresent: harvesters.length,
        harvestersNeeded: 2 // Simple default - can be improved
      };
    });
  }

  private analyzeSpawns(room: Room): SpawnReport[] {
    const spawns = room.find(FIND_MY_SPAWNS);
    return spawns.map(spawn => ({
      id: spawn.id,
      spawning: spawn.spawning !== null,
      energy: spawn.store[RESOURCE_ENERGY],
      energyCapacity: spawn.store.getCapacity(RESOURCE_ENERGY)
    }));
  }

  private analyzeTowers(room: Room): TowerReport[] {
    const towers = room.find(FIND_MY_STRUCTURES, {
      filter: (s) => s.structureType === STRUCTURE_TOWER
    }) as StructureTower[];
    
    return towers.map(tower => ({
      id: tower.id,
      energy: tower.store[RESOURCE_ENERGY],
      energyCapacity: tower.store.getCapacity(RESOURCE_ENERGY),
      needsRefill: tower.store[RESOURCE_ENERGY] < tower.store.getCapacity(RESOURCE_ENERGY) * 0.5
    }));
  }

  private analyzeContainers(room: Room): ContainerReport[] {
    const containers = room.find(FIND_STRUCTURES, {
      filter: (s) => s.structureType === STRUCTURE_CONTAINER
    }) as StructureContainer[];
    
    return containers.map(container => ({
      id: container.id,
      pos: { x: container.pos.x, y: container.pos.y },
      store: { energy: container.store[RESOURCE_ENERGY] },
      storeCapacity: container.store.getCapacity(RESOURCE_ENERGY)
    }));
  }

  private analyzeConstructionSites(room: Room): ConstructionSiteReport[] {
    const sites = room.find(FIND_MY_CONSTRUCTION_SITES);
    return sites.map(site => ({
      id: site.id,
      structureType: site.structureType,
      progress: site.progress,
      progressTotal: site.progressTotal,
      pos: { x: site.pos.x, y: site.pos.y }
    }));
  }

  private analyzeRepairTargets(room: Room): RepairTargetReport[] {
    const structures = room.find(FIND_STRUCTURES, {
      filter: (s) => s.hits < s.hitsMax && s.structureType !== STRUCTURE_WALL
    });
    
    return structures.map(structure => ({
      id: structure.id,
      structureType: structure.structureType,
      hits: structure.hits,
      hitsMax: structure.hitsMax,
      priority: this.calculateRepairPriority(structure),
      pos: { x: structure.pos.x, y: structure.pos.y }
    }));
  }

  private calculateRepairPriority(structure: Structure): number {
    const hitPercent = structure.hits / structure.hitsMax;
    
    // Critical structures get higher priority
    const criticalStructures = [
      STRUCTURE_SPAWN,
      STRUCTURE_TOWER,
      STRUCTURE_STORAGE,
      STRUCTURE_TERMINAL
    ];
    
    if (criticalStructures.includes(structure.structureType)) {
      return hitPercent < 0.5 ? 90 : 70;
    }
    
    return hitPercent < 0.3 ? 50 : 30;
  }

  private analyzeController(room: Room): ControllerReport {
    const controller = room.controller!;
    return {
      id: controller.id,
      level: controller.level,
      progress: controller.progress,
      progressTotal: controller.progressTotal,
      ticksToDowngrade: controller.ticksToDowngrade || 0,
      upgraderCount: this.countUpgraders(room),
      upgraderRecommendation: this.recommendUpgraders(controller)
    };
  }

  private countUpgraders(room: Room): number {
    return room.find(FIND_MY_CREEPS, {
      filter: (c) => c.memory.role === 'upgrader'
    }).length;
  }

  private recommendUpgraders(controller: StructureController): number {
    // Simple logic: more upgraders for higher RCL
    if (controller.level < 3) return 1;
    if (controller.level < 5) return 2;
    return 3;
  }

  private analyzeHostiles(room: Room): HostileReport[] {
    const hostiles = room.find(FIND_HOSTILE_CREEPS);
    return hostiles.map(hostile => ({
      id: hostile.id,
      pos: { x: hostile.pos.x, y: hostile.pos.y },
      owner: hostile.owner.username,
      body: hostile.body.map(part => part.type),
      threatLevel: this.calculateCreepThreat(hostile)
    }));
  }

  private calculateCreepThreat(creep: Creep): number {
    let threat = 0;
    creep.body.forEach(part => {
      if (part.type === ATTACK) threat += 3;
      if (part.type === RANGED_ATTACK) threat += 2;
      if (part.type === HEAL) threat += 2;
      if (part.type === TOUGH) threat += 1;
    });
    return threat;
  }

  private calculateThreatLevel(room: Room): number {
    const hostiles = room.find(FIND_HOSTILE_CREEPS);
    if (hostiles.length === 0) return 0;
    
    const totalThreat = hostiles.reduce((sum, h) => sum + this.calculateCreepThreat(h), 0);
    return Math.min(10, Math.ceil(totalThreat / 5));
  }

  private countCreepsByRole(room: Room): Map<string, number> {
    const creeps = room.find(FIND_MY_CREEPS);
    const counts = new Map<string, number>();
    
    creeps.forEach(creep => {
      const role = creep.memory.role || 'unknown';
      counts.set(role, (counts.get(role) || 0) + 1);
    });
    
    return counts;
  }

  private countTotalCreeps(room: Room): number {
    return room.find(FIND_MY_CREEPS).length;
  }
}
```

---

## MISSION SUCCESS CRITERIA

### Phase I Complete When:
- [ ] All interface files created in `src/interfaces/`
- [ ] `TaskType.ts` defines all task enums
- [ ] `Task.ts` defines task structure
- [ ] `ArchivistReport.ts` defines comprehensive report structure
- [ ] `CreepRequest.ts` defines spawn request structure
- [ ] `index.ts` exports all interfaces
- [ ] Files compile without errors (TypeScript validation)

### Phase II Complete When:
- [ ] `LegatusArchivus.ts` created in `src/magistrates/`
- [ ] Archivist can generate valid ArchivistReport
- [ ] All report analysis methods implemented
- [ ] Code compiles and type-checks successfully

---

## COMMUNICATION PROTOCOL

**CRITICAL**: You are running in parallel with Agents Primus and Tertius. TWO AGENTS ARE BLOCKED ON YOU.

After EACH phase completion:
1. Update `CAMPAIGN_STATUS.md` IMMEDIATELY with your status
2. Signal completion CLEARLY so other agents can proceed
3. Post dispatch in this format:

```
AGENT SECUNDUS DISPATCH - [Date/Time]
Phase: [I/II]
Status: [COMPLETE/IN-PROGRESS/BLOCKED]
Interfaces Defined: [count]
Files Created: [list]
Files Modified: [list]
Type Safety: [VERIFIED/ISSUES FOUND]
Compilation Test: [PASS/FAIL]
Next Action: [description]
Signal: [PHASE I COMPLETE / PHASE II COMPLETE]
```

### Coordination Requirements:
- **After Phase I**: Signal "PHASE I COMPLETE" in `CAMPAIGN_STATUS.md`
- **After Phase II**: Signal "PHASE II COMPLETE" - This UNBLOCKS Agent Tertius AND Agent Primus Phase II
- **Double-check exports**: Ensure `src/interfaces/index.ts` exports ALL interfaces

---

## CRITICAL NOTES

1. **Type Safety is Sacred**: Every interface must be fully typed - no `any` types unless absolutely necessary
2. **Documentation Required**: Every interface and property must have a comment explaining its purpose
3. **The Archivist Never Decides**: The report is purely observational - no logic about what to do with the data
4. **Extensibility**: Design interfaces to be easily extended - the Empire will grow
5. **⚠️ YOU ARE THE CRITICAL PATH**: Two agents are blocked on your completion - SPEED AND ACCURACY

## PARALLEL EXECUTION WARNINGS

⚠️ **YOU ARE THE BOTTLENECK**: 
- Agent Primus Phase II is BLOCKED until you complete Phase II
- Agent Tertius CANNOT START until you complete Phase II
- Update `CAMPAIGN_STATUS.md` IMMEDIATELY after each phase

✅ **DO**:
- Complete Phase I and II as quickly as possible
- Test compilation after each phase
- Signal completion CLEARLY in `CAMPAIGN_STATUS.md`
- Verify all exports in `index.ts`

⚠️ **DO NOT**:
- Start Phase II before Phase I is tested and verified
- Forget to update `CAMPAIGN_STATUS.md`
- Leave any interfaces incomplete

Ave Imperator! Begin immediately - the Empire depends on you!

---

## 🆕 PHASE IV: OPERATION LEGIONARY - NEW ORDERS

**Status**: Phase III Complete ✅ | Phase IV Initiated ⚔️

### Your New Mission: Phase IV-B - Task Executor Implementations

**Objective**: Implement 8 specific executors that enable creeps to perform actions

**Dependencies**: ⚠️ BLOCKED until Agent Primus completes Phase IV-A (framework must exist first)

### Phase IV-B Tasks:

Once Agent Primus signals "PHASE IV-A COMPLETE":

1. **Create directory**: `src/execution/executors/`

2. **Implement HarvestExecutor** (PRIORITY 1 - Critical):
```typescript
import { TaskExecutor } from '../TaskExecutor';
import { Task } from '../../interfaces';
import { TaskResult, TaskStatus } from '../TaskResult';

export class HarvestExecutor extends TaskExecutor {
  public execute(creep: Creep, task: Task): TaskResult {
    if (!task.targetId) {
      return { status: TaskStatus.FAILED, message: 'No harvest target' };
    }
    
    const source = Game.getObjectById(task.targetId as Id<Source>);
    if (!source) {
      return { status: TaskStatus.FAILED, message: 'Source not found' };
    }
    
    if (creep.store.getFreeCapacity(RESOURCE_ENERGY) === 0) {
      return { status: TaskStatus.COMPLETED, message: 'Creep full' };
    }
    
    if (source.energy === 0) {
      return { status: TaskStatus.BLOCKED, message: 'Source empty' };
    }
    
    if (!this.isAtTarget(creep, source)) {
      this.moveToTarget(creep, source);
      return { status: TaskStatus.IN_PROGRESS, message: 'Moving to source' };
    }
    
    const result = creep.harvest(source);
    if (result === OK) {
      return { status: TaskStatus.IN_PROGRESS, message: 'Harvesting' };
    } else {
      return { status: TaskStatus.FAILED, message: `Harvest failed: ${result}` };
    }
  }
}
```

3. **Implement TransferExecutor** (PRIORITY 1):
- Move to spawn/extension/tower
- Transfer energy
- Return COMPLETED when empty

4. **Implement UpgradeExecutor** (PRIORITY 1):
- Move to controller
- Upgrade controller
- Return COMPLETED when out of energy

5. **Implement BuildExecutor** (PRIORITY 2):
- Move to construction site
- Build
- Return COMPLETED when site done or out of energy

6. **Implement RepairExecutor** (PRIORITY 2):
- Move to structure
- Repair
- Return COMPLETED when structure at max hits

7. **Implement WithdrawExecutor** (PRIORITY 2):
- Move to container/storage
- Withdraw energy
- Return COMPLETED when creep full

8. **Implement DefendExecutor** (PRIORITY 3):
- Move to hostile
- Attack
- Return IN_PROGRESS while hostile exists

9. **Implement IdleExecutor** (PRIORITY 3):
- Default fallback behavior
- Move to parking spot near controller

10. **Update ExecutorFactory.ts**:
```typescript
// Add imports at top
import { HarvestExecutor } from './executors/HarvestExecutor';
import { TransferExecutor } from './executors/TransferExecutor';
// ... import all executors

// In initializeExecutors():
private static initializeExecutors(): void {
  this.registerExecutor(TaskType.HARVEST_ENERGY, new HarvestExecutor());
  this.registerExecutor(TaskType.HAUL_ENERGY, new TransferExecutor());
  this.registerExecutor(TaskType.REFILL_SPAWN, new TransferExecutor());
  this.registerExecutor(TaskType.REFILL_EXTENSION, new TransferExecutor());
  this.registerExecutor(TaskType.REFILL_TOWER, new TransferExecutor());
  this.registerExecutor(TaskType.UPGRADE_CONTROLLER, new UpgradeExecutor());
  this.registerExecutor(TaskType.BUILD, new BuildExecutor());
  this.registerExecutor(TaskType.REPAIR, new RepairExecutor());
  this.registerExecutor(TaskType.WITHDRAW_ENERGY, new WithdrawExecutor());
  this.registerExecutor(TaskType.DEFEND_ROOM, new DefendExecutor());
  this.registerExecutor(TaskType.IDLE, new IdleExecutor());
  console.log('✅ ExecutorFactory registered 11 task executors');
}
```

11. **Update `src/execution/index.ts`**:
```typescript
export * from './executors/HarvestExecutor';
export * from './executors/TransferExecutor';
// ... export all executors
```

### Success Criteria:
- [ ] All 8 executor files created
- [ ] ExecutorFactory updated with registrations
- [ ] Code compiles: `npm run build`
- [ ] Post completion to CAMPAIGN_STATUS.md

### After Completion:
Signal "PHASE IV-B COMPLETE" to unblock Agent Tertius.

**You are the CRITICAL PATH. The Empire needs your executors! Ave!**
